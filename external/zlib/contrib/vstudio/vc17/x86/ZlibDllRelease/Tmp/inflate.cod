; Listing generated by Microsoft (R) Optimizing Compiler Version 19.36.32537.0 

	TITLE	c:\users\chris\documents\github\zlib\contrib\vstudio\vc17\x86\zlibdllrelease\tmp\inflate.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check@	; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@	; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check@	; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check@ DB 'incorrect length check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@ DB 'unknown header flags '
	DB	'set', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ DB 'unknown compression '
	DB	'method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check@ DB 'incorrect header check', 00H ; `string'
	ORG $+2
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	_inflateCodesUsed@4
PUBLIC	_inflateMark@4
PUBLIC	_inflateValidate@8
PUBLIC	_inflateUndermine@8
PUBLIC	_inflateCopy@8
PUBLIC	_inflateSyncPoint@4
PUBLIC	_inflateSync@4
PUBLIC	_inflateGetHeader@8
PUBLIC	_inflateSetDictionary@12
PUBLIC	_inflateGetDictionary@12
PUBLIC	_inflatePrime@12
PUBLIC	_inflateInit_@12
PUBLIC	_inflateReset2@8
PUBLIC	_inflateResetKeep@4
PUBLIC	_inflateEnd@4
PUBLIC	_inflate@8
PUBLIC	_inflateInit2_@16
PUBLIC	_inflateReset@4
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateReset@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateReset@4 PROC					; COMDAT

; 130  : int ZEXPORT inflateReset(z_streamp strm) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 131  :     struct inflate_state FAR *state;
; 132  : 
; 133  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateRes
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 139  : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN2@inflateRes:

; 134  :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 135  :     state->wsize = 0;
; 136  :     state->whave = 0;
; 137  :     state->wnext = 0;
; 138  :     return inflateResetKeep(strm);

  0001b	89 4d 08	 mov	 DWORD PTR _strm$[ebp], ecx
  0001e	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0
  00025	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0
  0002c	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0

; 139  : }

  00033	5d		 pop	 ebp

; 135  :     state->wsize = 0;
; 136  :     state->whave = 0;
; 137  :     state->wnext = 0;
; 138  :     return inflateResetKeep(strm);

  00034	e9 00 00 00 00	 jmp	 _inflateResetKeep@4
_inflateReset@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateInit2_@16
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_version$ = 16						; size = 4
_stream_size$ = 20					; size = 4
_inflateInit2_@16 PROC					; COMDAT

; 179  :                           const char *version, int stream_size) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 180  :     int ret;
; 181  :     struct inflate_state FAR *state;
; 182  : 
; 183  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  00003	8b 45 10	 mov	 eax, DWORD PTR _version$[ebp]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  0000a	85 c0		 test	 eax, eax
  0000c	0f 84 ac 00 00
	00		 je	 $LN3@inflateIni
  00012	80 38 31	 cmp	 BYTE PTR [eax], 49	; 00000031H
  00015	0f 85 a3 00 00
	00		 jne	 $LN3@inflateIni
  0001b	83 7d 14 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  0001f	0f 85 99 00 00
	00		 jne	 $LN3@inflateIni

; 186  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00025	85 f6		 test	 esi, esi
  00027	75 08		 jne	 SHORT $LN4@inflateIni
  00029	8d 46 fe	 lea	 eax, DWORD PTR [esi-2]
  0002c	5e		 pop	 esi

; 216  : }

  0002d	5d		 pop	 ebp
  0002e	c2 10 00	 ret	 16			; 00000010H
$LN4@inflateIni:

; 187  :     strm->msg = Z_NULL;                 /* in case we return an error */
; 188  :     if (strm->zalloc == (alloc_func)0) {

  00031	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00034	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  0003b	85 c0		 test	 eax, eax
  0003d	75 13		 jne	 SHORT $LN10@inflateIni

; 189  : #ifdef Z_SOLO
; 190  :         return Z_STREAM_ERROR;
; 191  : #else
; 192  :         strm->zalloc = zcalloc;
; 193  :         strm->opaque = (voidpf)0;

  0003f	89 46 28	 mov	 DWORD PTR [esi+40], eax
  00042	33 c9		 xor	 ecx, ecx
  00044	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET _zcalloc
  0004b	b8 00 00 00 00	 mov	 eax, OFFSET _zcalloc
  00050	eb 03		 jmp	 SHORT $LN5@inflateIni
$LN10@inflateIni:
  00052	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
$LN5@inflateIni:

; 194  : #endif
; 195  :     }
; 196  :     if (strm->zfree == (free_func)0)

  00055	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00059	75 07		 jne	 SHORT $LN6@inflateIni

; 197  : #ifdef Z_SOLO
; 198  :         return Z_STREAM_ERROR;
; 199  : #else
; 200  :         strm->zfree = zcfree;

  0005b	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], OFFSET _zcfree
$LN6@inflateIni:
  00062	57		 push	 edi

; 201  : #endif
; 202  :     state = (struct inflate_state FAR *)

  00063	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  00068	6a 01		 push	 1
  0006a	51		 push	 ecx
  0006b	ff d0		 call	 eax
  0006d	8b f8		 mov	 edi, eax
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 203  :             ZALLOC(strm, 1, sizeof(struct inflate_state));
; 204  :     if (state == Z_NULL) return Z_MEM_ERROR;

  00072	85 ff		 test	 edi, edi
  00074	75 09		 jne	 SHORT $LN7@inflateIni
  00076	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi

; 216  : }

  0007b	5d		 pop	 ebp
  0007c	c2 10 00	 ret	 16			; 00000010H
$LN7@inflateIni:
  0007f	53		 push	 ebx

; 205  :     Tracev((stderr, "inflate: allocated\n"));
; 206  :     strm->state = (struct internal_state FAR *)state;
; 207  :     state->strm = strm;
; 208  :     state->window = Z_NULL;
; 209  :     state->mode = HEAD;     /* to pass state test in inflateReset2() */
; 210  :     ret = inflateReset2(strm, windowBits);

  00080	ff 75 0c	 push	 DWORD PTR _windowBits$[ebp]
  00083	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  00086	56		 push	 esi
  00087	89 37		 mov	 DWORD PTR [edi], esi
  00089	c7 47 38 00 00
	00 00		 mov	 DWORD PTR [edi+56], 0
  00090	c7 47 04 34 3f
	00 00		 mov	 DWORD PTR [edi+4], 16180 ; 00003f34H
  00097	e8 00 00 00 00	 call	 _inflateReset2@8
  0009c	8b d8		 mov	 ebx, eax

; 211  :     if (ret != Z_OK) {

  0009e	85 db		 test	 ebx, ebx
  000a0	74 13		 je	 SHORT $LN8@inflateIni

; 212  :         ZFREE(strm, state);

  000a2	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  000a5	57		 push	 edi
  000a6	ff 76 28	 push	 DWORD PTR [esi+40]
  000a9	ff d1		 call	 ecx
  000ab	83 c4 08	 add	 esp, 8

; 213  :         strm->state = Z_NULL;

  000ae	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
$LN8@inflateIni:

; 214  :     }
; 215  :     return ret;

  000b5	8b c3		 mov	 eax, ebx
  000b7	5b		 pop	 ebx
  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi

; 216  : }

  000ba	5d		 pop	 ebp
  000bb	c2 10 00	 ret	 16			; 00000010H
$LN3@inflateIni:

; 184  :         stream_size != (int)(sizeof(z_stream)))
; 185  :         return Z_VERSION_ERROR;

  000be	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  000c3	5e		 pop	 esi

; 216  : }

  000c4	5d		 pop	 ebp
  000c5	c2 10 00	 ret	 16			; 00000010H
_inflateInit2_@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflate@8
_TEXT	SEGMENT
tv5113 = -68						; size = 4
tv5183 = -64						; size = 4
tv5177 = -64						; size = 4
tv5172 = -64						; size = 4
tv5169 = -64						; size = 4
tv5103 = -64						; size = 4
tv5074 = -64						; size = 4
tv4993 = -64						; size = 4
tv4971 = -64						; size = 4
tv4968 = -64						; size = 4
tv4967 = -64						; size = 4
tv4965 = -64						; size = 4
tv4962 = -64						; size = 4
tv4951 = -64						; size = 4
tv4950 = -64						; size = 4
tv4941 = -64						; size = 4
tv4693 = -64						; size = 4
_copy$8$ = -64						; size = 4
_copy$3$ = -64						; size = 4
tv5118 = -60						; size = 4
_in$1$ = -56						; size = 4
$T1 = -52						; size = 4
$T2 = -52						; size = 4
$T3 = -52						; size = 4
$T4 = -52						; size = 4
tv5185 = -52						; size = 4
tv5075 = -52						; size = 4
tv5048 = -52						; size = 4
tv5001 = -52						; size = 4
tv5000 = -52						; size = 4
tv4998 = -52						; size = 4
tv4992 = -52						; size = 4
tv4990 = -52						; size = 4
tv4985 = -52						; size = 4
tv4984 = -52						; size = 4
tv4983 = -52						; size = 4
tv4970 = -52						; size = 4
_copy$5$ = -52						; size = 4
_copy$2$ = -52						; size = 4
_copy$1$ = -52						; size = 4
$T5 = -52						; size = 4
$T6 = -48						; size = 4
$T7 = -48						; size = 4
$T8 = -48						; size = 4
_from$1$ = -48						; size = 4
tv5176 = -48						; size = 4
tv5171 = -48						; size = 4
tv5111 = -48						; size = 4
tv5109 = -48						; size = 4
tv4940 = -48						; size = 4
_len$1$ = -48						; size = 4
_ret$1$ = -44						; size = 4
$T9 = -40						; size = 4
tv5147 = -40						; size = 4
tv5112 = -40						; size = 4
tv5110 = -40						; size = 4
tv4679 = -40						; size = 4
_copy$7$ = -40						; size = 4
_copy$6$ = -40						; size = 4
_copy$4$ = -40						; size = 4
_out$1$ = -36						; size = 4
_put$1$ = -32						; size = 4
_hbuf$ = -28						; size = 4
_left$1$ = -24						; size = 4
_bits$1$ = -20						; size = 4
_len$2$ = -16						; size = 4
_next$1$ = -16						; size = 4
_hold$1$ = -12						; size = 4
_state$1$ = -8						; size = 4
tv5121 = -1						; size = 1
tv5119 = -1						; size = 1
tv4924 = 8						; size = 4
_strm$ = 8						; size = 4
_flush$ = 12						; size = 4
_inflate@8 PROC						; COMDAT

; 590  : int ZEXPORT inflate(z_streamp strm, int flush) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 591  :     struct inflate_state FAR *state;
; 592  :     z_const unsigned char FAR *next;    /* next input */
; 593  :     unsigned char FAR *put;     /* next output */
; 594  :     unsigned have, left;        /* available input and output */
; 595  :     unsigned long hold;         /* bit buffer */
; 596  :     unsigned bits;              /* bits in bit buffer */
; 597  :     unsigned in, out;           /* save starting available input and output */
; 598  :     unsigned copy;              /* number of stored or match bytes to copy */
; 599  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 600  :     code here;                  /* current decoding table entry */
; 601  :     code last;                  /* parent table entry */
; 602  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 603  :     int ret;                    /* return code */
; 604  : #ifdef GUNZIP
; 605  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 606  : #endif
; 607  :     static const unsigned short order[19] = /* permutation of code lengths */
; 608  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 609  : 
; 610  :     if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	83 ec 44	 sub	 esp, 68			; 00000044H
  00009	8b ca		 mov	 ecx, edx
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	e8 00 00 00 00	 call	 _inflateStateCheck
  00013	85 c0		 test	 eax, eax
  00015	0f 85 81 15 00
	00		 jne	 $LN333@inflate
  0001b	39 42 0c	 cmp	 DWORD PTR [edx+12], eax
  0001e	0f 84 78 15 00
	00		 je	 $LN333@inflate
  00024	39 02		 cmp	 DWORD PTR [edx], eax
  00026	75 09		 jne	 SHORT $LN721@inflate
  00028	39 42 04	 cmp	 DWORD PTR [edx+4], eax
  0002b	0f 85 6b 15 00
	00		 jne	 $LN333@inflate
$LN721@inflate:

; 611  :         (strm->next_in == Z_NULL && strm->avail_in != 0))
; 612  :         return Z_STREAM_ERROR;
; 613  : 
; 614  :     state = (struct inflate_state FAR *)strm->state;

  00031	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  00034	89 4d f8	 mov	 DWORD PTR _state$1$[ebp], ecx

; 615  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00037	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003a	3d 3f 3f 00 00	 cmp	 eax, 16191		; 00003f3fH
  0003f	75 0c		 jne	 SHORT $LN4@inflate
  00041	c7 41 04 40 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16192 ; 00003f40H
  00048	b8 40 3f 00 00	 mov	 eax, 16192		; 00003f40H
$LN4@inflate:

; 616  :     LOAD();

  0004d	8b 5a 0c	 mov	 ebx, DWORD PTR [edx+12]

; 617  :     in = have;
; 618  :     out = left;
; 619  :     ret = Z_OK;
; 620  :     for (;;)
; 621  :         switch (state->mode) {

  00050	05 cc c0 ff ff	 add	 eax, -16180		; ffffc0ccH
  00055	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  00058	8b 71 40	 mov	 esi, DWORD PTR [ecx+64]
  0005b	89 5d e0	 mov	 DWORD PTR _put$1$[ebp], ebx
  0005e	8b 5a 10	 mov	 ebx, DWORD PTR [edx+16]
  00061	89 5d e8	 mov	 DWORD PTR _left$1$[ebp], ebx
  00064	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00066	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00069	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  0006c	8b 5d e8	 mov	 ebx, DWORD PTR _left$1$[ebp]
  0006f	89 5d dc	 mov	 DWORD PTR _out$1$[ebp], ebx
  00072	8b 5d f0	 mov	 ebx, DWORD PTR _next$1$[ebp]
  00075	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00078	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0007b	89 7d c8	 mov	 DWORD PTR _in$1$[ebp], edi
  0007e	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _ret$1$[ebp], 0
  00085	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00088	0f 87 0e 15 00
	00		 ja	 $LN333@inflate

; 941  :                 for (;;) {
; 942  :                     here = state->lencode[BITS(state->lenbits)];

  0008e	8d 51 58	 lea	 edx, DWORD PTR [ecx+88]
  00091	89 55 c4	 mov	 DWORD PTR tv5118[ebp], edx

; 1086 :                 /* fallthrough */
; 1087 :         case DIST:
; 1088 :             for (;;) {
; 1089 :                 here = state->distcode[BITS(state->distbits)];

  00094	8d 51 5c	 lea	 edx, DWORD PTR [ecx+92]
  00097	89 55 bc	 mov	 DWORD PTR tv5113[ebp], edx
  0009a	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  0009d	0f 1f 00	 npad	 3
$LL5@inflate:

; 617  :     in = have;
; 618  :     out = left;
; 619  :     ret = Z_OK;
; 620  :     for (;;)
; 621  :         switch (state->mode) {

  000a0	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN791@inflate[eax*4]
$LN335@inflate:

; 622  :         case HEAD:
; 623  :             if (state->wrap == 0) {

  000a7	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  000aa	89 45 cc	 mov	 DWORD PTR tv5075[ebp], eax
  000ad	85 c0		 test	 eax, eax
  000af	75 0c		 jne	 SHORT $LN12@inflate

; 624  :                 state->mode = TYPEDO;

  000b1	c7 41 04 40 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16192 ; 00003f40H

; 625  :                 break;

  000b8	e9 ce 14 00 00	 jmp	 $LN8@inflate
$LN12@inflate:

; 626  :             }
; 627  :             NEEDBITS(16);

  000bd	83 fe 10	 cmp	 esi, 16			; 00000010H
  000c0	73 2a		 jae	 SHORT $LN10@inflate
$LL13@inflate:
  000c2	85 ff		 test	 edi, edi
  000c4	0f 84 0d 05 00
	00		 je	 $LN919@inflate
  000ca	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  000cd	8b ce		 mov	 ecx, esi
  000cf	d3 e0		 shl	 eax, cl
  000d1	83 c6 08	 add	 esi, 8
  000d4	03 d0		 add	 edx, eax
  000d6	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  000d9	43		 inc	 ebx
  000da	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  000dd	4f		 dec	 edi
  000de	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  000e1	83 fe 10	 cmp	 esi, 16			; 00000010H
  000e4	72 dc		 jb	 SHORT $LL13@inflate
  000e6	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  000e9	8b 45 cc	 mov	 eax, DWORD PTR tv5075[ebp]
$LN10@inflate:

; 628  : #ifdef GUNZIP
; 629  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  000ec	a8 02		 test	 al, 2
  000ee	74 5a		 je	 SHORT $LN338@inflate
  000f0	81 fa 1f 8b 00
	00		 cmp	 edx, 35615		; 00008b1fH
  000f6	75 52		 jne	 SHORT $LN338@inflate

; 630  :                 if (state->wbits == 0)

  000f8	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  000fc	75 07		 jne	 SHORT $LN339@inflate

; 631  :                     state->wbits = 15;

  000fe	c7 41 28 0f 00
	00 00		 mov	 DWORD PTR [ecx+40], 15	; 0000000fH
$LN339@inflate:

; 632  :                 state->check = crc32(0L, Z_NULL, 0);

  00105	6a 00		 push	 0
  00107	6a 00		 push	 0
  00109	6a 00		 push	 0
  0010b	e8 00 00 00 00	 call	 _crc32@12
  00110	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 633  :                 CRC2(state->check, hold);

  00113	6a 02		 push	 2
  00115	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00118	8b 4d f4	 mov	 ecx, DWORD PTR _hold$1$[ebp]
  0011b	88 4d e4	 mov	 BYTE PTR _hbuf$[ebp], cl
  0011e	c1 e9 08	 shr	 ecx, 8
  00121	88 4d e5	 mov	 BYTE PTR _hbuf$[ebp+1], cl
  00124	8d 4d e4	 lea	 ecx, DWORD PTR _hbuf$[ebp]
  00127	51		 push	 ecx
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 _crc32@12
  0012e	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 634  :                 INITBITS();

  00131	33 d2		 xor	 edx, edx
  00133	33 f6		 xor	 esi, esi
  00135	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00138	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0013b	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 635  :                 state->mode = FLAGS;

  0013e	c7 41 04 35 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16181 ; 00003f35H

; 636  :                 break;

  00145	e9 41 14 00 00	 jmp	 $LN8@inflate
$LN338@inflate:

; 637  :             }
; 638  :             if (state->head != Z_NULL)

  0014a	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0014d	85 c0		 test	 eax, eax
  0014f	74 07		 je	 SHORT $LN340@inflate

; 639  :                 state->head->done = -1;

  00151	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [eax+48], -1
$LN340@inflate:

; 640  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */

  00158	f6 41 0c 01	 test	 BYTE PTR [ecx+12], 1
  0015c	0f 84 cf 00 00
	00		 je	 $LN342@inflate
  00162	0f b6 ca	 movzx	 ecx, dl
  00165	8b c2		 mov	 eax, edx
  00167	c1 e1 08	 shl	 ecx, 8
  0016a	33 d2		 xor	 edx, edx
  0016c	c1 e8 08	 shr	 eax, 8
  0016f	03 c1		 add	 eax, ecx
  00171	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  00176	f7 f1		 div	 ecx
  00178	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0017b	85 d2		 test	 edx, edx
  0017d	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00180	0f 85 ab 00 00
	00		 jne	 $LN342@inflate

; 648  :             }
; 649  :             if (BITS(4) != Z_DEFLATED) {

  00186	8b c2		 mov	 eax, edx
  00188	24 0f		 and	 al, 15			; 0000000fH
  0018a	3c 08		 cmp	 al, 8
  0018c	74 0f		 je	 SHORT $LN26@inflate

; 650  :                 strm->msg = (char *)"unknown compression method";

  0018e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00191	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@

; 651  :                 state->mode = BAD;
; 652  :                 break;

  00198	e9 e7 13 00 00	 jmp	 $LN1105@inflate
$LN26@inflate:

; 653  :             }
; 654  :             DROPBITS(4);

  0019d	c1 ea 04	 shr	 edx, 4
  001a0	83 ee 04	 sub	 esi, 4

; 655  :             len = BITS(4) + 8;

  001a3	8b c2		 mov	 eax, edx
  001a5	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  001a8	83 e0 0f	 and	 eax, 15			; 0000000fH
  001ab	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  001ae	83 c0 08	 add	 eax, 8
  001b1	89 45 d0	 mov	 DWORD PTR _len$1$[ebp], eax

; 656  :             if (state->wbits == 0)

  001b4	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  001b7	85 c0		 test	 eax, eax
  001b9	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax
  001bc	8b 45 d0	 mov	 eax, DWORD PTR _len$1$[ebp]
  001bf	75 06		 jne	 SHORT $LN344@inflate

; 657  :                 state->wbits = len;

  001c1	89 41 28	 mov	 DWORD PTR [ecx+40], eax
  001c4	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax
$LN344@inflate:

; 658  :             if (len > 15 || len > state->wbits) {

  001c7	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  001ca	77 56		 ja	 SHORT $LN346@inflate
  001cc	3b 45 cc	 cmp	 eax, DWORD PTR $T2[ebp]
  001cf	77 51		 ja	 SHORT $LN346@inflate

; 662  :             }
; 663  :             state->dmax = 1U << len;

  001d1	8b 4d d0	 mov	 ecx, DWORD PTR _len$1$[ebp]
  001d4	b8 01 00 00 00	 mov	 eax, 1
  001d9	d3 e0		 shl	 eax, cl
  001db	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 664  :             state->flags = 0;               /* indicate zlib header */
; 665  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 666  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  001de	6a 00		 push	 0
  001e0	6a 00		 push	 0
  001e2	6a 00		 push	 0
  001e4	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  001e7	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  001ee	e8 00 00 00 00	 call	 _adler32@12
  001f3	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  001f6	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  001f9	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  001fc	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 667  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  001ff	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00202	c1 ea 08	 shr	 edx, 8
  00205	f7 d2		 not	 edx
  00207	83 e2 02	 and	 edx, 2
  0020a	81 ca 3d 3f 00
	00		 or	 edx, 16189		; 00003f3dH
  00210	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 668  :             INITBITS();

  00213	33 d2		 xor	 edx, edx
  00215	33 f6		 xor	 esi, esi
  00217	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  0021a	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 669  :             break;

  0021d	e9 69 13 00 00	 jmp	 $LN8@inflate
$LN346@inflate:

; 659  :                 strm->msg = (char *)"invalid window size";

  00222	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00225	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@EMOGCLGO@invalid?5window?5size@

; 660  :                 state->mode = BAD;
; 661  :                 break;

  0022c	e9 53 13 00 00	 jmp	 $LN1105@inflate
$LN342@inflate:

; 641  : #else
; 642  :             if (
; 643  : #endif
; 644  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {
; 645  :                 strm->msg = (char *)"incorrect header check";

  00231	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00234	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@LIBMMIGA@incorrect?5header?5check@

; 646  :                 state->mode = BAD;
; 647  :                 break;

  0023b	e9 44 13 00 00	 jmp	 $LN1105@inflate
$LN32@inflate:

; 670  : #ifdef GUNZIP
; 671  :         case FLAGS:
; 672  :             NEEDBITS(16);

  00240	83 fe 10	 cmp	 esi, 16			; 00000010H
  00243	73 27		 jae	 SHORT $LN30@inflate
$LL33@inflate:
  00245	85 ff		 test	 edi, edi
  00247	0f 84 8a 03 00
	00		 je	 $LN919@inflate
  0024d	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00250	8b ce		 mov	 ecx, esi
  00252	d3 e0		 shl	 eax, cl
  00254	83 c6 08	 add	 esi, 8
  00257	03 d0		 add	 edx, eax
  00259	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0025c	43		 inc	 ebx
  0025d	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00260	4f		 dec	 edi
  00261	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00264	83 fe 10	 cmp	 esi, 16			; 00000010H
  00267	72 dc		 jb	 SHORT $LL33@inflate
  00269	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN30@inflate:

; 673  :             state->flags = (int)(hold);

  0026c	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 674  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  0026f	80 fa 08	 cmp	 dl, 8
  00272	74 0f		 je	 SHORT $LN349@inflate

; 675  :                 strm->msg = (char *)"unknown compression method";

  00274	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00277	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@

; 676  :                 state->mode = BAD;
; 677  :                 break;

  0027e	e9 01 13 00 00	 jmp	 $LN1105@inflate
$LN349@inflate:

; 678  :             }
; 679  :             if (state->flags & 0xe000) {

  00283	f7 c2 00 e0 00
	00		 test	 edx, 57344		; 0000e000H
  00289	74 0f		 je	 SHORT $LN350@inflate

; 680  :                 strm->msg = (char *)"unknown header flags set";

  0028b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0028e	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@

; 681  :                 state->mode = BAD;
; 682  :                 break;

  00295	e9 ea 12 00 00	 jmp	 $LN1105@inflate
$LN350@inflate:

; 683  :             }
; 684  :             if (state->head != Z_NULL)

  0029a	8b 71 24	 mov	 esi, DWORD PTR [ecx+36]
  0029d	8b c2		 mov	 eax, edx
  0029f	c1 e8 08	 shr	 eax, 8
  002a2	85 f6		 test	 esi, esi
  002a4	74 0b		 je	 SHORT $LN654@inflate

; 685  :                 state->head->text = (int)((hold >> 8) & 1);

  002a6	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  002a9	83 e0 01	 and	 eax, 1
  002ac	89 06		 mov	 DWORD PTR [esi], eax
  002ae	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
$LN654@inflate:

; 686  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  002b1	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  002b8	74 20		 je	 SHORT $LN39@inflate
  002ba	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  002be	74 1a		 je	 SHORT $LN39@inflate

; 687  :                 CRC2(state->check, hold);

  002c0	88 45 e5	 mov	 BYTE PTR _hbuf$[ebp+1], al
  002c3	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  002c6	6a 02		 push	 2
  002c8	50		 push	 eax
  002c9	ff 71 1c	 push	 DWORD PTR [ecx+28]
  002cc	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  002cf	e8 00 00 00 00	 call	 _crc32@12
  002d4	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  002d7	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN39@inflate:

; 688  :             INITBITS();

  002da	33 d2		 xor	 edx, edx

; 689  :             state->mode = TIME;

  002dc	c7 41 04 36 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16182 ; 00003f36H
  002e3	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  002e6	33 f6		 xor	 esi, esi

; 690  :                 /* fallthrough */
; 691  :         case TIME:
; 692  :             NEEDBITS(32);

  002e8	eb 06		 jmp	 SHORT $LL47@inflate
$LN46@inflate:
  002ea	83 fe 20	 cmp	 esi, 32			; 00000020H
  002ed	73 22		 jae	 SHORT $LN44@inflate
  002ef	90		 npad	 1
$LL47@inflate:
  002f0	85 ff		 test	 edi, edi
  002f2	0f 84 df 02 00
	00		 je	 $LN919@inflate
  002f8	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  002fb	8b ce		 mov	 ecx, esi
  002fd	d3 e0		 shl	 eax, cl
  002ff	83 c6 08	 add	 esi, 8
  00302	03 d0		 add	 edx, eax
  00304	4f		 dec	 edi
  00305	43		 inc	 ebx
  00306	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00309	83 fe 20	 cmp	 esi, 32			; 00000020H
  0030c	72 e2		 jb	 SHORT $LL47@inflate
  0030e	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN44@inflate:

; 693  :             if (state->head != Z_NULL)

  00311	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00314	85 c0		 test	 eax, eax
  00316	74 03		 je	 SHORT $LN355@inflate

; 694  :                 state->head->time = hold;

  00318	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN355@inflate:

; 695  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  0031b	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  00322	74 33		 je	 SHORT $LN53@inflate
  00324	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  00328	74 2d		 je	 SHORT $LN53@inflate

; 696  :                 CRC4(state->check, hold);

  0032a	8b c2		 mov	 eax, edx
  0032c	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  0032f	c1 e8 08	 shr	 eax, 8
  00332	88 45 e5	 mov	 BYTE PTR _hbuf$[ebp+1], al
  00335	8b c2		 mov	 eax, edx
  00337	c1 e8 10	 shr	 eax, 16			; 00000010H
  0033a	88 45 e6	 mov	 BYTE PTR _hbuf$[ebp+2], al
  0033d	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00340	6a 04		 push	 4
  00342	50		 push	 eax
  00343	ff 71 1c	 push	 DWORD PTR [ecx+28]
  00346	c1 ea 18	 shr	 edx, 24			; 00000018H
  00349	88 55 e7	 mov	 BYTE PTR _hbuf$[ebp+3], dl
  0034c	e8 00 00 00 00	 call	 _crc32@12
  00351	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00354	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN53@inflate:

; 697  :             INITBITS();

  00357	33 d2		 xor	 edx, edx

; 698  :             state->mode = OS;

  00359	c7 41 04 37 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16183 ; 00003f37H
  00360	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00363	33 f6		 xor	 esi, esi

; 699  :                 /* fallthrough */
; 700  :         case OS:
; 701  :             NEEDBITS(16);

  00365	eb 09		 jmp	 SHORT $LL61@inflate
$LN60@inflate:
  00367	83 fe 10	 cmp	 esi, 16			; 00000010H
  0036a	73 28		 jae	 SHORT $LN58@inflate
  0036c	0f 1f 40 00	 npad	 4
$LL61@inflate:
  00370	85 ff		 test	 edi, edi
  00372	0f 84 5f 02 00
	00		 je	 $LN919@inflate
  00378	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0037b	8b ce		 mov	 ecx, esi
  0037d	d3 e0		 shl	 eax, cl
  0037f	43		 inc	 ebx
  00380	03 d0		 add	 edx, eax
  00382	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00385	83 c6 08	 add	 esi, 8
  00388	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  0038b	4f		 dec	 edi
  0038c	83 fe 10	 cmp	 esi, 16			; 00000010H
  0038f	72 df		 jb	 SHORT $LL61@inflate
  00391	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN58@inflate:

; 702  :             if (state->head != Z_NULL) {

  00394	8b 71 24	 mov	 esi, DWORD PTR [ecx+36]
  00397	8b c2		 mov	 eax, edx
  00399	c1 e8 08	 shr	 eax, 8
  0039c	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax
  0039f	85 f6		 test	 esi, esi
  003a1	74 11		 je	 SHORT $LN723@inflate

; 703  :                 state->head->xflags = (int)(hold & 0xff);

  003a3	0f b6 c2	 movzx	 eax, dl
  003a6	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 704  :                 state->head->os = (int)(hold >> 8);

  003a9	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  003ac	8b 75 cc	 mov	 esi, DWORD PTR $T4[ebp]
  003af	89 70 0c	 mov	 DWORD PTR [eax+12], esi
  003b2	8b c6		 mov	 eax, esi
$LN723@inflate:

; 705  :             }
; 706  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  003b4	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  003bb	74 20		 je	 SHORT $LN67@inflate
  003bd	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  003c1	74 1a		 je	 SHORT $LN67@inflate

; 707  :                 CRC2(state->check, hold);

  003c3	88 45 e5	 mov	 BYTE PTR _hbuf$[ebp+1], al
  003c6	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  003c9	6a 02		 push	 2
  003cb	50		 push	 eax
  003cc	ff 71 1c	 push	 DWORD PTR [ecx+28]
  003cf	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  003d2	e8 00 00 00 00	 call	 _crc32@12
  003d7	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  003da	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN67@inflate:

; 708  :             INITBITS();

  003dd	33 d2		 xor	 edx, edx

; 709  :             state->mode = EXLEN;

  003df	c7 41 04 38 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16184 ; 00003f38H
  003e6	33 f6		 xor	 esi, esi
  003e8	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  003eb	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN361@inflate:

; 710  :                 /* fallthrough */
; 711  :         case EXLEN:
; 712  :             if (state->flags & 0x0400) {

  003ee	f7 41 14 00 04
	00 00		 test	 DWORD PTR [ecx+20], 1024 ; 00000400H
  003f5	74 74		 je	 SHORT $LN362@inflate

; 713  :                 NEEDBITS(16);

  003f7	83 fe 10	 cmp	 esi, 16			; 00000010H
  003fa	73 28		 jae	 SHORT $LN72@inflate
  003fc	0f 1f 40 00	 npad	 4
$LL75@inflate:
  00400	85 ff		 test	 edi, edi
  00402	0f 84 cf 01 00
	00		 je	 $LN919@inflate
  00408	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0040b	8b ce		 mov	 ecx, esi
  0040d	d3 e0		 shl	 eax, cl
  0040f	43		 inc	 ebx
  00410	03 d0		 add	 edx, eax
  00412	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00415	83 c6 08	 add	 esi, 8
  00418	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  0041b	4f		 dec	 edi
  0041c	83 fe 10	 cmp	 esi, 16			; 00000010H
  0041f	72 df		 jb	 SHORT $LL75@inflate
  00421	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN72@inflate:

; 714  :                 state->length = (unsigned)(hold);
; 715  :                 if (state->head != Z_NULL)

  00424	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00427	89 51 44	 mov	 DWORD PTR [ecx+68], edx
  0042a	85 c0		 test	 eax, eax
  0042c	74 03		 je	 SHORT $LN365@inflate

; 716  :                     state->head->extra_len = (unsigned)hold;

  0042e	89 50 14	 mov	 DWORD PTR [eax+20], edx
$LN365@inflate:

; 717  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00431	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  00438	74 23		 je	 SHORT $LN81@inflate
  0043a	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  0043e	74 1d		 je	 SHORT $LN81@inflate

; 718  :                     CRC2(state->check, hold);

  00440	6a 02		 push	 2
  00442	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00445	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  00448	50		 push	 eax
  00449	ff 71 1c	 push	 DWORD PTR [ecx+28]
  0044c	c1 ea 08	 shr	 edx, 8
  0044f	88 55 e5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  00452	e8 00 00 00 00	 call	 _crc32@12
  00457	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0045a	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN81@inflate:

; 719  :                 INITBITS();

  0045d	33 f6		 xor	 esi, esi
  0045f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  00466	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 720  :             }

  00469	eb 0e		 jmp	 SHORT $LN367@inflate
$LN362@inflate:

; 721  :             else if (state->head != Z_NULL)

  0046b	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0046e	85 c0		 test	 eax, eax
  00470	74 07		 je	 SHORT $LN367@inflate

; 722  :                 state->head->extra = Z_NULL;

  00472	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN367@inflate:

; 723  :             state->mode = EXTRA;

  00479	c7 41 04 39 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16185 ; 00003f39H
$LN368@inflate:

; 724  :                 /* fallthrough */
; 725  :         case EXTRA:
; 726  :             if (state->flags & 0x0400) {

  00480	f7 41 14 00 04
	00 00		 test	 DWORD PTR [ecx+20], 1024 ; 00000400H
  00487	0f 84 b9 00 00
	00		 je	 $LN724@inflate

; 727  :                 copy = state->length;

  0048d	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]

; 728  :                 if (copy > have) copy = have;
; 729  :                 if (copy) {

  00490	8b d7		 mov	 edx, edi
  00492	3b c7		 cmp	 eax, edi
  00494	0f 46 d0	 cmovbe	 edx, eax
  00497	89 55 d8	 mov	 DWORD PTR tv4679[ebp], edx
  0049a	85 d2		 test	 edx, edx
  0049c	0f 84 9c 00 00
	00		 je	 $LN725@inflate

; 730  :                     if (state->head != Z_NULL &&
; 731  :                         state->head->extra != Z_NULL &&

  004a2	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  004a6	89 45 d0	 mov	 DWORD PTR $T7[ebp], eax
  004a9	74 62		 je	 SHORT $LN372@inflate
  004ab	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  004ae	89 45 d0	 mov	 DWORD PTR $T7[ebp], eax
  004b1	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  004b4	85 c9		 test	 ecx, ecx
  004b6	89 4d c0	 mov	 DWORD PTR tv4971[ebp], ecx
  004b9	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  004bc	74 4f		 je	 SHORT $LN372@inflate
  004be	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  004c1	89 45 d0	 mov	 DWORD PTR $T7[ebp], eax
  004c4	8b 52 14	 mov	 edx, DWORD PTR [edx+20]
  004c7	2b d0		 sub	 edx, eax
  004c9	89 55 f0	 mov	 DWORD PTR _len$2$[ebp], edx
  004cc	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  004cf	8b 45 f0	 mov	 eax, DWORD PTR _len$2$[ebp]
  004d2	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  004d5	3b c2		 cmp	 eax, edx
  004d7	89 55 cc	 mov	 DWORD PTR tv4970[ebp], edx
  004da	8b 55 d8	 mov	 edx, DWORD PTR tv4679[ebp]
  004dd	73 2e		 jae	 SHORT $LN372@inflate

; 732  :                         (len = state->head->extra_len - state->length) <
; 733  :                             state->head->extra_max) {
; 734  :                         zmemcpy(state->head->extra + len, next,

  004df	8d 0c 02	 lea	 ecx, DWORD PTR [edx+eax]
  004e2	8b 55 cc	 mov	 edx, DWORD PTR tv4970[ebp]
  004e5	2b d0		 sub	 edx, eax
  004e7	3b 4d cc	 cmp	 ecx, DWORD PTR tv4970[ebp]
  004ea	8b 45 d8	 mov	 eax, DWORD PTR tv4679[ebp]
  004ed	0f 47 c2	 cmova	 eax, edx
  004f0	50		 push	 eax
  004f1	8b 45 f0	 mov	 eax, DWORD PTR _len$2$[ebp]
  004f4	03 45 c0	 add	 eax, DWORD PTR tv4971[ebp]
  004f7	53		 push	 ebx
  004f8	50		 push	 eax
  004f9	e8 00 00 00 00	 call	 _memcpy
  004fe	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00501	83 c4 0c	 add	 esp, 12			; 0000000cH
  00504	8b 55 d8	 mov	 edx, DWORD PTR tv4679[ebp]
  00507	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  0050a	89 45 d0	 mov	 DWORD PTR $T7[ebp], eax
$LN372@inflate:

; 735  :                                 len + copy > state->head->extra_max ?
; 736  :                                 state->head->extra_max - len : copy);
; 737  :                     }
; 738  :                     if ((state->flags & 0x0200) && (state->wrap & 4))

  0050d	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  00514	74 16		 je	 SHORT $LN373@inflate
  00516	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  0051a	74 10		 je	 SHORT $LN373@inflate

; 739  :                         state->check = crc32(state->check, next, copy);

  0051c	52		 push	 edx
  0051d	53		 push	 ebx
  0051e	ff 71 1c	 push	 DWORD PTR [ecx+28]
  00521	e8 00 00 00 00	 call	 _crc32@12
  00526	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00529	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN373@inflate:

; 740  :                     have -= copy;

  0052c	8b 55 d8	 mov	 edx, DWORD PTR tv4679[ebp]
  0052f	2b fa		 sub	 edi, edx

; 741  :                     next += copy;
; 742  :                     state->length -= copy;

  00531	8b 45 d0	 mov	 eax, DWORD PTR $T7[ebp]
  00534	03 da		 add	 ebx, edx
  00536	2b c2		 sub	 eax, edx
  00538	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  0053b	89 41 44	 mov	 DWORD PTR [ecx+68], eax
$LN725@inflate:

; 743  :                 }
; 744  :                 if (state->length) goto inf_leave;

  0053e	85 c0		 test	 eax, eax
  00540	0f 85 91 00 00
	00		 jne	 $LN919@inflate
$LN724@inflate:

; 745  :             }
; 746  :             state->length = 0;

  00546	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 747  :             state->mode = NAME;

  0054d	c7 41 04 3a 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16186 ; 00003f3aH
$LN375@inflate:

; 748  :                 /* fallthrough */
; 749  :         case NAME:
; 750  :             if (state->flags & 0x0800) {

  00554	f7 41 14 00 08
	00 00		 test	 DWORD PTR [ecx+20], 2048 ; 00000800H
  0055b	0f 84 f7 00 00
	00		 je	 $LN376@inflate

; 751  :                 if (have == 0) goto inf_leave;

  00561	85 ff		 test	 edi, edi
  00563	74 72		 je	 SHORT $LN919@inflate

; 752  :                 copy = 0;

  00565	33 d2		 xor	 edx, edx
$LL88@inflate:

; 753  :                 do {
; 754  :                     len = (unsigned)(next[copy++]);

  00567	8a 04 1a	 mov	 al, BYTE PTR [edx+ebx]
  0056a	42		 inc	 edx
  0056b	88 45 ff	 mov	 BYTE PTR tv5121[ebp], al

; 755  :                     if (state->head != Z_NULL &&
; 756  :                             state->head->name != Z_NULL &&

  0056e	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00571	89 55 cc	 mov	 DWORD PTR _copy$1$[ebp], edx
  00574	85 c0		 test	 eax, eax
  00576	74 1d		 je	 SHORT $LN86@inflate
  00578	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  0057c	74 17		 je	 SHORT $LN86@inflate
  0057e	8b 71 44	 mov	 esi, DWORD PTR [ecx+68]
  00581	3b 70 20	 cmp	 esi, DWORD PTR [eax+32]
  00584	73 0f		 jae	 SHORT $LN86@inflate

; 757  :                             state->length < state->head->name_max)
; 758  :                         state->head->name[state->length++] = (Bytef)len;

  00586	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00589	8a 55 ff	 mov	 dl, BYTE PTR tv5121[ebp]
  0058c	88 14 30	 mov	 BYTE PTR [eax+esi], dl
  0058f	ff 41 44	 inc	 DWORD PTR [ecx+68]
  00592	8b 55 cc	 mov	 edx, DWORD PTR _copy$1$[ebp]
$LN86@inflate:

; 759  :                 } while (len && copy < have);

  00595	8a 45 ff	 mov	 al, BYTE PTR tv5121[ebp]
  00598	84 c0		 test	 al, al
  0059a	74 04		 je	 SHORT $LN380@inflate
  0059c	3b d7		 cmp	 edx, edi
  0059e	72 c7		 jb	 SHORT $LL88@inflate
$LN380@inflate:

; 760  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  005a0	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  005a7	8b 75 ec	 mov	 esi, DWORD PTR _bits$1$[ebp]
  005aa	74 1c		 je	 SHORT $LN381@inflate
  005ac	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  005b0	74 16		 je	 SHORT $LN381@inflate

; 761  :                     state->check = crc32(state->check, next, copy);

  005b2	52		 push	 edx
  005b3	53		 push	 ebx
  005b4	ff 71 1c	 push	 DWORD PTR [ecx+28]
  005b7	e8 00 00 00 00	 call	 _crc32@12
  005bc	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  005bf	8b 55 cc	 mov	 edx, DWORD PTR _copy$1$[ebp]
  005c2	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  005c5	8a 45 ff	 mov	 al, BYTE PTR tv5121[ebp]
$LN381@inflate:

; 762  :                 have -= copy;
; 763  :                 next += copy;

  005c8	03 da		 add	 ebx, edx
  005ca	2b fa		 sub	 edi, edx
  005cc	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx

; 764  :                 if (len) goto inf_leave;

  005cf	84 c0		 test	 al, al
  005d1	0f 84 8f 00 00
	00		 je	 $LN383@inflate
$LN919@inflate:

; 1227 :             goto inf_leave;
; 1228 :         case MEM:
; 1229 :             return Z_MEM_ERROR;
; 1230 :         case SYNC:
; 1231 :                 /* fallthrough */
; 1232 :         default:
; 1233 :             return Z_STREAM_ERROR;
; 1234 :         }
; 1235 : 
; 1236 :     /*
; 1237 :        Return from inflate(), updating the total counts and the check value.
; 1238 :        If there was no progress during the inflate() call, return a buffer
; 1239 :        error.  Call updatewindow() to create and/or update the window state.
; 1240 :        Note: a memory error from inflate() is non-recoverable.
; 1241 :      */
; 1242 :   inf_leave:
; 1243 :     RESTORE();

  005d7	8b 55 0c	 mov	 edx, DWORD PTR _flush$[ebp]
$inf_leave$1112:
  005da	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  005dd	8b 45 e0	 mov	 eax, DWORD PTR _put$1$[ebp]
  005e0	89 19		 mov	 DWORD PTR [ecx], ebx
  005e2	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
  005e5	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  005e8	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  005eb	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  005ee	8b 45 f4	 mov	 eax, DWORD PTR _hold$1$[ebp]
  005f1	89 79 04	 mov	 DWORD PTR [ecx+4], edi

; 1244 :     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&

  005f4	83 7b 2c 00	 cmp	 DWORD PTR [ebx+44], 0
  005f8	89 73 40	 mov	 DWORD PTR [ebx+64], esi
  005fb	8b 75 dc	 mov	 esi, DWORD PTR _out$1$[ebp]
  005fe	89 43 3c	 mov	 DWORD PTR [ebx+60], eax
  00601	75 27		 jne	 SHORT $LN503@inflate
  00603	3b 71 10	 cmp	 esi, DWORD PTR [ecx+16]
  00606	0f 84 fb 0f 00
	00		 je	 $LN504@inflate
  0060c	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0060f	3d 51 3f 00 00	 cmp	 eax, 16209		; 00003f51H
  00614	0f 8d ed 0f 00
	00		 jge	 $LN504@inflate
  0061a	3d 4e 3f 00 00	 cmp	 eax, 16206		; 00003f4eH
  0061f	7c 09		 jl	 SHORT $LN503@inflate
  00621	83 fa 04	 cmp	 edx, 4
  00624	0f 84 dd 0f 00
	00		 je	 $LN504@inflate
$LN503@inflate:

; 1245 :             (state->mode < CHECK || flush != Z_FINISH)))
; 1246 :         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {

  0062a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0062d	8b c6		 mov	 eax, esi
  0062f	2b 41 10	 sub	 eax, DWORD PTR [ecx+16]
  00632	50		 push	 eax
  00633	e8 00 00 00 00	 call	 _updatewindow
  00638	83 c4 04	 add	 esp, 4
  0063b	85 c0		 test	 eax, eax
  0063d	0f 84 c1 0f 00
	00		 je	 $LN883@inflate

; 1247 :             state->mode = MEM;

  00643	c7 43 04 52 3f
	00 00		 mov	 DWORD PTR [ebx+4], 16210 ; 00003f52H
$LN498@inflate:
  0064a	5f		 pop	 edi

; 1262 :         ret = Z_BUF_ERROR;
; 1263 :     return ret;
; 1264 : }

  0064b	5e		 pop	 esi
  0064c	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00651	5b		 pop	 ebx
  00652	8b e5		 mov	 esp, ebp
  00654	5d		 pop	 ebp
  00655	c2 08 00	 ret	 8
$LN376@inflate:

; 765  :             }
; 766  :             else if (state->head != Z_NULL)

  00658	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0065b	85 c0		 test	 eax, eax
  0065d	74 07		 je	 SHORT $LN383@inflate

; 767  :                 state->head->name = Z_NULL;

  0065f	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
$LN383@inflate:

; 768  :             state->length = 0;

  00666	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 769  :             state->mode = COMMENT;

  0066d	c7 41 04 3b 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16187 ; 00003f3bH
$LN384@inflate:

; 770  :                 /* fallthrough */
; 771  :         case COMMENT:
; 772  :             if (state->flags & 0x1000) {

  00674	f7 41 14 00 10
	00 00		 test	 DWORD PTR [ecx+20], 4096 ; 00001000H
  0067b	74 7c		 je	 SHORT $LN385@inflate

; 773  :                 if (have == 0) goto inf_leave;

  0067d	85 ff		 test	 edi, edi
  0067f	0f 84 52 ff ff
	ff		 je	 $LN919@inflate

; 774  :                 copy = 0;

  00685	33 d2		 xor	 edx, edx
$LL91@inflate:

; 775  :                 do {
; 776  :                     len = (unsigned)(next[copy++]);

  00687	8a 04 1a	 mov	 al, BYTE PTR [edx+ebx]
  0068a	42		 inc	 edx
  0068b	88 45 ff	 mov	 BYTE PTR tv5119[ebp], al

; 777  :                     if (state->head != Z_NULL &&
; 778  :                             state->head->comment != Z_NULL &&

  0068e	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00691	89 55 cc	 mov	 DWORD PTR _copy$2$[ebp], edx
  00694	85 c0		 test	 eax, eax
  00696	74 1d		 je	 SHORT $LN89@inflate
  00698	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  0069c	74 17		 je	 SHORT $LN89@inflate
  0069e	8b 71 44	 mov	 esi, DWORD PTR [ecx+68]
  006a1	3b 70 28	 cmp	 esi, DWORD PTR [eax+40]
  006a4	73 0f		 jae	 SHORT $LN89@inflate

; 779  :                             state->length < state->head->comm_max)
; 780  :                         state->head->comment[state->length++] = (Bytef)len;

  006a6	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  006a9	8a 55 ff	 mov	 dl, BYTE PTR tv5119[ebp]
  006ac	88 14 30	 mov	 BYTE PTR [eax+esi], dl
  006af	ff 41 44	 inc	 DWORD PTR [ecx+68]
  006b2	8b 55 cc	 mov	 edx, DWORD PTR _copy$2$[ebp]
$LN89@inflate:

; 781  :                 } while (len && copy < have);

  006b5	8a 45 ff	 mov	 al, BYTE PTR tv5119[ebp]
  006b8	84 c0		 test	 al, al
  006ba	74 04		 je	 SHORT $LN389@inflate
  006bc	3b d7		 cmp	 edx, edi
  006be	72 c7		 jb	 SHORT $LL91@inflate
$LN389@inflate:

; 782  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  006c0	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  006c7	8b 75 ec	 mov	 esi, DWORD PTR _bits$1$[ebp]
  006ca	74 1c		 je	 SHORT $LN390@inflate
  006cc	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  006d0	74 16		 je	 SHORT $LN390@inflate

; 783  :                     state->check = crc32(state->check, next, copy);

  006d2	52		 push	 edx
  006d3	53		 push	 ebx
  006d4	ff 71 1c	 push	 DWORD PTR [ecx+28]
  006d7	e8 00 00 00 00	 call	 _crc32@12
  006dc	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  006df	8b 55 cc	 mov	 edx, DWORD PTR _copy$2$[ebp]
  006e2	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  006e5	8a 45 ff	 mov	 al, BYTE PTR tv5119[ebp]
$LN390@inflate:

; 784  :                 have -= copy;
; 785  :                 next += copy;

  006e8	03 da		 add	 ebx, edx
  006ea	2b fa		 sub	 edi, edx
  006ec	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx

; 786  :                 if (len) goto inf_leave;

  006ef	84 c0		 test	 al, al
  006f1	0f 85 e0 fe ff
	ff		 jne	 $LN919@inflate

; 787  :             }

  006f7	eb 0e		 jmp	 SHORT $LN392@inflate
$LN385@inflate:

; 788  :             else if (state->head != Z_NULL)

  006f9	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  006fc	85 c0		 test	 eax, eax
  006fe	74 07		 je	 SHORT $LN392@inflate

; 789  :                 state->head->comment = Z_NULL;

  00700	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
$LN392@inflate:
  00707	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 790  :             state->mode = HCRC;

  0070a	c7 41 04 3c 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16188 ; 00003f3cH
$LN393@inflate:

; 791  :                 /* fallthrough */
; 792  :         case HCRC:
; 793  :             if (state->flags & 0x0200) {

  00711	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00714	89 45 c0	 mov	 DWORD PTR tv4693[ebp], eax
  00717	a9 00 02 00 00	 test	 eax, 512		; 00000200H
  0071c	74 55		 je	 SHORT $LN101@inflate

; 794  :                 NEEDBITS(16);

  0071e	83 fe 10	 cmp	 esi, 16			; 00000010H
  00721	73 27		 jae	 SHORT $LN92@inflate
$LL95@inflate:
  00723	85 ff		 test	 edi, edi
  00725	0f 84 ac fe ff
	ff		 je	 $LN919@inflate
  0072b	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0072e	8b ce		 mov	 ecx, esi
  00730	d3 e0		 shl	 eax, cl
  00732	83 c6 08	 add	 esi, 8
  00735	03 d0		 add	 edx, eax
  00737	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0073a	43		 inc	 ebx
  0073b	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  0073e	4f		 dec	 edi
  0073f	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00742	83 fe 10	 cmp	 esi, 16			; 00000010H
  00745	72 dc		 jb	 SHORT $LL95@inflate
  00747	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN92@inflate:

; 795  :                 if ((state->wrap & 4) && hold != (state->check & 0xffff)) {

  0074a	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  0074e	74 17		 je	 SHORT $LN102@inflate
  00750	0f b7 41 1c	 movzx	 eax, WORD PTR [ecx+28]
  00754	3b d0		 cmp	 edx, eax
  00756	74 0f		 je	 SHORT $LN102@inflate

; 796  :                     strm->msg = (char *)"header crc mismatch";

  00758	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0075b	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@GONKLEPM@header?5crc?5mismatch@

; 797  :                     state->mode = BAD;
; 798  :                     break;

  00762	e9 1d 0e 00 00	 jmp	 $LN1105@inflate
$LN102@inflate:

; 799  :                 }
; 800  :                 INITBITS();

  00767	33 f6		 xor	 esi, esi
  00769	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  00770	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN101@inflate:

; 801  :             }
; 802  :             if (state->head != Z_NULL) {

  00773	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00776	85 c0		 test	 eax, eax
  00778	74 16		 je	 SHORT $LN397@inflate

; 803  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  0077a	8b 55 c0	 mov	 edx, DWORD PTR tv4693[ebp]
  0077d	c1 fa 09	 sar	 edx, 9
  00780	83 e2 01	 and	 edx, 1
  00783	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 804  :                 state->head->done = 1;

  00786	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00789	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [eax+48], 1
$LN397@inflate:

; 805  :             }
; 806  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  00790	6a 00		 push	 0
  00792	6a 00		 push	 0
  00794	6a 00		 push	 0
  00796	e8 00 00 00 00	 call	 _crc32@12
  0079b	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0079e	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  007a1	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  007a4	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 807  :             state->mode = TYPE;
; 808  :             break;

  007a7	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  007aa	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
  007b1	e9 d5 0d 00 00	 jmp	 $LN8@inflate
$LN105@inflate:

; 809  : #endif
; 810  :         case DICTID:
; 811  :             NEEDBITS(32);

  007b6	83 fe 20	 cmp	 esi, 32			; 00000020H
  007b9	73 26		 jae	 SHORT $LN103@inflate
  007bb	0f 1f 44 00 00	 npad	 5
$LL106@inflate:
  007c0	85 ff		 test	 edi, edi
  007c2	0f 84 0f fe ff
	ff		 je	 $LN919@inflate
  007c8	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  007cb	8b ce		 mov	 ecx, esi
  007cd	d3 e0		 shl	 eax, cl
  007cf	43		 inc	 ebx
  007d0	03 d0		 add	 edx, eax
  007d2	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  007d5	83 c6 08	 add	 esi, 8
  007d8	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  007db	4f		 dec	 edi
  007dc	83 fe 20	 cmp	 esi, 32			; 00000020H
  007df	72 df		 jb	 SHORT $LL106@inflate
$LN103@inflate:

; 812  :             strm->adler = state->check = ZSWAP32(hold);

  007e1	8b ca		 mov	 ecx, edx
  007e3	8b c2		 mov	 eax, edx
  007e5	c1 e0 10	 shl	 eax, 16			; 00000010H
  007e8	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  007ee	03 c8		 add	 ecx, eax
  007f0	8b c2		 mov	 eax, edx
  007f2	c1 e8 08	 shr	 eax, 8
  007f5	c1 e1 08	 shl	 ecx, 8
  007f8	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  007fd	c1 ea 18	 shr	 edx, 24			; 00000018H
  00800	03 c1		 add	 eax, ecx
  00802	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00805	03 c2		 add	 eax, edx
  00807	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0080a	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  0080d	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 813  :             INITBITS();

  00810	33 d2		 xor	 edx, edx
  00812	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00815	33 f6		 xor	 esi, esi

; 814  :             state->mode = DICT;

  00817	c7 41 04 3e 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16190 ; 00003f3eH
$LN400@inflate:

; 815  :                 /* fallthrough */
; 816  :         case DICT:
; 817  :             if (state->havedict == 0) {

  0081e	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00822	0f 84 82 0d 00
	00		 je	 $LN587@inflate

; 820  :             }
; 821  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  00828	6a 00		 push	 0
  0082a	6a 00		 push	 0
  0082c	6a 00		 push	 0
  0082e	e8 00 00 00 00	 call	 _adler32@12
  00833	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00836	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00839	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  0083c	89 42 30	 mov	 DWORD PTR [edx+48], eax
  0083f	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 822  :             state->mode = TYPE;

  00842	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
$LN402@inflate:

; 823  :                 /* fallthrough */
; 824  :         case TYPE:
; 825  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  00849	8b 45 0c	 mov	 eax, DWORD PTR _flush$[ebp]
  0084c	83 f8 05	 cmp	 eax, 5
  0084f	0f 84 a8 0d 00
	00		 je	 $LN906@inflate
  00855	83 f8 06	 cmp	 eax, 6
  00858	0f 84 9f 0d 00
	00		 je	 $LN906@inflate
$LN403@inflate:

; 826  :                 /* fallthrough */
; 827  :         case TYPEDO:
; 828  :             if (state->last) {

  0085e	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00862	74 1e		 je	 SHORT $LN122@inflate

; 829  :                 BYTEBITS();

  00864	8b ce		 mov	 ecx, esi
  00866	83 e1 07	 and	 ecx, 7
  00869	d3 ea		 shr	 edx, cl
  0086b	2b f1		 sub	 esi, ecx

; 830  :                 state->mode = CHECK;

  0086d	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00870	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00873	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00876	c7 41 04 4e 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16206 ; 00003f4eH

; 831  :                 break;

  0087d	e9 09 0d 00 00	 jmp	 $LN8@inflate
$LN122@inflate:

; 832  :             }
; 833  :             NEEDBITS(3);

  00882	83 fe 03	 cmp	 esi, 3
  00885	73 24		 jae	 SHORT $LN120@inflate
$LL123@inflate:
  00887	85 ff		 test	 edi, edi
  00889	0f 84 48 fd ff
	ff		 je	 $LN919@inflate
  0088f	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00892	8b ce		 mov	 ecx, esi
  00894	d3 e0		 shl	 eax, cl
  00896	43		 inc	 ebx
  00897	03 d0		 add	 edx, eax
  00899	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  0089c	83 c6 08	 add	 esi, 8
  0089f	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  008a2	4f		 dec	 edi
  008a3	83 fe 03	 cmp	 esi, 3
  008a6	72 df		 jb	 SHORT $LL123@inflate
  008a8	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN120@inflate:

; 834  :             state->last = BITS(1);

  008ab	8b c2		 mov	 eax, edx

; 835  :             DROPBITS(1);

  008ad	d1 ea		 shr	 edx, 1
  008af	83 e0 01	 and	 eax, 1
  008b2	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 836  :             switch (BITS(2)) {

  008b5	8b c2		 mov	 eax, edx
  008b7	83 e0 03	 and	 eax, 3
  008ba	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN792@inflate[eax*4]
$LN408@inflate:

; 860  :             }
; 861  :             DROPBITS(2);

  008c1	c1 ea 02	 shr	 edx, 2
  008c4	83 ee 03	 sub	 esi, 3
  008c7	c7 41 04 41 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16193 ; 00003f41H
  008ce	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  008d1	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 862  :             break;

  008d4	e9 b2 0c 00 00	 jmp	 $LN8@inflate
$LN409@inflate:

; 837  :             case 0:                             /* stored block */
; 838  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 839  :                         state->last ? " (last)" : ""));
; 840  :                 state->mode = STORED;
; 841  :                 break;
; 842  :             case 1:                             /* fixed block */
; 843  :                 fixedtables(state);

  008d9	e8 00 00 00 00	 call	 _fixedtables

; 844  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 845  :                         state->last ? " (last)" : ""));
; 846  :                 state->mode = LEN_;             /* decode codes */
; 847  :                 if (flush == Z_TREES) {

  008de	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  008e2	c7 41 04 47 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16199 ; 00003f47H
  008e9	75 37		 jne	 SHORT $LN138@inflate

; 848  :                     DROPBITS(2);

  008eb	c1 ea 02	 shr	 edx, 2
  008ee	83 ee 03	 sub	 esi, 3
  008f1	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx

; 849  :                     goto inf_leave;

  008f4	e9 de fc ff ff	 jmp	 $LN919@inflate
$LN411@inflate:

; 860  :             }
; 861  :             DROPBITS(2);

  008f9	c1 ea 02	 shr	 edx, 2
  008fc	83 ee 03	 sub	 esi, 3
  008ff	c7 41 04 44 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16196 ; 00003f44H
  00906	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00909	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 862  :             break;

  0090c	e9 7a 0c 00 00	 jmp	 $LN8@inflate
$LN412@inflate:

; 850  :                 }
; 851  :                 break;
; 852  :             case 2:                             /* dynamic block */
; 853  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 854  :                         state->last ? " (last)" : ""));
; 855  :                 state->mode = TABLE;
; 856  :                 break;
; 857  :             case 3:
; 858  :                 strm->msg = (char *)"invalid block type";

  00911	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00914	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type@

; 859  :                 state->mode = BAD;

  0091b	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
$LN138@inflate:

; 860  :             }
; 861  :             DROPBITS(2);

  00922	c1 ea 02	 shr	 edx, 2
  00925	83 ee 03	 sub	 esi, 3
  00928	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  0092b	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 862  :             break;

  0092e	e9 58 0c 00 00	 jmp	 $LN8@inflate
$LN141@inflate:

; 863  :         case STORED:
; 864  :             BYTEBITS();                         /* go to byte boundary */

  00933	8b ce		 mov	 ecx, esi
  00935	83 e1 07	 and	 ecx, 7
  00938	2b f1		 sub	 esi, ecx
  0093a	d3 ea		 shr	 edx, cl
  0093c	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  0093f	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 865  :             NEEDBITS(32);

  00942	83 fe 20	 cmp	 esi, 32			; 00000020H
  00945	73 24		 jae	 SHORT $LN142@inflate
$LL145@inflate:
  00947	85 ff		 test	 edi, edi
  00949	0f 84 88 fc ff
	ff		 je	 $LN919@inflate
  0094f	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00952	8b ce		 mov	 ecx, esi
  00954	d3 e0		 shl	 eax, cl
  00956	83 c6 08	 add	 esi, 8
  00959	03 d0		 add	 edx, eax
  0095b	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0095e	43		 inc	 ebx
  0095f	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00962	4f		 dec	 edi
  00963	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00966	83 fe 20	 cmp	 esi, 32			; 00000020H
  00969	72 dc		 jb	 SHORT $LL145@inflate
$LN142@inflate:

; 866  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  0096b	8b c2		 mov	 eax, edx
  0096d	0f b7 ca	 movzx	 ecx, dx
  00970	f7 d0		 not	 eax
  00972	89 4d c0	 mov	 DWORD PTR tv4965[ebp], ecx
  00975	c1 e8 10	 shr	 eax, 16			; 00000010H
  00978	3b c8		 cmp	 ecx, eax
  0097a	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0097d	74 0f		 je	 SHORT $LN415@inflate

; 867  :                 strm->msg = (char *)"invalid stored block lengths";

  0097f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00982	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@

; 868  :                 state->mode = BAD;
; 869  :                 break;

  00989	e9 f6 0b 00 00	 jmp	 $LN1105@inflate
$LN415@inflate:

; 870  :             }
; 871  :             state->length = (unsigned)hold & 0xffff;

  0098e	8b 45 c0	 mov	 eax, DWORD PTR tv4965[ebp]

; 872  :             Tracev((stderr, "inflate:       stored length %u\n",
; 873  :                     state->length));
; 874  :             INITBITS();

  00991	33 d2		 xor	 edx, edx
  00993	33 f6		 xor	 esi, esi
  00995	89 41 44	 mov	 DWORD PTR [ecx+68], eax

; 875  :             state->mode = COPY_;
; 876  :             if (flush == Z_TREES) goto inf_leave;

  00998	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  0099c	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  0099f	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  009a2	c7 41 04 42 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16194 ; 00003f42H
  009a9	0f 84 28 fc ff
	ff		 je	 $LN919@inflate
$LN416@inflate:

; 877  :                 /* fallthrough */
; 878  :         case COPY_:
; 879  :             state->mode = COPY;

  009af	c7 41 04 43 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16195 ; 00003f43H
$LN418@inflate:

; 880  :                 /* fallthrough */
; 881  :         case COPY:
; 882  :             copy = state->length;

  009b6	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  009b9	89 45 c0	 mov	 DWORD PTR _copy$3$[ebp], eax

; 883  :             if (copy) {

  009bc	85 c0		 test	 eax, eax
  009be	0f 84 1a 07 00
	00		 je	 $LN419@inflate

; 884  :                 if (copy > have) copy = have;
; 885  :                 if (copy > left) copy = left;

  009c4	39 7d c0	 cmp	 DWORD PTR _copy$3$[ebp], edi
  009c7	8b c7		 mov	 eax, edi

; 886  :                 if (copy == 0) goto inf_leave;

  009c9	8b 4d e8	 mov	 ecx, DWORD PTR _left$1$[ebp]
  009cc	0f 46 45 c0	 cmovbe	 eax, DWORD PTR _copy$3$[ebp]
  009d0	3b c1		 cmp	 eax, ecx
  009d2	0f 46 c8	 cmovbe	 ecx, eax
  009d5	89 4d c0	 mov	 DWORD PTR tv5103[ebp], ecx
  009d8	85 c9		 test	 ecx, ecx
  009da	0f 84 f7 fb ff
	ff		 je	 $LN919@inflate

; 887  :                 zmemcpy(put, next, copy);

  009e0	51		 push	 ecx
  009e1	53		 push	 ebx
  009e2	ff 75 e0	 push	 DWORD PTR _put$1$[ebp]
  009e5	e8 00 00 00 00	 call	 _memcpy

; 888  :                 have -= copy;

  009ea	8b 45 c0	 mov	 eax, DWORD PTR tv5103[ebp]
  009ed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 889  :                 next += copy;
; 890  :                 left -= copy;
; 891  :                 put += copy;
; 892  :                 state->length -= copy;

  009f0	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  009f3	03 d8		 add	 ebx, eax
  009f5	29 45 e8	 sub	 DWORD PTR _left$1$[ebp], eax
  009f8	2b f8		 sub	 edi, eax
  009fa	01 45 e0	 add	 DWORD PTR _put$1$[ebp], eax

; 893  :                 break;

  009fd	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00a00	29 41 44	 sub	 DWORD PTR [ecx+68], eax
  00a03	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00a06	e9 80 0b 00 00	 jmp	 $LN8@inflate
$LN155@inflate:

; 894  :             }
; 895  :             Tracev((stderr, "inflate:       stored end\n"));
; 896  :             state->mode = TYPE;
; 897  :             break;
; 898  :         case TABLE:
; 899  :             NEEDBITS(14);

  00a0b	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  00a0e	73 21		 jae	 SHORT $LN153@inflate
$LL156@inflate:
  00a10	85 ff		 test	 edi, edi
  00a12	0f 84 bf fb ff
	ff		 je	 $LN919@inflate
  00a18	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00a1b	8b ce		 mov	 ecx, esi
  00a1d	d3 e0		 shl	 eax, cl
  00a1f	43		 inc	 ebx
  00a20	03 d0		 add	 edx, eax
  00a22	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00a25	83 c6 08	 add	 esi, 8
  00a28	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00a2b	4f		 dec	 edi
  00a2c	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  00a2f	72 df		 jb	 SHORT $LL156@inflate
$LN153@inflate:

; 900  :             state->nlen = BITS(5) + 257;

  00a31	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00a34	8b ca		 mov	 ecx, edx
  00a36	83 e1 1f	 and	 ecx, 31			; 0000001fH

; 901  :             DROPBITS(5);

  00a39	c1 ea 05	 shr	 edx, 5
  00a3c	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H

; 902  :             state->ndist = BITS(5) + 1;
; 903  :             DROPBITS(5);
; 904  :             state->ncode = BITS(4) + 4;
; 905  :             DROPBITS(4);

  00a42	83 ee 0e	 sub	 esi, 14			; 0000000eH
  00a45	89 4d c0	 mov	 DWORD PTR tv4962[ebp], ecx
  00a48	89 48 64	 mov	 DWORD PTR [eax+100], ecx
  00a4b	8b ca		 mov	 ecx, edx
  00a4d	83 e1 1f	 and	 ecx, 31			; 0000001fH
  00a50	c1 ea 05	 shr	 edx, 5
  00a53	41		 inc	 ecx
  00a54	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00a57	89 48 68	 mov	 DWORD PTR [eax+104], ecx
  00a5a	8b c2		 mov	 eax, edx
  00a5c	89 4d cc	 mov	 DWORD PTR tv5185[ebp], ecx
  00a5f	83 e0 0f	 and	 eax, 15			; 0000000fH
  00a62	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00a65	83 c0 04	 add	 eax, 4
  00a68	c1 ea 04	 shr	 edx, 4

; 906  : #ifndef PKZIP_BUG_WORKAROUND
; 907  :             if (state->nlen > 286 || state->ndist > 30) {

  00a6b	81 7d c0 1e 01
	00 00		 cmp	 DWORD PTR tv4962[ebp], 286 ; 0000011eH
  00a72	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00a75	89 41 60	 mov	 DWORD PTR [ecx+96], eax
  00a78	0f 87 fc 00 00
	00		 ja	 $LN426@inflate
  00a7e	83 7d cc 1e	 cmp	 DWORD PTR tv5185[ebp], 30 ; 0000001eH
  00a82	0f 87 f2 00 00
	00		 ja	 $LN426@inflate

; 911  :             }
; 912  : #endif
; 913  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 914  :             state->have = 0;

  00a88	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], 0

; 915  :             state->mode = LENLENS;

  00a8f	c7 41 04 45 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16197 ; 00003f45H
$LN533@inflate:

; 916  :                 /* fallthrough */
; 917  :         case LENLENS:
; 918  :             while (state->have < state->ncode) {

  00a96	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00a99	3b 41 60	 cmp	 eax, DWORD PTR [ecx+96]
  00a9c	73 5f		 jae	 SHORT $LN535@inflate
  00a9e	66 90		 npad	 2
$LL170@inflate:

; 919  :                 NEEDBITS(3);

  00aa0	83 fe 03	 cmp	 esi, 3
  00aa3	73 21		 jae	 SHORT $LN172@inflate
$LL175@inflate:
  00aa5	85 ff		 test	 edi, edi
  00aa7	0f 84 2a fb ff
	ff		 je	 $LN919@inflate
  00aad	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00ab0	8b ce		 mov	 ecx, esi
  00ab2	d3 e0		 shl	 eax, cl
  00ab4	43		 inc	 ebx
  00ab5	03 d0		 add	 edx, eax
  00ab7	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00aba	83 c6 08	 add	 esi, 8
  00abd	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00ac0	4f		 dec	 edi
  00ac1	83 fe 03	 cmp	 esi, 3
  00ac4	72 df		 jb	 SHORT $LL175@inflate
$LN172@inflate:

; 920  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00ac6	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00ac9	8b ca		 mov	 ecx, edx
  00acb	8b 55 f8	 mov	 edx, DWORD PTR _state$1$[ebp]
  00ace	83 e1 07	 and	 ecx, 7

; 921  :                 DROPBITS(3);

  00ad1	83 ee 03	 sub	 esi, 3
  00ad4	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00ad7	8b 40 6c	 mov	 eax, DWORD PTR [eax+108]
  00ada	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00ae2	66 89 4c 42 74	 mov	 WORD PTR [edx+eax*2+116], cx
  00ae7	8b ca		 mov	 ecx, edx
  00ae9	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00aec	c1 ea 03	 shr	 edx, 3
  00aef	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00af2	ff 41 6c	 inc	 DWORD PTR [ecx+108]
  00af5	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00af8	3b 41 60	 cmp	 eax, DWORD PTR [ecx+96]
  00afb	72 a3		 jb	 SHORT $LL170@inflate
$LN535@inflate:

; 922  :             }
; 923  :             while (state->have < 19)

  00afd	83 f8 13	 cmp	 eax, 19			; 00000013H
  00b00	73 29		 jae	 SHORT $LN184@inflate
  00b02	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL183@inflate:

; 924  :                 state->lens[order[state->have++]] = 0;

  00b10	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00b18	33 d2		 xor	 edx, edx
  00b1a	66 89 54 41 74	 mov	 WORD PTR [ecx+eax*2+116], dx
  00b1f	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00b22	40		 inc	 eax
  00b23	89 41 6c	 mov	 DWORD PTR [ecx+108], eax
  00b26	83 f8 13	 cmp	 eax, 19			; 00000013H
  00b29	72 e5		 jb	 SHORT $LL183@inflate
$LN184@inflate:

; 925  :             state->next = state->codes;
; 926  :             state->lencode = (const code FAR *)(state->next);

  00b2b	8b 55 f8	 mov	 edx, DWORD PTR _state$1$[ebp]
  00b2e	8d 81 34 05 00
	00		 lea	 eax, DWORD PTR [ecx+1332]
  00b34	83 c1 70	 add	 ecx, 112		; 00000070H
  00b37	89 42 50	 mov	 DWORD PTR [edx+80], eax
  00b3a	89 01		 mov	 DWORD PTR [ecx], eax

; 927  :             state->lenbits = 7;
; 928  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  00b3c	8d 82 f4 02 00
	00		 lea	 eax, DWORD PTR [edx+756]
  00b42	50		 push	 eax
  00b43	8d 42 58	 lea	 eax, DWORD PTR [edx+88]
  00b46	c7 42 58 07 00
	00 00		 mov	 DWORD PTR [edx+88], 7
  00b4d	50		 push	 eax
  00b4e	51		 push	 ecx
  00b4f	6a 13		 push	 19			; 00000013H
  00b51	83 c2 74	 add	 edx, 116		; 00000074H
  00b54	33 c9		 xor	 ecx, ecx
  00b56	e8 00 00 00 00	 call	 _inflate_table

; 929  :                                 &(state->lenbits), state->work);
; 930  :             if (ret) {

  00b5b	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00b5e	83 c4 10	 add	 esp, 16			; 00000010H
  00b61	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00b64	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00b67	85 c0		 test	 eax, eax
  00b69	74 1e		 je	 SHORT $LN429@inflate

; 931  :                 strm->msg = (char *)"invalid code lengths set";

  00b6b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00b6e	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@

; 932  :                 state->mode = BAD;
; 933  :                 break;

  00b75	e9 0a 0a 00 00	 jmp	 $LN1105@inflate
$LN426@inflate:

; 908  :                 strm->msg = (char *)"too many length or distance symbols";

  00b7a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00b7d	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@

; 909  :                 state->mode = BAD;
; 910  :                 break;

  00b84	e9 fb 09 00 00	 jmp	 $LN1105@inflate
$LN429@inflate:

; 934  :             }
; 935  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 936  :             state->have = 0;

  00b89	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], 0

; 937  :             state->mode = CODELENS;

  00b90	c7 41 04 46 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16198 ; 00003f46H
$LN536@inflate:

; 938  :                 /* fallthrough */
; 939  :         case CODELENS:
; 940  :             while (state->have < state->nlen + state->ndist) {

  00b97	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00b9a	03 41 64	 add	 eax, DWORD PTR [ecx+100]
  00b9d	39 41 6c	 cmp	 DWORD PTR [ecx+108], eax
  00ba0	0f 83 65 02 00
	00		 jae	 $LN882@inflate
$LL185@inflate:

; 941  :                 for (;;) {
; 942  :                     here = state->lencode[BITS(state->lenbits)];

  00ba6	8b 4d c4	 mov	 ecx, DWORD PTR tv5118[ebp]
  00ba9	b8 01 00 00 00	 mov	 eax, 1
  00bae	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00bb0	d3 e0		 shl	 eax, cl
  00bb2	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00bb5	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00bb8	89 4d c0	 mov	 DWORD PTR tv5169[ebp], ecx
  00bbb	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00bbe	89 45 cc	 mov	 DWORD PTR tv5001[ebp], eax
  00bc1	8b c1		 mov	 eax, ecx
  00bc3	8b 4d cc	 mov	 ecx, DWORD PTR tv5001[ebp]
  00bc6	23 c2		 and	 eax, edx
  00bc8	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00bcb	8b c8		 mov	 ecx, eax
  00bcd	c1 e9 08	 shr	 ecx, 8
  00bd0	89 4d d8	 mov	 DWORD PTR $T9[ebp], ecx
  00bd3	89 45 d0	 mov	 DWORD PTR $T8[ebp], eax
  00bd6	c1 6d d0 10	 shr	 DWORD PTR $T8[ebp], 16	; 00000010H
  00bda	0f b6 c9	 movzx	 ecx, cl

; 943  :                     if ((unsigned)(here.bits) <= bits) break;

  00bdd	3b ce		 cmp	 ecx, esi
  00bdf	76 45		 jbe	 SHORT $LN878@inflate
$LL187@inflate:

; 944  :                     PULLBYTE();

  00be1	85 ff		 test	 edi, edi
  00be3	0f 84 ee f9 ff
	ff		 je	 $LN919@inflate
  00be9	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00bec	8b ce		 mov	 ecx, esi
  00bee	d3 e0		 shl	 eax, cl
  00bf0	43		 inc	 ebx
  00bf1	8b 4d cc	 mov	 ecx, DWORD PTR tv5001[ebp]
  00bf4	03 d0		 add	 edx, eax
  00bf6	8b 45 c0	 mov	 eax, DWORD PTR tv5169[ebp]
  00bf9	83 c6 08	 add	 esi, 8
  00bfc	23 c2		 and	 eax, edx
  00bfe	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00c01	4f		 dec	 edi
  00c02	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00c05	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00c08	8b c8		 mov	 ecx, eax
  00c0a	c1 e9 08	 shr	 ecx, 8
  00c0d	89 4d d8	 mov	 DWORD PTR $T9[ebp], ecx
  00c10	89 45 d0	 mov	 DWORD PTR tv4940[ebp], eax
  00c13	c1 6d d0 10	 shr	 DWORD PTR tv4940[ebp], 16 ; 00000010H
  00c17	0f b6 c9	 movzx	 ecx, cl
  00c1a	3b ce		 cmp	 ecx, esi
  00c1c	77 c3		 ja	 SHORT $LL187@inflate

; 943  :                     if ((unsigned)(here.bits) <= bits) break;

  00c1e	8b 4d d0	 mov	 ecx, DWORD PTR tv4940[ebp]
  00c21	0f b7 c9	 movzx	 ecx, cx
  00c24	eb 03		 jmp	 SHORT $LN563@inflate
$LN878@inflate:
  00c26	8b 4d d0	 mov	 ecx, DWORD PTR $T8[ebp]
$LN563@inflate:

; 945  :                 }
; 946  :                 if (here.val < 16) {

  00c29	0f b7 d9	 movzx	 ebx, cx
  00c2c	89 5d c0	 mov	 DWORD PTR tv4941[ebp], ebx
  00c2f	8b 5d f0	 mov	 ebx, DWORD PTR _next$1$[ebp]
  00c32	66 83 f9 10	 cmp	 cx, 16			; 00000010H
  00c36	73 33		 jae	 SHORT $LN433@inflate

; 947  :                     DROPBITS(here.bits);

  00c38	8b 4d d8	 mov	 ecx, DWORD PTR $T9[ebp]
  00c3b	d3 ea		 shr	 edx, cl
  00c3d	8b c8		 mov	 ecx, eax
  00c3f	c1 e9 08	 shr	 ecx, 8
  00c42	0f b6 c9	 movzx	 ecx, cl
  00c45	2b f1		 sub	 esi, ecx
  00c47	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx

; 948  :                     state->lens[state->have++] = here.val;

  00c4a	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00c4d	8b 55 f8	 mov	 edx, DWORD PTR _state$1$[ebp]
  00c50	c1 e8 10	 shr	 eax, 16			; 00000010H
  00c53	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00c56	8b 49 6c	 mov	 ecx, DWORD PTR [ecx+108]
  00c59	66 89 44 4a 74	 mov	 WORD PTR [edx+ecx*2+116], ax
  00c5e	8b ca		 mov	 ecx, edx
  00c60	ff 41 6c	 inc	 DWORD PTR [ecx+108]
  00c63	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]

; 949  :                 }

  00c66	e9 8b 01 00 00	 jmp	 $LN1106@inflate
$LN433@inflate:

; 950  :                 else {
; 951  :                     if (here.val == 16) {

  00c6b	8b 4d c0	 mov	 ecx, DWORD PTR tv4941[ebp]
  00c6e	66 83 f9 10	 cmp	 cx, 16			; 00000010H
  00c72	75 7b		 jne	 SHORT $LN435@inflate

; 952  :                         NEEDBITS(here.bits + 2);

  00c74	8b 4d d8	 mov	 ecx, DWORD PTR $T9[ebp]
  00c77	c1 e8 08	 shr	 eax, 8
  00c7a	0f b6 c0	 movzx	 eax, al
  00c7d	89 45 cc	 mov	 DWORD PTR tv4998[ebp], eax
  00c80	0f b6 c1	 movzx	 eax, cl
  00c83	83 c0 02	 add	 eax, 2
  00c86	89 45 c0	 mov	 DWORD PTR tv4993[ebp], eax
  00c89	3b f0		 cmp	 esi, eax
  00c8b	73 24		 jae	 SHORT $LN196@inflate
  00c8d	0f 1f 00	 npad	 3
$LL199@inflate:
  00c90	85 ff		 test	 edi, edi
  00c92	0f 84 3f f9 ff
	ff		 je	 $LN919@inflate
  00c98	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00c9b	8b ce		 mov	 ecx, esi
  00c9d	d3 e0		 shl	 eax, cl
  00c9f	43		 inc	 ebx
  00ca0	03 d0		 add	 edx, eax
  00ca2	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00ca5	83 c6 08	 add	 esi, 8
  00ca8	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00cab	4f		 dec	 edi
  00cac	3b 75 c0	 cmp	 esi, DWORD PTR tv4993[ebp]
  00caf	72 df		 jb	 SHORT $LL199@inflate
$LN196@inflate:

; 953  :                         DROPBITS(here.bits);

  00cb1	8b 4d cc	 mov	 ecx, DWORD PTR tv4998[ebp]
  00cb4	2b f1		 sub	 esi, ecx
  00cb6	d3 ea		 shr	 edx, cl

; 954  :                         if (state->have == 0) {

  00cb8	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00cbb	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00cbe	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00cc1	83 79 6c 00	 cmp	 DWORD PTR [ecx+108], 0
  00cc5	0f 84 66 01 00
	00		 je	 $LN568@inflate

; 955  :                             strm->msg = (char *)"invalid bit length repeat";
; 956  :                             state->mode = BAD;
; 957  :                             break;
; 958  :                         }
; 959  :                         len = state->lens[state->have - 1];
; 960  :                         copy = 3 + BITS(2);

  00ccb	8b c2		 mov	 eax, edx

; 961  :                         DROPBITS(2);

  00ccd	c1 ea 02	 shr	 edx, 2
  00cd0	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00cd3	83 e0 03	 and	 eax, 3
  00cd6	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  00cd9	83 c0 03	 add	 eax, 3
  00cdc	89 45 d8	 mov	 DWORD PTR _copy$4$[ebp], eax
  00cdf	83 ee 02	 sub	 esi, 2
  00ce2	0f b7 54 51 72	 movzx	 edx, WORD PTR [ecx+edx*2+114]
  00ce7	89 55 cc	 mov	 DWORD PTR $T5[ebp], edx

; 962  :                     }

  00cea	e9 be 00 00 00	 jmp	 $LN1107@inflate
$LN435@inflate:

; 963  :                     else if (here.val == 17) {

  00cef	66 83 f9 11	 cmp	 cx, 17			; 00000011H
  00cf3	0f b6 c4	 movzx	 eax, ah
  00cf6	8b 4d d8	 mov	 ecx, DWORD PTR $T9[ebp]
  00cf9	75 50		 jne	 SHORT $LN226@inflate

; 964  :                         NEEDBITS(here.bits + 3);

  00cfb	89 45 cc	 mov	 DWORD PTR tv4992[ebp], eax
  00cfe	0f b6 c1	 movzx	 eax, cl
  00d01	83 c0 03	 add	 eax, 3
  00d04	89 45 c0	 mov	 DWORD PTR tv4951[ebp], eax
  00d07	3b f0		 cmp	 esi, eax
  00d09	73 26		 jae	 SHORT $LN210@inflate
  00d0b	0f 1f 44 00 00	 npad	 5
$LL213@inflate:
  00d10	85 ff		 test	 edi, edi
  00d12	0f 84 bf f8 ff
	ff		 je	 $LN919@inflate
  00d18	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00d1b	8b ce		 mov	 ecx, esi
  00d1d	d3 e0		 shl	 eax, cl
  00d1f	43		 inc	 ebx
  00d20	03 d0		 add	 edx, eax
  00d22	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00d25	83 c6 08	 add	 esi, 8
  00d28	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00d2b	4f		 dec	 edi
  00d2c	3b 75 c0	 cmp	 esi, DWORD PTR tv4951[ebp]
  00d2f	72 df		 jb	 SHORT $LL213@inflate
$LN210@inflate:

; 965  :                         DROPBITS(here.bits);

  00d31	8b 4d cc	 mov	 ecx, DWORD PTR tv4992[ebp]
  00d34	d3 ea		 shr	 edx, cl

; 966  :                         len = 0;
; 967  :                         copy = 3 + BITS(3);

  00d36	8b c2		 mov	 eax, edx
  00d38	83 e0 07	 and	 eax, 7
  00d3b	83 c0 03	 add	 eax, 3

; 968  :                         DROPBITS(3);

  00d3e	c1 ea 03	 shr	 edx, 3
  00d41	89 45 d8	 mov	 DWORD PTR _copy$4$[ebp], eax
  00d44	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 969  :                     }

  00d49	eb 4e		 jmp	 SHORT $LN1108@inflate
$LN226@inflate:

; 970  :                     else {
; 971  :                         NEEDBITS(here.bits + 7);

  00d4b	89 45 cc	 mov	 DWORD PTR tv4990[ebp], eax
  00d4e	0f b6 c1	 movzx	 eax, cl
  00d51	83 c0 07	 add	 eax, 7
  00d54	89 45 c0	 mov	 DWORD PTR tv4950[ebp], eax
  00d57	3b f0		 cmp	 esi, eax
  00d59	73 26		 jae	 SHORT $LN224@inflate
  00d5b	0f 1f 44 00 00	 npad	 5
$LL227@inflate:
  00d60	85 ff		 test	 edi, edi
  00d62	0f 84 6f f8 ff
	ff		 je	 $LN919@inflate
  00d68	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00d6b	8b ce		 mov	 ecx, esi
  00d6d	d3 e0		 shl	 eax, cl
  00d6f	43		 inc	 ebx
  00d70	03 d0		 add	 edx, eax
  00d72	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00d75	83 c6 08	 add	 esi, 8
  00d78	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00d7b	4f		 dec	 edi
  00d7c	3b 75 c0	 cmp	 esi, DWORD PTR tv4950[ebp]
  00d7f	72 df		 jb	 SHORT $LL227@inflate
$LN224@inflate:

; 972  :                         DROPBITS(here.bits);

  00d81	8b 4d cc	 mov	 ecx, DWORD PTR tv4990[ebp]
  00d84	d3 ea		 shr	 edx, cl

; 973  :                         len = 0;
; 974  :                         copy = 11 + BITS(7);

  00d86	8b c2		 mov	 eax, edx
  00d88	83 e0 7f	 and	 eax, 127		; 0000007fH
  00d8b	83 c0 0b	 add	 eax, 11			; 0000000bH

; 975  :                         DROPBITS(7);

  00d8e	c1 ea 07	 shr	 edx, 7
  00d91	89 45 d8	 mov	 DWORD PTR _copy$4$[ebp], eax
  00d94	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
$LN1108@inflate:

; 976  :                     }
; 977  :                     if (state->have + copy > state->nlen + state->ndist) {

  00d99	2b c1		 sub	 eax, ecx
  00d9b	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR $T5[ebp], 0
  00da2	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00da5	03 f0		 add	 esi, eax
  00da7	8b 45 d8	 mov	 eax, DWORD PTR _copy$4$[ebp]
  00daa	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
$LN1107@inflate:
  00dad	8b 49 6c	 mov	 ecx, DWORD PTR [ecx+108]
  00db0	8b 55 f8	 mov	 edx, DWORD PTR _state$1$[ebp]
  00db3	89 4d d0	 mov	 DWORD PTR $T6[ebp], ecx
  00db6	03 c8		 add	 ecx, eax
  00db8	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00dbb	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00dbe	8b 40 64	 mov	 eax, DWORD PTR [eax+100]
  00dc1	03 42 68	 add	 eax, DWORD PTR [edx+104]
  00dc4	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00dc7	3b c8		 cmp	 ecx, eax
  00dc9	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00dcc	77 63		 ja	 SHORT $LN568@inflate
  00dce	8b 55 d8	 mov	 edx, DWORD PTR _copy$4$[ebp]
  00dd1	8b 45 d0	 mov	 eax, DWORD PTR $T6[ebp]
  00dd4	8b 5d cc	 mov	 ebx, DWORD PTR $T5[ebp]
  00dd7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL238@inflate:

; 978  :                         strm->msg = (char *)"invalid bit length repeat";
; 979  :                         state->mode = BAD;
; 980  :                         break;
; 981  :                     }
; 982  :                     while (copy--)
; 983  :                         state->lens[state->have++] = (unsigned short)len;

  00de0	66 89 5c 41 74	 mov	 WORD PTR [ecx+eax*2+116], bx
  00de5	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00de8	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00deb	89 41 6c	 mov	 DWORD PTR [ecx+108], eax
  00dee	83 ea 01	 sub	 edx, 1
  00df1	75 ed		 jne	 SHORT $LL238@inflate
  00df3	8b 5d f0	 mov	 ebx, DWORD PTR _next$1$[ebp]
$LN1106@inflate:

; 938  :                 /* fallthrough */
; 939  :         case CODELENS:
; 940  :             while (state->have < state->nlen + state->ndist) {

  00df6	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00df9	89 45 d0	 mov	 DWORD PTR $T6[ebp], eax
  00dfc	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00dff	03 41 68	 add	 eax, DWORD PTR [ecx+104]
  00e02	39 45 d0	 cmp	 DWORD PTR $T6[ebp], eax
  00e05	0f 82 9b fd ff
	ff		 jb	 $LL185@inflate
$LN882@inflate:

; 984  :                 }
; 985  :             }
; 986  : 
; 987  :             /* handle error breaks in while */
; 988  :             if (state->mode == BAD) break;

  00e0b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
$LN186@inflate:
  00e0e	81 79 04 51 3f
	00 00		 cmp	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00e15	0f 84 70 07 00
	00		 je	 $LN8@inflate

; 989  : 
; 990  :             /* check for end-of-block code (better have one) */
; 991  :             if (state->lens[256] == 0) {

  00e1b	66 83 b9 74 02
	00 00 00	 cmp	 WORD PTR [ecx+628], 0
  00e23	75 1f		 jne	 SHORT $LN445@inflate

; 992  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00e25	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@

; 993  :                 state->mode = BAD;
; 994  :                 break;

  00e2c	e9 53 07 00 00	 jmp	 $LN1105@inflate
$LN568@inflate:

; 984  :                 }
; 985  :             }
; 986  : 
; 987  :             /* handle error breaks in while */
; 988  :             if (state->mode == BAD) break;

  00e31	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00e34	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
  00e3b	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00e42	eb ca		 jmp	 SHORT $LN186@inflate
$LN445@inflate:

; 995  :             }
; 996  : 
; 997  :             /* build code tables -- note: do not change the lenbits or distbits
; 998  :                values here (9 and 6) without reading the comments in inftrees.h
; 999  :                concerning the ENOUGH constants, which depend on those values */
; 1000 :             state->next = state->codes;

  00e44	8d 51 70	 lea	 edx, DWORD PTR [ecx+112]

; 1001 :             state->lencode = (const code FAR *)(state->next);
; 1002 :             state->lenbits = 9;

  00e47	c7 41 58 09 00
	00 00		 mov	 DWORD PTR [ecx+88], 9
  00e4e	8d 81 34 05 00
	00		 lea	 eax, DWORD PTR [ecx+1332]
  00e54	89 55 c0	 mov	 DWORD PTR tv5183[ebp], edx
  00e57	89 02		 mov	 DWORD PTR [edx], eax
  00e59	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 1003 :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  00e5c	8d 81 f4 02 00
	00		 lea	 eax, DWORD PTR [ecx+756]
  00e62	50		 push	 eax
  00e63	8d 41 58	 lea	 eax, DWORD PTR [ecx+88]
  00e66	50		 push	 eax
  00e67	52		 push	 edx
  00e68	ff 71 64	 push	 DWORD PTR [ecx+100]
  00e6b	8d 51 74	 lea	 edx, DWORD PTR [ecx+116]
  00e6e	b9 01 00 00 00	 mov	 ecx, 1
  00e73	e8 00 00 00 00	 call	 _inflate_table

; 1004 :                                 &(state->lenbits), state->work);
; 1005 :             if (ret) {

  00e78	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00e7b	83 c4 10	 add	 esp, 16			; 00000010H
  00e7e	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00e81	85 c0		 test	 eax, eax
  00e83	74 12		 je	 SHORT $LN446@inflate

; 1006 :                 strm->msg = (char *)"invalid literal/lengths set";

  00e85	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 1007 :                 state->mode = BAD;
; 1008 :                 break;

  00e88	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00e8b	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@
  00e92	e9 ed 06 00 00	 jmp	 $LN1105@inflate
$LN446@inflate:

; 1009 :             }
; 1010 :             state->distcode = (const code FAR *)(state->next);

  00e97	8b 55 c0	 mov	 edx, DWORD PTR tv5183[ebp]

; 1011 :             state->distbits = 6;

  00e9a	c7 41 5c 06 00
	00 00		 mov	 DWORD PTR [ecx+92], 6
  00ea1	8b 02		 mov	 eax, DWORD PTR [edx]
  00ea3	89 41 54	 mov	 DWORD PTR [ecx+84], eax

; 1012 :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  00ea6	8d 81 f4 02 00
	00		 lea	 eax, DWORD PTR [ecx+756]
  00eac	50		 push	 eax
  00ead	8d 41 5c	 lea	 eax, DWORD PTR [ecx+92]
  00eb0	50		 push	 eax
  00eb1	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00eb4	52		 push	 edx
  00eb5	ff 71 68	 push	 DWORD PTR [ecx+104]
  00eb8	83 c1 74	 add	 ecx, 116		; 00000074H
  00ebb	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00ebe	b9 02 00 00 00	 mov	 ecx, 2
  00ec3	e8 00 00 00 00	 call	 _inflate_table

; 1013 :                             &(state->next), &(state->distbits), state->work);
; 1014 :             if (ret) {

  00ec8	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00ecb	83 c4 10	 add	 esp, 16			; 00000010H
  00ece	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00ed1	85 c0		 test	 eax, eax
  00ed3	74 12		 je	 SHORT $LN447@inflate

; 1015 :                 strm->msg = (char *)"invalid distances set";

  00ed5	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 1016 :                 state->mode = BAD;
; 1017 :                 break;

  00ed8	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00edb	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set@
  00ee2	e9 9d 06 00 00	 jmp	 $LN1105@inflate
$LN447@inflate:

; 1018 :             }
; 1019 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1020 :             state->mode = LEN_;
; 1021 :             if (flush == Z_TREES) goto inf_leave;

  00ee7	8b 55 0c	 mov	 edx, DWORD PTR _flush$[ebp]
  00eea	c7 41 04 47 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16199 ; 00003f47H
  00ef1	83 fa 06	 cmp	 edx, 6
  00ef4	0f 84 e0 f6 ff
	ff		 je	 $inf_leave$1112
  00efa	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN448@inflate:

; 1022 :                 /* fallthrough */
; 1023 :         case LEN_:
; 1024 :             state->mode = LEN;

  00efd	c7 41 04 48 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16200 ; 00003f48H
$LN450@inflate:

; 1025 :                 /* fallthrough */
; 1026 :         case LEN:
; 1027 :             if (have >= 6 && left >= 258) {

  00f04	83 ff 06	 cmp	 edi, 6
  00f07	72 72		 jb	 SHORT $LN451@inflate
  00f09	81 7d e8 02 01
	00 00		 cmp	 DWORD PTR _left$1$[ebp], 258 ; 00000102H
  00f10	72 69		 jb	 SHORT $LN451@inflate

; 1028 :                 RESTORE();

  00f12	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00f15	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  00f18	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00f1b	8b 4d e8	 mov	 ecx, DWORD PTR _left$1$[ebp]
  00f1e	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00f21	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00f24	89 18		 mov	 DWORD PTR [eax], ebx
  00f26	89 78 04	 mov	 DWORD PTR [eax+4], edi
  00f29	89 51 3c	 mov	 DWORD PTR [ecx+60], edx

; 1029 :                 inflate_fast(strm, out);

  00f2c	8b 55 dc	 mov	 edx, DWORD PTR _out$1$[ebp]
  00f2f	89 71 40	 mov	 DWORD PTR [ecx+64], esi
  00f32	8b c8		 mov	 ecx, eax
  00f34	e8 00 00 00 00	 call	 _inflate_fast

; 1030 :                 LOAD();

  00f39	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00f3c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00f3f	8b 18		 mov	 ebx, DWORD PTR [eax]
  00f41	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00f44	89 4d e0	 mov	 DWORD PTR _put$1$[ebp], ecx
  00f47	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00f4a	89 4d e8	 mov	 DWORD PTR _left$1$[ebp], ecx
  00f4d	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00f50	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx

; 1031 :                 if (state->mode == TYPE)

  00f53	81 79 04 3f 3f
	00 00		 cmp	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
  00f5a	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00f5d	8b 71 40	 mov	 esi, DWORD PTR [ecx+64]
  00f60	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00f63	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00f66	0f 85 1f 06 00
	00		 jne	 $LN8@inflate

; 1032 :                     state->back = -1;

  00f6c	c7 81 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7112], -1

; 1033 :                 break;

  00f76	e9 10 06 00 00	 jmp	 $LN8@inflate
$LN451@inflate:

; 1034 :             }
; 1035 :             state->back = 0;

  00f7b	c7 81 c8 1b 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+7112], 0

; 1036 :             for (;;) {
; 1037 :                 here = state->lencode[BITS(state->lenbits)];

  00f85	b8 01 00 00 00	 mov	 eax, 1
  00f8a	8b 4d c4	 mov	 ecx, DWORD PTR tv5118[ebp]
  00f8d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00f8f	d3 e0		 shl	 eax, cl
  00f91	48		 dec	 eax
  00f92	89 45 d0	 mov	 DWORD PTR tv5171[ebp], eax
  00f95	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00f98	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00f9b	8b 45 d0	 mov	 eax, DWORD PTR tv5171[ebp]
  00f9e	23 c2		 and	 eax, edx
  00fa0	89 4d cc	 mov	 DWORD PTR tv5000[ebp], ecx
  00fa3	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00fa6	8b c8		 mov	 ecx, eax
  00fa8	c1 e9 08	 shr	 ecx, 8
  00fab	0f b6 c9	 movzx	 ecx, cl

; 1038 :                 if ((unsigned)(here.bits) <= bits) break;

  00fae	3b ce		 cmp	 ecx, esi
  00fb0	76 33		 jbe	 SHORT $LN570@inflate
$LL246@inflate:

; 1039 :                 PULLBYTE();

  00fb2	85 ff		 test	 edi, edi
  00fb4	0f 84 1d f6 ff
	ff		 je	 $LN919@inflate
  00fba	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00fbd	8b ce		 mov	 ecx, esi
  00fbf	d3 e0		 shl	 eax, cl
  00fc1	43		 inc	 ebx
  00fc2	8b 4d cc	 mov	 ecx, DWORD PTR tv5000[ebp]
  00fc5	03 d0		 add	 edx, eax
  00fc7	8b 45 d0	 mov	 eax, DWORD PTR tv5171[ebp]
  00fca	83 c6 08	 add	 esi, 8
  00fcd	23 c2		 and	 eax, edx
  00fcf	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00fd2	4f		 dec	 edi
  00fd3	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00fd6	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00fd9	8b c8		 mov	 ecx, eax
  00fdb	c1 e9 08	 shr	 ecx, 8
  00fde	0f b6 c9	 movzx	 ecx, cl
  00fe1	3b ce		 cmp	 ecx, esi
  00fe3	77 cd		 ja	 SHORT $LL246@inflate
$LN570@inflate:

; 1040 :             }
; 1041 :             if (here.op && (here.op & 0xf0) == 0) {

  00fe5	84 c0		 test	 al, al
  00fe7	0f 84 aa 00 00
	00		 je	 $LN263@inflate
  00fed	a8 f0		 test	 al, 240			; 000000f0H
  00fef	0f 85 a2 00 00
	00		 jne	 $LN263@inflate

; 1042 :                 last = here;

  00ff5	8b c8		 mov	 ecx, eax
  00ff7	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00ffa	89 4d d0	 mov	 DWORD PTR tv5111[ebp], ecx
  00ffd	8b c8		 mov	 ecx, eax
  00fff	c1 e9 08	 shr	 ecx, 8

; 1043 :                 for (;;) {
; 1044 :                     here = state->lencode[last.val +

  01002	0f b6 c9	 movzx	 ecx, cl
  01005	89 4d d8	 mov	 DWORD PTR tv5112[ebp], ecx
  01008	0f b6 c8	 movzx	 ecx, al
  0100b	b8 01 00 00 00	 mov	 eax, 1
  01010	03 4d d8	 add	 ecx, DWORD PTR tv5112[ebp]
  01013	d3 e0		 shl	 eax, cl
  01015	8b 4d d8	 mov	 ecx, DWORD PTR tv5112[ebp]
  01018	48		 dec	 eax
  01019	89 45 c0	 mov	 DWORD PTR tv5172[ebp], eax
  0101c	23 c2		 and	 eax, edx

; 1045 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1046 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  0101e	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  01021	d3 e8		 shr	 eax, cl
  01023	03 45 d0	 add	 eax, DWORD PTR tv5111[ebp]
  01026	8b 4d cc	 mov	 ecx, DWORD PTR tv5000[ebp]
  01029	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0102c	8b c8		 mov	 ecx, eax
  0102e	c1 e9 08	 shr	 ecx, 8
  01031	0f b6 c9	 movzx	 ecx, cl
  01034	03 4d d8	 add	 ecx, DWORD PTR tv5112[ebp]
  01037	3b ce		 cmp	 ecx, esi
  01039	76 43		 jbe	 SHORT $LN260@inflate
  0103b	0f 1f 44 00 00	 npad	 5
$LL252@inflate:

; 1047 :                     PULLBYTE();

  01040	85 ff		 test	 edi, edi
  01042	0f 84 8f f5 ff
	ff		 je	 $LN919@inflate
  01048	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0104b	8b ce		 mov	 ecx, esi
  0104d	d3 e0		 shl	 eax, cl
  0104f	43		 inc	 ebx
  01050	8b 4d d8	 mov	 ecx, DWORD PTR tv5112[ebp]
  01053	03 d0		 add	 edx, eax
  01055	8b 45 c0	 mov	 eax, DWORD PTR tv5172[ebp]
  01058	83 c6 08	 add	 esi, 8
  0105b	23 c2		 and	 eax, edx
  0105d	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  01060	d3 e8		 shr	 eax, cl
  01062	4f		 dec	 edi
  01063	03 45 d0	 add	 eax, DWORD PTR tv5111[ebp]
  01066	8b 4d cc	 mov	 ecx, DWORD PTR tv5000[ebp]
  01069	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  0106c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0106f	8b c8		 mov	 ecx, eax
  01071	c1 e9 08	 shr	 ecx, 8
  01074	0f b6 c9	 movzx	 ecx, cl
  01077	03 4d d8	 add	 ecx, DWORD PTR tv5112[ebp]
  0107a	3b ce		 cmp	 ecx, esi
  0107c	77 c2		 ja	 SHORT $LL252@inflate
$LN260@inflate:

; 1048 :                 }
; 1049 :                 DROPBITS(last.bits);

  0107e	8b 4d d8	 mov	 ecx, DWORD PTR tv5112[ebp]
  01081	d3 ea		 shr	 edx, cl
  01083	2b f1		 sub	 esi, ecx

; 1050 :                 state->back += last.bits;

  01085	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01088	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  0108b	8b 55 d8	 mov	 edx, DWORD PTR tv5112[ebp]
  0108e	89 91 c8 1b 00
	00		 mov	 DWORD PTR [ecx+7112], edx
  01094	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN263@inflate:

; 1051 :             }
; 1052 :             DROPBITS(here.bits);

  01097	8b c8		 mov	 ecx, eax
  01099	c1 e9 08	 shr	 ecx, 8
  0109c	0f b6 c9	 movzx	 ecx, cl
  0109f	d3 ea		 shr	 edx, cl
  010a1	2b f1		 sub	 esi, ecx
  010a3	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx

; 1053 :             state->back += here.bits;

  010a6	8b 55 f8	 mov	 edx, DWORD PTR _state$1$[ebp]
  010a9	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  010ac	01 8a c8 1b 00
	00		 add	 DWORD PTR [edx+7112], ecx

; 1054 :             state->length = (unsigned)here.val;

  010b2	8b c8		 mov	 ecx, eax
  010b4	c1 e9 10	 shr	 ecx, 16			; 00000010H
  010b7	89 4a 44	 mov	 DWORD PTR [edx+68], ecx

; 1055 :             if ((int)(here.op) == 0) {

  010ba	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  010bd	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  010c0	84 c0		 test	 al, al
  010c2	75 0c		 jne	 SHORT $LN458@inflate

; 1056 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1057 :                         "inflate:         literal '%c'\n" :
; 1058 :                         "inflate:         literal 0x%02x\n", here.val));
; 1059 :                 state->mode = LIT;

  010c4	c7 41 04 4d 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16205 ; 00003f4dH

; 1060 :                 break;

  010cb	e9 bb 04 00 00	 jmp	 $LN8@inflate
$LN458@inflate:

; 1061 :             }
; 1062 :             if (here.op & 32) {

  010d0	a8 20		 test	 al, 32			; 00000020H
  010d2	74 16		 je	 SHORT $LN459@inflate

; 1063 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1064 :                 state->back = -1;

  010d4	c7 81 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7112], -1
$LN419@inflate:

; 617  :     in = have;
; 618  :     out = left;
; 619  :     ret = Z_OK;
; 620  :     for (;;)
; 621  :         switch (state->mode) {

  010de	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
  010e5	e9 a1 04 00 00	 jmp	 $LN8@inflate
$LN459@inflate:

; 1065 :                 state->mode = TYPE;
; 1066 :                 break;
; 1067 :             }
; 1068 :             if (here.op & 64) {

  010ea	a8 40		 test	 al, 64			; 00000040H
  010ec	74 0f		 je	 SHORT $LN460@inflate

; 1069 :                 strm->msg = (char *)"invalid literal/length code";

  010ee	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  010f1	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@

; 1070 :                 state->mode = BAD;
; 1071 :                 break;

  010f8	e9 87 04 00 00	 jmp	 $LN1105@inflate
$LN460@inflate:

; 1072 :             }
; 1073 :             state->extra = (unsigned)(here.op) & 15;

  010fd	0f b6 c0	 movzx	 eax, al
  01100	83 e0 0f	 and	 eax, 15			; 0000000fH

; 1074 :             state->mode = LENEXT;

  01103	c7 41 04 49 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16201 ; 00003f49H
  0110a	89 41 4c	 mov	 DWORD PTR [ecx+76], eax
$LN461@inflate:

; 1075 :                 /* fallthrough */
; 1076 :         case LENEXT:
; 1077 :             if (state->extra) {

  0110d	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  01110	89 45 cc	 mov	 DWORD PTR tv4985[ebp], eax
  01113	85 c0		 test	 eax, eax
  01115	74 52		 je	 SHORT $LN728@inflate

; 1078 :                 NEEDBITS(state->extra);

  01117	3b f0		 cmp	 esi, eax
  01119	73 26		 jae	 SHORT $LN264@inflate
  0111b	0f 1f 44 00 00	 npad	 5
$LL267@inflate:
  01120	85 ff		 test	 edi, edi
  01122	0f 84 af f4 ff
	ff		 je	 $LN919@inflate
  01128	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0112b	8b ce		 mov	 ecx, esi
  0112d	d3 e0		 shl	 eax, cl
  0112f	43		 inc	 ebx
  01130	03 d0		 add	 edx, eax
  01132	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  01135	83 c6 08	 add	 esi, 8
  01138	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  0113b	4f		 dec	 edi
  0113c	3b 75 cc	 cmp	 esi, DWORD PTR tv4985[ebp]
  0113f	72 df		 jb	 SHORT $LL267@inflate
$LN264@inflate:

; 1079 :                 state->length += BITS(state->extra);

  01141	8b 4d cc	 mov	 ecx, DWORD PTR tv4985[ebp]
  01144	b8 01 00 00 00	 mov	 eax, 1
  01149	d3 e0		 shl	 eax, cl
  0114b	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0114e	48		 dec	 eax
  0114f	23 c2		 and	 eax, edx
  01151	01 41 44	 add	 DWORD PTR [ecx+68], eax

; 1080 :                 DROPBITS(state->extra);

  01154	8b 45 cc	 mov	 eax, DWORD PTR tv4985[ebp]
  01157	8b c8		 mov	 ecx, eax
  01159	d3 ea		 shr	 edx, cl
  0115b	2b f0		 sub	 esi, eax

; 1081 :                 state->back += state->extra;

  0115d	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01160	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  01163	01 81 c8 1b 00
	00		 add	 DWORD PTR [ecx+7112], eax
$LN728@inflate:

; 1082 :             }
; 1083 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1084 :             state->was = state->length;

  01169	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  0116c	89 81 cc 1b 00
	00		 mov	 DWORD PTR [ecx+7116], eax

; 1085 :             state->mode = DIST;

  01172	c7 41 04 4a 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16202 ; 00003f4aH
$LN464@inflate:

; 1086 :                 /* fallthrough */
; 1087 :         case DIST:
; 1088 :             for (;;) {
; 1089 :                 here = state->distcode[BITS(state->distbits)];

  01179	8b 4d bc	 mov	 ecx, DWORD PTR tv5113[ebp]
  0117c	b8 01 00 00 00	 mov	 eax, 1
  01181	8b 09		 mov	 ecx, DWORD PTR [ecx]
  01183	d3 e0		 shl	 eax, cl
  01185	48		 dec	 eax
  01186	89 45 d0	 mov	 DWORD PTR tv5176[ebp], eax
  01189	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  0118c	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0118f	8b 45 d0	 mov	 eax, DWORD PTR tv5176[ebp]
  01192	23 c2		 and	 eax, edx
  01194	89 4d cc	 mov	 DWORD PTR tv4983[ebp], ecx
  01197	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0119a	8b c8		 mov	 ecx, eax
  0119c	c1 e9 08	 shr	 ecx, 8
  0119f	0f b6 c9	 movzx	 ecx, cl

; 1090 :                 if ((unsigned)(here.bits) <= bits) break;

  011a2	3b ce		 cmp	 ecx, esi
  011a4	76 33		 jbe	 SHORT $LN575@inflate
$LL275@inflate:

; 1091 :                 PULLBYTE();

  011a6	85 ff		 test	 edi, edi
  011a8	0f 84 29 f4 ff
	ff		 je	 $LN919@inflate
  011ae	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  011b1	8b ce		 mov	 ecx, esi
  011b3	d3 e0		 shl	 eax, cl
  011b5	43		 inc	 ebx
  011b6	8b 4d cc	 mov	 ecx, DWORD PTR tv4983[ebp]
  011b9	03 d0		 add	 edx, eax
  011bb	8b 45 d0	 mov	 eax, DWORD PTR tv5176[ebp]
  011be	83 c6 08	 add	 esi, 8
  011c1	23 c2		 and	 eax, edx
  011c3	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  011c6	4f		 dec	 edi
  011c7	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  011ca	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  011cd	8b c8		 mov	 ecx, eax
  011cf	c1 e9 08	 shr	 ecx, 8
  011d2	0f b6 c9	 movzx	 ecx, cl
  011d5	3b ce		 cmp	 ecx, esi
  011d7	77 cd		 ja	 SHORT $LL275@inflate
$LN575@inflate:

; 1092 :             }
; 1093 :             if ((here.op & 0xf0) == 0) {

  011d9	a8 f0		 test	 al, 240			; 000000f0H
  011db	0f 85 a3 00 00
	00		 jne	 $LN292@inflate

; 1094 :                 last = here;

  011e1	8b c8		 mov	 ecx, eax
  011e3	c1 e9 10	 shr	 ecx, 16			; 00000010H
  011e6	89 4d d0	 mov	 DWORD PTR tv5109[ebp], ecx
  011e9	8b c8		 mov	 ecx, eax
  011eb	c1 e9 08	 shr	 ecx, 8

; 1095 :                 for (;;) {
; 1096 :                     here = state->distcode[last.val +

  011ee	0f b6 c9	 movzx	 ecx, cl
  011f1	89 4d d8	 mov	 DWORD PTR tv5110[ebp], ecx
  011f4	0f b6 c8	 movzx	 ecx, al
  011f7	b8 01 00 00 00	 mov	 eax, 1
  011fc	03 4d d8	 add	 ecx, DWORD PTR tv5110[ebp]
  011ff	d3 e0		 shl	 eax, cl
  01201	8b 4d d8	 mov	 ecx, DWORD PTR tv5110[ebp]
  01204	48		 dec	 eax
  01205	89 45 c0	 mov	 DWORD PTR tv5177[ebp], eax
  01208	23 c2		 and	 eax, edx
  0120a	d3 e8		 shr	 eax, cl
  0120c	03 45 d0	 add	 eax, DWORD PTR tv5109[ebp]
  0120f	8b 4d cc	 mov	 ecx, DWORD PTR tv4983[ebp]
  01212	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  01215	8b c8		 mov	 ecx, eax
  01217	c1 e9 08	 shr	 ecx, 8

; 1097 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1098 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  0121a	0f b6 c9	 movzx	 ecx, cl
  0121d	03 4d d8	 add	 ecx, DWORD PTR tv5110[ebp]
  01220	3b ce		 cmp	 ecx, esi
  01222	76 3e		 jbe	 SHORT $LN289@inflate
$LL281@inflate:

; 1099 :                     PULLBYTE();

  01224	85 ff		 test	 edi, edi
  01226	0f 84 ab f3 ff
	ff		 je	 $LN919@inflate
  0122c	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0122f	8b ce		 mov	 ecx, esi
  01231	d3 e0		 shl	 eax, cl
  01233	43		 inc	 ebx
  01234	8b 4d d8	 mov	 ecx, DWORD PTR tv5110[ebp]
  01237	03 d0		 add	 edx, eax
  01239	8b 45 c0	 mov	 eax, DWORD PTR tv5177[ebp]
  0123c	83 c6 08	 add	 esi, 8
  0123f	23 c2		 and	 eax, edx
  01241	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  01244	d3 e8		 shr	 eax, cl
  01246	4f		 dec	 edi
  01247	03 45 d0	 add	 eax, DWORD PTR tv5109[ebp]
  0124a	8b 4d cc	 mov	 ecx, DWORD PTR tv4983[ebp]
  0124d	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  01250	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  01253	8b c8		 mov	 ecx, eax
  01255	c1 e9 08	 shr	 ecx, 8
  01258	0f b6 c9	 movzx	 ecx, cl
  0125b	03 4d d8	 add	 ecx, DWORD PTR tv5110[ebp]
  0125e	3b ce		 cmp	 ecx, esi
  01260	77 c2		 ja	 SHORT $LL281@inflate
$LN289@inflate:

; 1100 :                 }
; 1101 :                 DROPBITS(last.bits);

  01262	8b 4d d8	 mov	 ecx, DWORD PTR tv5110[ebp]
  01265	2b f1		 sub	 esi, ecx
  01267	d3 ea		 shr	 edx, cl

; 1102 :                 state->back += last.bits;

  01269	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0126c	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  0126f	8b 55 f8	 mov	 edx, DWORD PTR _state$1$[ebp]
  01272	8b 89 c8 1b 00
	00		 mov	 ecx, DWORD PTR [ecx+7112]
  01278	03 4d d8	 add	 ecx, DWORD PTR tv5110[ebp]
  0127b	89 8a c8 1b 00
	00		 mov	 DWORD PTR [edx+7112], ecx
  01281	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN292@inflate:

; 1103 :             }
; 1104 :             DROPBITS(here.bits);

  01284	8b c8		 mov	 ecx, eax
  01286	c1 e9 08	 shr	 ecx, 8
  01289	0f b6 c9	 movzx	 ecx, cl
  0128c	d3 ea		 shr	 edx, cl
  0128e	2b f1		 sub	 esi, ecx
  01290	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx

; 1105 :             state->back += here.bits;

  01293	8b 55 f8	 mov	 edx, DWORD PTR _state$1$[ebp]
  01296	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  01299	01 8a c8 1b 00
	00		 add	 DWORD PTR [edx+7112], ecx

; 1106 :             if (here.op & 64) {

  0129f	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  012a2	a8 40		 test	 al, 64			; 00000040H
  012a4	74 12		 je	 SHORT $LN470@inflate

; 1107 :                 strm->msg = (char *)"invalid distance code";

  012a6	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 1108 :                 state->mode = BAD;

  012a9	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  012ac	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code@

; 1109 :                 break;

  012b3	e9 cc 02 00 00	 jmp	 $LN1105@inflate
$LN470@inflate:

; 1110 :             }
; 1111 :             state->offset = (unsigned)here.val;

  012b8	8b 55 f8	 mov	 edx, DWORD PTR _state$1$[ebp]
  012bb	8b c8		 mov	 ecx, eax
  012bd	c1 e9 10	 shr	 ecx, 16			; 00000010H

; 1112 :             state->extra = (unsigned)(here.op) & 15;

  012c0	0f b6 c0	 movzx	 eax, al
  012c3	83 e0 0f	 and	 eax, 15			; 0000000fH
  012c6	89 4a 48	 mov	 DWORD PTR [edx+72], ecx
  012c9	8b ca		 mov	 ecx, edx
  012cb	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  012ce	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 1113 :             state->mode = DISTEXT;

  012d1	c7 41 04 4b 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16203 ; 00003f4bH
$LN471@inflate:

; 1114 :                 /* fallthrough */
; 1115 :         case DISTEXT:
; 1116 :             if (state->extra) {

  012d8	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  012db	89 45 cc	 mov	 DWORD PTR tv4984[ebp], eax
  012de	85 c0		 test	 eax, eax
  012e0	74 50		 je	 SHORT $LN730@inflate

; 1117 :                 NEEDBITS(state->extra);

  012e2	3b f0		 cmp	 esi, eax
  012e4	73 21		 jae	 SHORT $LN293@inflate
$LL296@inflate:
  012e6	85 ff		 test	 edi, edi
  012e8	0f 84 e9 f2 ff
	ff		 je	 $LN919@inflate
  012ee	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  012f1	8b ce		 mov	 ecx, esi
  012f3	d3 e0		 shl	 eax, cl
  012f5	43		 inc	 ebx
  012f6	03 d0		 add	 edx, eax
  012f8	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  012fb	83 c6 08	 add	 esi, 8
  012fe	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  01301	4f		 dec	 edi
  01302	3b 75 cc	 cmp	 esi, DWORD PTR tv4984[ebp]
  01305	72 df		 jb	 SHORT $LL296@inflate
$LN293@inflate:

; 1118 :                 state->offset += BITS(state->extra);

  01307	8b 4d cc	 mov	 ecx, DWORD PTR tv4984[ebp]
  0130a	b8 01 00 00 00	 mov	 eax, 1
  0130f	d3 e0		 shl	 eax, cl
  01311	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01314	48		 dec	 eax
  01315	23 c2		 and	 eax, edx
  01317	01 41 48	 add	 DWORD PTR [ecx+72], eax

; 1119 :                 DROPBITS(state->extra);

  0131a	8b 45 cc	 mov	 eax, DWORD PTR tv4984[ebp]
  0131d	8b c8		 mov	 ecx, eax
  0131f	d3 ea		 shr	 edx, cl
  01321	2b f0		 sub	 esi, eax

; 1120 :                 state->back += state->extra;

  01323	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01326	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  01329	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0132c	01 81 c8 1b 00
	00		 add	 DWORD PTR [ecx+7112], eax
$LN730@inflate:

; 1121 :             }
; 1122 : #ifdef INFLATE_STRICT
; 1123 :             if (state->offset > state->dmax) {
; 1124 :                 strm->msg = (char *)"invalid distance too far back";
; 1125 :                 state->mode = BAD;
; 1126 :                 break;
; 1127 :             }
; 1128 : #endif
; 1129 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1130 :             state->mode = MATCH;

  01332	c7 41 04 4c 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16204 ; 00003f4cH
$LN474@inflate:

; 1131 :                 /* fallthrough */
; 1132 :         case MATCH:
; 1133 :             if (left == 0) goto inf_leave;

  01339	83 7d e8 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  0133d	0f 84 94 f2 ff
	ff		 je	 $LN919@inflate

; 1134 :             copy = out - left;

  01343	8b 45 dc	 mov	 eax, DWORD PTR _out$1$[ebp]
  01346	2b 45 e8	 sub	 eax, DWORD PTR _left$1$[ebp]
  01349	89 45 cc	 mov	 DWORD PTR _copy$5$[ebp], eax

; 1135 :             if (state->offset > copy) {         /* copy from window */

  0134c	8b 41 48	 mov	 eax, DWORD PTR [ecx+72]
  0134f	89 45 d8	 mov	 DWORD PTR _copy$6$[ebp], eax
  01352	3b 45 cc	 cmp	 eax, DWORD PTR _copy$5$[ebp]
  01355	76 5d		 jbe	 SHORT $LN476@inflate

; 1136 :                 copy = state->offset - copy;

  01357	2b 45 cc	 sub	 eax, DWORD PTR _copy$5$[ebp]
  0135a	89 45 d8	 mov	 DWORD PTR _copy$6$[ebp], eax

; 1137 :                 if (copy > state->whave) {

  0135d	3b 41 30	 cmp	 eax, DWORD PTR [ecx+48]
  01360	76 18		 jbe	 SHORT $LN479@inflate

; 1138 :                     if (state->sane) {

  01362	83 b9 c4 1b 00
	00 00		 cmp	 DWORD PTR [ecx+7108], 0
  01369	74 0f		 je	 SHORT $LN479@inflate

; 1139 :                         strm->msg = (char *)"invalid distance too far back";

  0136b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0136e	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@

; 1140 :                         state->mode = BAD;
; 1141 :                         break;

  01375	e9 0a 02 00 00	 jmp	 $LN1105@inflate
$LN479@inflate:

; 1142 :                     }
; 1143 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1144 :                     Trace((stderr, "inflate.c too far\n"));
; 1145 :                     copy -= state->whave;
; 1146 :                     if (copy > state->length) copy = state->length;
; 1147 :                     if (copy > left) copy = left;
; 1148 :                     left -= copy;
; 1149 :                     state->length -= copy;
; 1150 :                     do {
; 1151 :                         *put++ = 0;
; 1152 :                     } while (--copy);
; 1153 :                     if (state->length == 0) state->mode = LEN;
; 1154 :                     break;
; 1155 : #endif
; 1156 :                 }
; 1157 :                 if (copy > state->wnext) {

  0137a	3b 41 34	 cmp	 eax, DWORD PTR [ecx+52]
  0137d	76 11		 jbe	 SHORT $LN480@inflate

; 1158 :                     copy -= state->wnext;

  0137f	2b 41 34	 sub	 eax, DWORD PTR [ecx+52]
  01382	89 45 d8	 mov	 DWORD PTR _copy$6$[ebp], eax

; 1159 :                     from = state->window + (state->wsize - copy);

  01385	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  01388	2b 45 d8	 sub	 eax, DWORD PTR _copy$6$[ebp]
  0138b	03 41 38	 add	 eax, DWORD PTR [ecx+56]

; 1160 :                 }

  0138e	eb 09		 jmp	 SHORT $LN1109@inflate
$LN480@inflate:

; 1161 :                 else
; 1162 :                     from = state->window + (state->wnext - copy);

  01390	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  01393	2b 45 d8	 sub	 eax, DWORD PTR _copy$6$[ebp]
  01396	03 41 34	 add	 eax, DWORD PTR [ecx+52]
$LN1109@inflate:

; 1163 :                 if (copy > state->length) copy = state->length;

  01399	89 45 d0	 mov	 DWORD PTR _from$1$[ebp], eax
  0139c	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]

; 1164 :             }

  0139f	8b c8		 mov	 ecx, eax
  013a1	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
  013a4	8b 45 d8	 mov	 eax, DWORD PTR _copy$6$[ebp]
  013a7	3b c1		 cmp	 eax, ecx
  013a9	0f 46 c8	 cmovbe	 ecx, eax
  013ac	89 4d d8	 mov	 DWORD PTR _copy$7$[ebp], ecx
  013af	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  013b2	eb 12		 jmp	 SHORT $LN477@inflate
$LN476@inflate:

; 1165 :             else {                              /* copy from output */
; 1166 :                 from = put - state->offset;

  013b4	8b 45 e0	 mov	 eax, DWORD PTR _put$1$[ebp]
  013b7	2b 45 d8	 sub	 eax, DWORD PTR _copy$6$[ebp]
  013ba	89 45 d0	 mov	 DWORD PTR _from$1$[ebp], eax

; 1167 :                 copy = state->length;

  013bd	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  013c0	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
  013c3	89 45 d8	 mov	 DWORD PTR _copy$7$[ebp], eax
$LN477@inflate:

; 1168 :             }
; 1169 :             if (copy > left) copy = left;
; 1170 :             left -= copy;

  013c6	8b 5d e8	 mov	 ebx, DWORD PTR _left$1$[ebp]
  013c9	8b c3		 mov	 eax, ebx
  013cb	39 5d d8	 cmp	 DWORD PTR _copy$7$[ebp], ebx

; 1171 :             state->length -= copy;

  013ce	8b 55 cc	 mov	 edx, DWORD PTR $T1[ebp]
  013d1	0f 46 45 d8	 cmovbe	 eax, DWORD PTR _copy$7$[ebp]
  013d5	2b d0		 sub	 edx, eax
  013d7	89 45 c0	 mov	 DWORD PTR _copy$8$[ebp], eax
  013da	2b d8		 sub	 ebx, eax
  013dc	89 51 44	 mov	 DWORD PTR [ecx+68], edx
  013df	8b 55 d0	 mov	 edx, DWORD PTR _from$1$[ebp]
  013e2	8b c8		 mov	 ecx, eax
  013e4	89 5d e8	 mov	 DWORD PTR _left$1$[ebp], ebx
  013e7	8b 5d e0	 mov	 ebx, DWORD PTR _put$1$[ebp]
  013ea	2b d3		 sub	 edx, ebx
  013ec	0f 1f 40 00	 npad	 4
$LL306@inflate:

; 1172 :             do {
; 1173 :                 *put++ = *from++;

  013f0	8a 04 1a	 mov	 al, BYTE PTR [edx+ebx]
  013f3	88 03		 mov	 BYTE PTR [ebx], al
  013f5	43		 inc	 ebx

; 1174 :             } while (--copy);

  013f6	83 e9 01	 sub	 ecx, 1
  013f9	75 f5		 jne	 SHORT $LL306@inflate

; 1175 :             if (state->length == 0) state->mode = LEN;

  013fb	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  013fe	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  01401	89 5d e0	 mov	 DWORD PTR _put$1$[ebp], ebx
  01404	8b 5d f0	 mov	 ebx, DWORD PTR _next$1$[ebp]
  01407	83 79 44 00	 cmp	 DWORD PTR [ecx+68], 0
  0140b	0f 85 7a 01 00
	00		 jne	 $LN8@inflate
  01411	c7 41 04 48 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16200 ; 00003f48H

; 1176 :             break;

  01418	e9 6e 01 00 00	 jmp	 $LN8@inflate
$LN485@inflate:

; 1177 :         case LIT:
; 1178 :             if (left == 0) goto inf_leave;

  0141d	83 7d e8 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  01421	0f 84 b0 f1 ff
	ff		 je	 $LN919@inflate

; 1179 :             *put++ = (unsigned char)(state->length);

  01427	8a 41 44	 mov	 al, BYTE PTR [ecx+68]
  0142a	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  0142d	ff 45 e0	 inc	 DWORD PTR _put$1$[ebp]

; 1180 :             left--;

  01430	ff 4d e8	 dec	 DWORD PTR _left$1$[ebp]
  01433	88 01		 mov	 BYTE PTR [ecx], al

; 1181 :             state->mode = LEN;

  01435	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01438	c7 41 04 48 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16200 ; 00003f48H

; 1182 :             break;

  0143f	e9 47 01 00 00	 jmp	 $LN8@inflate
$LN487@inflate:

; 1183 :         case CHECK:
; 1184 :             if (state->wrap) {

  01444	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  01448	0f 84 d5 00 00
	00		 je	 $LN316@inflate

; 1185 :                 NEEDBITS(32);

  0144e	83 fe 20	 cmp	 esi, 32			; 00000020H
  01451	73 24		 jae	 SHORT $LN307@inflate
$LL310@inflate:
  01453	85 ff		 test	 edi, edi
  01455	0f 84 7c f1 ff
	ff		 je	 $LN919@inflate
  0145b	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0145e	8b ce		 mov	 ecx, esi
  01460	d3 e0		 shl	 eax, cl
  01462	83 c6 08	 add	 esi, 8
  01465	03 d0		 add	 edx, eax
  01467	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0146a	43		 inc	 ebx
  0146b	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  0146e	4f		 dec	 edi
  0146f	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  01472	83 fe 20	 cmp	 esi, 32			; 00000020H
  01475	72 dc		 jb	 SHORT $LL310@inflate
$LN307@inflate:

; 1186 :                 out -= left;

  01477	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  0147a	29 45 dc	 sub	 DWORD PTR _out$1$[ebp], eax

; 1187 :                 strm->total_out += out;

  0147d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01480	8b 4d dc	 mov	 ecx, DWORD PTR _out$1$[ebp]
  01483	01 48 14	 add	 DWORD PTR [eax+20], ecx

; 1188 :                 state->total += out;

  01486	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01489	8b 45 dc	 mov	 eax, DWORD PTR _out$1$[ebp]
  0148c	01 41 20	 add	 DWORD PTR [ecx+32], eax

; 1189 :                 if ((state->wrap & 4) && out)

  0148f	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  01493	74 33		 je	 SHORT $LN490@inflate
  01495	85 c0		 test	 eax, eax
  01497	74 2f		 je	 SHORT $LN490@inflate

; 1190 :                     strm->adler = state->check =

  01499	8b 45 e0	 mov	 eax, DWORD PTR _put$1$[ebp]
  0149c	ff 75 dc	 push	 DWORD PTR _out$1$[ebp]
  0149f	2b 45 dc	 sub	 eax, DWORD PTR _out$1$[ebp]
  014a2	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  014a6	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  014a9	50		 push	 eax
  014aa	52		 push	 edx
  014ab	74 07		 je	 SHORT $LN512@inflate
  014ad	e8 00 00 00 00	 call	 _crc32@12
  014b2	eb 05		 jmp	 SHORT $LN513@inflate
$LN512@inflate:
  014b4	e8 00 00 00 00	 call	 _adler32@12
$LN513@inflate:
  014b9	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  014bc	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  014bf	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  014c2	89 42 30	 mov	 DWORD PTR [edx+48], eax
  014c5	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN490@inflate:

; 1191 :                         UPDATE_CHECK(state->check, put - out, out);
; 1192 :                 out = left;
; 1193 :                 if ((state->wrap & 4) && (

  014c8	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  014cc	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  014cf	89 45 dc	 mov	 DWORD PTR _out$1$[ebp], eax
  014d2	74 45		 je	 SHORT $LN317@inflate
  014d4	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  014d8	8b c2		 mov	 eax, edx
  014da	75 2c		 jne	 SHORT $LN515@inflate
  014dc	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  014e1	89 45 d8	 mov	 DWORD PTR tv5147[ebp], eax
  014e4	8b c2		 mov	 eax, edx
  014e6	c1 e0 10	 shl	 eax, 16			; 00000010H
  014e9	01 45 d8	 add	 DWORD PTR tv5147[ebp], eax
  014ec	8b c2		 mov	 eax, edx
  014ee	c1 65 d8 08	 shl	 DWORD PTR tv5147[ebp], 8
  014f2	c1 e8 08	 shr	 eax, 8
  014f5	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  014fa	01 45 d8	 add	 DWORD PTR tv5147[ebp], eax
  014fd	8b c2		 mov	 eax, edx
  014ff	c1 e8 18	 shr	 eax, 24			; 00000018H
  01502	01 45 d8	 add	 DWORD PTR tv5147[ebp], eax
  01505	8b 45 d8	 mov	 eax, DWORD PTR tv5147[ebp]
$LN515@inflate:
  01508	3b 41 1c	 cmp	 eax, DWORD PTR [ecx+28]
  0150b	74 0c		 je	 SHORT $LN317@inflate

; 1194 : #ifdef GUNZIP
; 1195 :                      state->flags ? hold :
; 1196 : #endif
; 1197 :                      ZSWAP32(hold)) != state->check) {
; 1198 :                     strm->msg = (char *)"incorrect data check";

  0150d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01510	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BF@MEIGEHBE@incorrect?5data?5check@

; 1199 :                     state->mode = BAD;
; 1200 :                     break;

  01517	eb 6b		 jmp	 SHORT $LN1105@inflate
$LN317@inflate:

; 1201 :                 }
; 1202 :                 INITBITS();

  01519	33 d2		 xor	 edx, edx
  0151b	33 f6		 xor	 esi, esi
  0151d	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  01520	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN316@inflate:

; 1203 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1204 :             }
; 1205 : #ifdef GUNZIP
; 1206 :             state->mode = LENGTH;

  01523	c7 41 04 4f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16207 ; 00003f4fH
$LN492@inflate:

; 1207 :                 /* fallthrough */
; 1208 :         case LENGTH:
; 1209 :             if (state->wrap && state->flags) {

  0152a	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0152d	89 45 c0	 mov	 DWORD PTR tv5074[ebp], eax
  01530	85 c0		 test	 eax, eax
  01532	0f 84 a6 00 00
	00		 je	 $LN327@inflate
  01538	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  0153c	0f 84 9c 00 00
	00		 je	 $LN327@inflate

; 1210 :                 NEEDBITS(32);

  01542	83 fe 20	 cmp	 esi, 32			; 00000020H
  01545	73 2a		 jae	 SHORT $LN318@inflate
$LL321@inflate:
  01547	85 ff		 test	 edi, edi
  01549	0f 84 88 f0 ff
	ff		 je	 $LN919@inflate
  0154f	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  01552	8b ce		 mov	 ecx, esi
  01554	d3 e0		 shl	 eax, cl
  01556	83 c6 08	 add	 esi, 8
  01559	03 d0		 add	 edx, eax
  0155b	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0155e	43		 inc	 ebx
  0155f	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  01562	4f		 dec	 edi
  01563	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  01566	83 fe 20	 cmp	 esi, 32			; 00000020H
  01569	72 dc		 jb	 SHORT $LL321@inflate
  0156b	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0156e	8b 45 c0	 mov	 eax, DWORD PTR tv5074[ebp]
$LN318@inflate:

; 1211 :                 if ((state->wrap & 4) && hold != (state->total & 0xffffffff)) {

  01571	a8 04		 test	 al, 4
  01573	74 60		 je	 SHORT $LN328@inflate
  01575	3b 51 20	 cmp	 edx, DWORD PTR [ecx+32]
  01578	74 5b		 je	 SHORT $LN328@inflate

; 1212 :                     strm->msg = (char *)"incorrect length check";

  0157a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0157d	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
$LN1105@inflate:

; 617  :     in = have;
; 618  :     out = left;
; 619  :     ret = Z_OK;
; 620  :     for (;;)
; 621  :         switch (state->mode) {

  01584	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
$LN8@inflate:
  0158b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0158e	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  01593	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  01596	0f 86 04 eb ff
	ff		 jbe	 $LL5@inflate
$LN333@inflate:
  0159c	5f		 pop	 edi

; 1262 :         ret = Z_BUF_ERROR;
; 1263 :     return ret;
; 1264 : }

  0159d	5e		 pop	 esi
  0159e	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  015a3	5b		 pop	 ebx
  015a4	8b e5		 mov	 esp, ebp
  015a6	5d		 pop	 ebp
  015a7	c2 08 00	 ret	 8
$LN587@inflate:

; 818  :                 RESTORE();

  015aa	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  015ad	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  015b0	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  015b3	8b 4d e8	 mov	 ecx, DWORD PTR _left$1$[ebp]
  015b6	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  015b9	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  015bc	89 78 04	 mov	 DWORD PTR [eax+4], edi
  015bf	89 18		 mov	 DWORD PTR [eax], ebx

; 819  :                 return Z_NEED_DICT;

  015c1	b8 02 00 00 00	 mov	 eax, 2
  015c6	5f		 pop	 edi
  015c7	89 71 40	 mov	 DWORD PTR [ecx+64], esi

; 1262 :         ret = Z_BUF_ERROR;
; 1263 :     return ret;
; 1264 : }

  015ca	5e		 pop	 esi
  015cb	89 51 3c	 mov	 DWORD PTR [ecx+60], edx
  015ce	5b		 pop	 ebx
  015cf	8b e5		 mov	 esp, ebp
  015d1	5d		 pop	 ebp
  015d2	c2 08 00	 ret	 8
$LN328@inflate:

; 1213 :                     state->mode = BAD;
; 1214 :                     break;
; 1215 :                 }
; 1216 :                 INITBITS();

  015d5	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  015dc	33 f6		 xor	 esi, esi
$LN327@inflate:

; 1217 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1218 :             }
; 1219 : #endif
; 1220 :             state->mode = DONE;

  015de	c7 41 04 50 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16208 ; 00003f50H
$LN496@inflate:

; 1221 :                 /* fallthrough */
; 1222 :         case DONE:
; 1223 :             ret = Z_STREAM_END;

  015e5	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _ret$1$[ebp], 1

; 1224 :             goto inf_leave;

  015ec	e9 e6 ef ff ff	 jmp	 $LN919@inflate
$LN497@inflate:

; 1225 :         case BAD:
; 1226 :             ret = Z_DATA_ERROR;

  015f1	c7 45 d4 fd ff
	ff ff		 mov	 DWORD PTR _ret$1$[ebp], -3 ; fffffffdH
  015f8	e9 da ef ff ff	 jmp	 $LN919@inflate
$LN906@inflate:

; 1227 :             goto inf_leave;
; 1228 :         case MEM:
; 1229 :             return Z_MEM_ERROR;
; 1230 :         case SYNC:
; 1231 :                 /* fallthrough */
; 1232 :         default:
; 1233 :             return Z_STREAM_ERROR;
; 1234 :         }
; 1235 : 
; 1236 :     /*
; 1237 :        Return from inflate(), updating the total counts and the check value.
; 1238 :        If there was no progress during the inflate() call, return a buffer
; 1239 :        error.  Call updatewindow() to create and/or update the window state.
; 1240 :        Note: a memory error from inflate() is non-recoverable.
; 1241 :      */
; 1242 :   inf_leave:
; 1243 :     RESTORE();

  015fd	8b d0		 mov	 edx, eax
  015ff	e9 d6 ef ff ff	 jmp	 $inf_leave$1112
$LN883@inflate:

; 1245 :             (state->mode < CHECK || flush != Z_FINISH)))
; 1246 :         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {

  01604	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
$LN504@inflate:

; 1248 :             return Z_MEM_ERROR;
; 1249 :         }
; 1250 :     in -= strm->avail_in;

  01607	8b 45 c8	 mov	 eax, DWORD PTR _in$1$[ebp]
  0160a	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]

; 1251 :     out -= strm->avail_out;

  0160d	2b 71 10	 sub	 esi, DWORD PTR [ecx+16]

; 1252 :     strm->total_in += in;

  01610	01 41 08	 add	 DWORD PTR [ecx+8], eax

; 1253 :     strm->total_out += out;

  01613	01 71 14	 add	 DWORD PTR [ecx+20], esi

; 1254 :     state->total += out;

  01616	01 73 20	 add	 DWORD PTR [ebx+32], esi

; 1255 :     if ((state->wrap & 4) && out)

  01619	f6 43 0c 04	 test	 BYTE PTR [ebx+12], 4
  0161d	89 45 c8	 mov	 DWORD PTR _in$1$[ebp], eax
  01620	89 75 dc	 mov	 DWORD PTR _out$1$[ebp], esi
  01623	74 35		 je	 SHORT $LN880@inflate
  01625	85 f6		 test	 esi, esi
  01627	74 31		 je	 SHORT $LN880@inflate

; 1256 :         strm->adler = state->check =

  01629	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0162c	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  0162f	2b c6		 sub	 eax, esi
  01631	83 7b 14 00	 cmp	 DWORD PTR [ebx+20], 0
  01635	56		 push	 esi
  01636	50		 push	 eax
  01637	51		 push	 ecx
  01638	74 10		 je	 SHORT $LN516@inflate
  0163a	e8 00 00 00 00	 call	 _crc32@12
  0163f	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  01642	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  01645	89 47 30	 mov	 DWORD PTR [edi+48], eax
  01648	eb 13		 jmp	 SHORT $LN505@inflate
$LN516@inflate:
  0164a	e8 00 00 00 00	 call	 _adler32@12
  0164f	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  01652	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  01655	89 47 30	 mov	 DWORD PTR [edi+48], eax
  01658	eb 03		 jmp	 SHORT $LN505@inflate
$LN880@inflate:

; 1257 :             UPDATE_CHECK(state->check, strm->next_out - out, out);
; 1258 :     strm->data_type = (int)state->bits + (state->last ? 64 : 0) +

  0165a	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
$LN505@inflate:
  0165d	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  01660	81 fa 47 3f 00
	00		 cmp	 edx, 16199		; 00003f47H
  01666	74 0c		 je	 SHORT $LN518@inflate
  01668	81 fa 42 3f 00
	00		 cmp	 edx, 16194		; 00003f42H
  0166e	74 04		 je	 SHORT $LN518@inflate
  01670	33 f6		 xor	 esi, esi
  01672	eb 05		 jmp	 SHORT $LN519@inflate
$LN518@inflate:
  01674	be 00 01 00 00	 mov	 esi, 256		; 00000100H
$LN519@inflate:
  01679	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0167c	f7 d9		 neg	 ecx
  0167e	c7 45 08 80 00
	00 00		 mov	 DWORD PTR tv4924[ebp], 128 ; 00000080H
  01685	1b c9		 sbb	 ecx, ecx
  01687	33 c0		 xor	 eax, eax
  01689	83 e1 40	 and	 ecx, 64			; 00000040H
  0168c	81 fa 3f 3f 00
	00		 cmp	 edx, 16191		; 00003f3fH
  01692	0f 44 45 08	 cmove	 eax, DWORD PTR tv4924[ebp]
  01696	03 ce		 add	 ecx, esi
  01698	03 c1		 add	 eax, ecx
  0169a	03 43 40	 add	 eax, DWORD PTR [ebx+64]

; 1259 :                       (state->mode == TYPE ? 128 : 0) +
; 1260 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
; 1261 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  0169d	83 7d c8 00	 cmp	 DWORD PTR _in$1$[ebp], 0
  016a1	89 47 2c	 mov	 DWORD PTR [edi+44], eax
  016a4	75 06		 jne	 SHORT $LN508@inflate
  016a6	83 7d dc 00	 cmp	 DWORD PTR _out$1$[ebp], 0
  016aa	74 06		 je	 SHORT $LN507@inflate
$LN508@inflate:
  016ac	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  016b0	75 16		 jne	 SHORT $LN885@inflate
$LN507@inflate:
  016b2	8b 45 d4	 mov	 eax, DWORD PTR _ret$1$[ebp]
  016b5	b9 fb ff ff ff	 mov	 ecx, -5			; fffffffbH
  016ba	5f		 pop	 edi
  016bb	85 c0		 test	 eax, eax

; 1262 :         ret = Z_BUF_ERROR;
; 1263 :     return ret;
; 1264 : }

  016bd	5e		 pop	 esi
  016be	0f 44 c1	 cmove	 eax, ecx
  016c1	5b		 pop	 ebx
  016c2	8b e5		 mov	 esp, ebp
  016c4	5d		 pop	 ebp
  016c5	c2 08 00	 ret	 8
$LN885@inflate:

; 1259 :                       (state->mode == TYPE ? 128 : 0) +
; 1260 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
; 1261 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  016c8	8b 45 d4	 mov	 eax, DWORD PTR _ret$1$[ebp]
  016cb	5f		 pop	 edi

; 1262 :         ret = Z_BUF_ERROR;
; 1263 :     return ret;
; 1264 : }

  016cc	5e		 pop	 esi
  016cd	5b		 pop	 ebx
  016ce	8b e5		 mov	 esp, ebp
  016d0	5d		 pop	 ebp
  016d1	c2 08 00	 ret	 8
$LN791@inflate:
  016d4	00 00 00 00	 DD	 $LN335@inflate
  016d8	00 00 00 00	 DD	 $LN32@inflate
  016dc	00 00 00 00	 DD	 $LN46@inflate
  016e0	00 00 00 00	 DD	 $LN60@inflate
  016e4	00 00 00 00	 DD	 $LN361@inflate
  016e8	00 00 00 00	 DD	 $LN368@inflate
  016ec	00 00 00 00	 DD	 $LN375@inflate
  016f0	00 00 00 00	 DD	 $LN384@inflate
  016f4	00 00 00 00	 DD	 $LN393@inflate
  016f8	00 00 00 00	 DD	 $LN105@inflate
  016fc	00 00 00 00	 DD	 $LN400@inflate
  01700	00 00 00 00	 DD	 $LN402@inflate
  01704	00 00 00 00	 DD	 $LN403@inflate
  01708	00 00 00 00	 DD	 $LN141@inflate
  0170c	00 00 00 00	 DD	 $LN416@inflate
  01710	00 00 00 00	 DD	 $LN418@inflate
  01714	00 00 00 00	 DD	 $LN155@inflate
  01718	00 00 00 00	 DD	 $LN533@inflate
  0171c	00 00 00 00	 DD	 $LN536@inflate
  01720	00 00 00 00	 DD	 $LN448@inflate
  01724	00 00 00 00	 DD	 $LN450@inflate
  01728	00 00 00 00	 DD	 $LN461@inflate
  0172c	00 00 00 00	 DD	 $LN464@inflate
  01730	00 00 00 00	 DD	 $LN471@inflate
  01734	00 00 00 00	 DD	 $LN474@inflate
  01738	00 00 00 00	 DD	 $LN485@inflate
  0173c	00 00 00 00	 DD	 $LN487@inflate
  01740	00 00 00 00	 DD	 $LN492@inflate
  01744	00 00 00 00	 DD	 $LN496@inflate
  01748	00 00 00 00	 DD	 $LN497@inflate
  0174c	00 00 00 00	 DD	 $LN498@inflate
  01750	00 00 00 00	 DD	 $LN333@inflate
$LN792@inflate:
  01754	00 00 00 00	 DD	 $LN408@inflate
  01758	00 00 00 00	 DD	 $LN409@inflate
  0175c	00 00 00 00	 DD	 $LN411@inflate
  01760	00 00 00 00	 DD	 $LN412@inflate
_inflate@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateEnd@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateEnd@4 PROC					; COMDAT

; 1266 : int ZEXPORT inflateEnd(z_streamp strm) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]

; 1267 :     struct inflate_state FAR *state;
; 1268 :     if (inflateStateCheck(strm))

  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 _inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0a		 je	 SHORT $LN2@inflateEnd

; 1269 :         return Z_STREAM_ERROR;

  00012	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00017	5e		 pop	 esi

; 1276 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN2@inflateEnd:

; 1270 :     state = (struct inflate_state FAR *)strm->state;
; 1271 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  0001c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0001f	53		 push	 ebx
  00020	57		 push	 edi
  00021	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00024	85 c0		 test	 eax, eax
  00026	74 0c		 je	 SHORT $LN5@inflateEnd
  00028	50		 push	 eax
  00029	ff 76 28	 push	 DWORD PTR [esi+40]
  0002c	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0002f	ff d0		 call	 eax
  00031	83 c4 08	 add	 esp, 8
$LN5@inflateEnd:

; 1272 :     ZFREE(strm, strm->state);

  00034	ff 76 1c	 push	 DWORD PTR [esi+28]
  00037	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0003a	ff 76 28	 push	 DWORD PTR [esi+40]
  0003d	ff d0		 call	 eax
  0003f	83 c4 08	 add	 esp, 8

; 1273 :     strm->state = Z_NULL;

  00042	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 1274 :     Tracev((stderr, "inflate: end\n"));
; 1275 :     return Z_OK;

  00049	33 c0		 xor	 eax, eax
  0004b	5f		 pop	 edi
  0004c	5b		 pop	 ebx
  0004d	5e		 pop	 esi

; 1276 : }

  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
_inflateEnd@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateStateCheck
_TEXT	SEGMENT
_inflateStateCheck PROC					; COMDAT
; _strm$ = ecx

; 95   :     struct inflate_state FAR *state;
; 96   :     if (strm == Z_NULL ||
; 97   :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)

  00000	85 c9		 test	 ecx, ecx
  00002	74 27		 je	 SHORT $LN3@inflateSta
  00004	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  00008	74 21		 je	 SHORT $LN3@inflateSta
  0000a	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0000e	74 1b		 je	 SHORT $LN3@inflateSta

; 99   :     state = (struct inflate_state FAR *)strm->state;

  00010	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 100  :     if (state == Z_NULL || state->strm != strm ||
; 101  :         state->mode < HEAD || state->mode > SYNC)

  00013	85 c0		 test	 eax, eax
  00015	74 14		 je	 SHORT $LN3@inflateSta
  00017	39 08		 cmp	 DWORD PTR [eax], ecx
  00019	75 10		 jne	 SHORT $LN3@inflateSta
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  00023	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00026	77 03		 ja	 SHORT $LN3@inflateSta

; 102  :         return 1;
; 103  :     return 0;

  00028	33 c0		 xor	 eax, eax

; 104  : }

  0002a	c3		 ret	 0
$LN3@inflateSta:

; 98   :         return 1;

  0002b	b8 01 00 00 00	 mov	 eax, 1

; 104  : }

  00030	c3		 ret	 0
_inflateStateCheck ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateResetKeep@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateResetKeep@4 PROC				; COMDAT

; 106  : int ZEXPORT inflateResetKeep(z_streamp strm) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 107  :     struct inflate_state FAR *state;
; 108  : 
; 109  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	8b ca		 mov	 ecx, edx
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	85 c0		 test	 eax, eax
  0000f	74 09		 je	 SHORT $LN2@inflateRes
  00011	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 128  : }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN2@inflateRes:

; 110  :     state = (struct inflate_state FAR *)strm->state;

  0001a	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]

; 111  :     strm->total_in = strm->total_out = state->total = 0;

  0001d	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
  00024	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0
  0002b	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 112  :     strm->msg = Z_NULL;

  00032	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 113  :     if (state->wrap)        /* to support ill-conceived Java test suite */

  00039	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0003c	85 c0		 test	 eax, eax
  0003e	74 06		 je	 SHORT $LN3@inflateRes

; 114  :         strm->adler = state->wrap & 1;

  00040	83 e0 01	 and	 eax, 1
  00043	89 42 30	 mov	 DWORD PTR [edx+48], eax
$LN3@inflateRes:

; 115  :     state->mode = HEAD;
; 116  :     state->last = 0;
; 117  :     state->havedict = 0;
; 118  :     state->flags = -1;
; 119  :     state->dmax = 32768U;
; 120  :     state->head = Z_NULL;
; 121  :     state->hold = 0;
; 122  :     state->bits = 0;
; 123  :     state->lencode = state->distcode = state->next = state->codes;

  00046	8d 81 34 05 00
	00		 lea	 eax, DWORD PTR [ecx+1332]
  0004c	c7 41 04 34 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16180 ; 00003f34H
  00053	89 41 70	 mov	 DWORD PTR [ecx+112], eax
  00056	89 41 54	 mov	 DWORD PTR [ecx+84], eax
  00059	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 124  :     state->sane = 1;
; 125  :     state->back = -1;
; 126  :     Tracev((stderr, "inflate: reset\n"));
; 127  :     return Z_OK;

  0005c	33 c0		 xor	 eax, eax
  0005e	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00065	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0006c	c7 41 14 ff ff
	ff ff		 mov	 DWORD PTR [ecx+20], -1
  00073	c7 41 18 00 80
	00 00		 mov	 DWORD PTR [ecx+24], 32768 ; 00008000H
  0007a	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0
  00081	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0
  00088	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0
  0008f	c7 81 c4 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+7108], 1
  00099	c7 81 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7112], -1

; 128  : }

  000a3	5d		 pop	 ebp
  000a4	c2 04 00	 ret	 4
_inflateResetKeep@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateReset2@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_inflateReset2@8 PROC					; COMDAT

; 141  : int ZEXPORT inflateReset2(z_streamp strm, int windowBits) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 142  :     int wrap;
; 143  :     struct inflate_state FAR *state;
; 144  : 
; 145  :     /* get the state */
; 146  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 75 0c	 mov	 esi, DWORD PTR _windowBits$[ebp]
  0000b	57		 push	 edi
  0000c	e8 00 00 00 00	 call	 _inflateStateCheck
  00011	85 c0		 test	 eax, eax
  00013	75 65		 jne	 SHORT $LN8@inflateRes

; 147  :     state = (struct inflate_state FAR *)strm->state;

  00015	8b 59 1c	 mov	 ebx, DWORD PTR [ecx+28]

; 148  : 
; 149  :     /* extract wrap request from windowBits parameter */
; 150  :     if (windowBits < 0) {

  00018	85 f6		 test	 esi, esi
  0001a	79 0b		 jns	 SHORT $LN3@inflateRes

; 151  :         if (windowBits < -15)

  0001c	83 fe f1	 cmp	 esi, -15		; fffffff1H
  0001f	7c 59		 jl	 SHORT $LN8@inflateRes

; 152  :             return Z_STREAM_ERROR;
; 153  :         wrap = 0;

  00021	33 ff		 xor	 edi, edi

; 154  :         windowBits = -windowBits;

  00023	f7 de		 neg	 esi

; 155  :     }

  00025	eb 10		 jmp	 SHORT $LN6@inflateRes
$LN3@inflateRes:

; 156  :     else {
; 157  :         wrap = (windowBits >> 4) + 5;

  00027	8b fe		 mov	 edi, esi
  00029	c1 ef 04	 shr	 edi, 4
  0002c	83 c7 05	 add	 edi, 5

; 158  : #ifdef GUNZIP
; 159  :         if (windowBits < 48)

  0002f	83 fe 30	 cmp	 esi, 48			; 00000030H
  00032	7d 03		 jge	 SHORT $LN6@inflateRes

; 160  :             windowBits &= 15;

  00034	83 e6 0f	 and	 esi, 15			; 0000000fH
$LN6@inflateRes:

; 161  : #endif
; 162  :     }
; 163  : 
; 164  :     /* set number of window bits, free window if different */
; 165  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  00037	85 f6		 test	 esi, esi
  00039	74 0a		 je	 SHORT $LN7@inflateRes
  0003b	83 fe 08	 cmp	 esi, 8
  0003e	7c 3a		 jl	 SHORT $LN8@inflateRes
  00040	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  00043	7f 35		 jg	 SHORT $LN8@inflateRes
$LN7@inflateRes:

; 166  :         return Z_STREAM_ERROR;
; 167  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  00045	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  00048	85 c0		 test	 eax, eax
  0004a	74 1b		 je	 SHORT $LN9@inflateRes
  0004c	39 73 28	 cmp	 DWORD PTR [ebx+40], esi
  0004f	74 16		 je	 SHORT $LN9@inflateRes

; 168  :         ZFREE(strm, state->window);

  00051	50		 push	 eax
  00052	ff 71 28	 push	 DWORD PTR [ecx+40]
  00055	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00058	ff d0		 call	 eax
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0005d	83 c4 08	 add	 esp, 8

; 169  :         state->window = Z_NULL;

  00060	c7 43 38 00 00
	00 00		 mov	 DWORD PTR [ebx+56], 0
$LN9@inflateRes:

; 170  :     }
; 171  : 
; 172  :     /* update state and reset the rest of it */
; 173  :     state->wrap = wrap;
; 174  :     state->wbits = (unsigned)windowBits;
; 175  :     return inflateReset(strm);

  00067	51		 push	 ecx
  00068	89 7b 0c	 mov	 DWORD PTR [ebx+12], edi
  0006b	89 73 28	 mov	 DWORD PTR [ebx+40], esi
  0006e	e8 00 00 00 00	 call	 _inflateReset@4
  00073	5f		 pop	 edi

; 176  : }

  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	5d		 pop	 ebp
  00077	c2 08 00	 ret	 8
$LN8@inflateRes:
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00081	5b		 pop	 ebx
  00082	5d		 pop	 ebp
  00083	c2 08 00	 ret	 8
_inflateReset2@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateInit_@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_version$ = 12						; size = 4
_stream_size$ = 16					; size = 4
_inflateInit_@12 PROC					; COMDAT

; 219  :                          int stream_size) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 220  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00003	ff 75 10	 push	 DWORD PTR _stream_size$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _version$[ebp]
  00009	6a 0f		 push	 15			; 0000000fH
  0000b	ff 75 08	 push	 DWORD PTR _strm$[ebp]
  0000e	e8 00 00 00 00	 call	 _inflateInit2_@16

; 221  : }

  00013	5d		 pop	 ebp
  00014	c2 0c 00	 ret	 12			; 0000000cH
_inflateInit_@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflatePrime@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_bits$ = 12						; size = 4
_value$ = 16						; size = 4
_inflatePrime@12 PROC					; COMDAT

; 223  : int ZEXPORT inflatePrime(z_streamp strm, int bits, int value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  :     struct inflate_state FAR *state;
; 225  : 
; 226  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	8b ca		 mov	 ecx, edx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	e8 00 00 00 00	 call	 _inflateStateCheck
  0000f	85 c0		 test	 eax, eax
  00011	75 47		 jne	 SHORT $LN6@inflatePri

; 227  :     if (bits == 0)

  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _bits$[ebp]
  00016	85 c9		 test	 ecx, ecx
  00018	74 0b		 je	 SHORT $LN14@inflatePri

; 228  :         return Z_OK;
; 229  :     state = (struct inflate_state FAR *)strm->state;

  0001a	8b 52 1c	 mov	 edx, DWORD PTR [edx+28]

; 230  :     if (bits < 0) {

  0001d	79 0e		 jns	 SHORT $LN4@inflatePri

; 231  :         state->hold = 0;

  0001f	89 42 3c	 mov	 DWORD PTR [edx+60], eax

; 232  :         state->bits = 0;

  00022	89 42 40	 mov	 DWORD PTR [edx+64], eax
$LN14@inflatePri:

; 240  : }

  00025	5f		 pop	 edi
  00026	33 c0		 xor	 eax, eax
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 0c 00	 ret	 12			; 0000000cH
$LN4@inflatePri:

; 233  :         return Z_OK;
; 234  :     }
; 235  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  0002d	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00030	7f 28		 jg	 SHORT $LN6@inflatePri
  00032	8b 72 40	 mov	 esi, DWORD PTR [edx+64]
  00035	8d 3c 0e	 lea	 edi, DWORD PTR [esi+ecx]
  00038	83 ff 20	 cmp	 edi, 32			; 00000020H
  0003b	77 1d		 ja	 SHORT $LN6@inflatePri

; 236  :     value &= (1L << bits) - 1;

  0003d	b8 01 00 00 00	 mov	 eax, 1

; 237  :     state->hold += (unsigned)value << state->bits;
; 238  :     state->bits += (uInt)bits;

  00042	89 7a 40	 mov	 DWORD PTR [edx+64], edi
  00045	d3 e0		 shl	 eax, cl
  00047	8b ce		 mov	 ecx, esi
  00049	48		 dec	 eax
  0004a	23 45 10	 and	 eax, DWORD PTR _value$[ebp]
  0004d	d3 e0		 shl	 eax, cl
  0004f	01 42 3c	 add	 DWORD PTR [edx+60], eax

; 239  :     return Z_OK;

  00052	33 c0		 xor	 eax, eax
  00054	5f		 pop	 edi

; 240  : }

  00055	5e		 pop	 esi
  00056	5d		 pop	 ebp
  00057	c2 0c 00	 ret	 12			; 0000000cH
$LN6@inflatePri:
  0005a	5f		 pop	 edi

; 233  :         return Z_OK;
; 234  :     }
; 235  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  0005b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 240  : }

  00060	5e		 pop	 esi
  00061	5d		 pop	 ebp
  00062	c2 0c 00	 ret	 12			; 0000000cH
_inflatePrime@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _fixedtables
_TEXT	SEGMENT
_fixedtables PROC					; COMDAT
; _state$ = ecx

; 253  : #ifdef BUILDFIXED
; 254  :     static int virgin = 1;
; 255  :     static code *lenfix, *distfix;
; 256  :     static code fixed[544];
; 257  : 
; 258  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 259  :     if (virgin) {
; 260  :         unsigned sym, bits;
; 261  :         static code *next;
; 262  : 
; 263  :         /* literal/length table */
; 264  :         sym = 0;
; 265  :         while (sym < 144) state->lens[sym++] = 8;
; 266  :         while (sym < 256) state->lens[sym++] = 9;
; 267  :         while (sym < 280) state->lens[sym++] = 7;
; 268  :         while (sym < 288) state->lens[sym++] = 8;
; 269  :         next = fixed;
; 270  :         lenfix = next;
; 271  :         bits = 9;
; 272  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 273  : 
; 274  :         /* distance table */
; 275  :         sym = 0;
; 276  :         while (sym < 32) state->lens[sym++] = 5;
; 277  :         distfix = next;
; 278  :         bits = 5;
; 279  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 280  : 
; 281  :         /* do this just once */
; 282  :         virgin = 0;
; 283  :     }
; 284  : #else /* !BUILDFIXED */
; 285  : #   include "inffixed.h"
; 286  : #endif /* BUILDFIXED */
; 287  :     state->lencode = lenfix;

  00000	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], OFFSET ?lenfix@?1??fixedtables@@9@9

; 288  :     state->lenbits = 9;

  00007	c7 41 58 09 00
	00 00		 mov	 DWORD PTR [ecx+88], 9

; 289  :     state->distcode = distfix;

  0000e	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], OFFSET ?distfix@?1??fixedtables@@9@9

; 290  :     state->distbits = 5;

  00015	c7 41 5c 05 00
	00 00		 mov	 DWORD PTR [ecx+92], 5

; 291  : }

  0001c	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _updatewindow
_TEXT	SEGMENT
$T1 = -4						; size = 4
_copy$ = 8						; size = 4
_updatewindow PROC					; COMDAT
; _strm$ = ecx
; _end$ = edx

; 368  : local int updatewindow(z_streamp strm, const Bytef *end, unsigned copy) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b da		 mov	 ebx, edx
  00007	8b d1		 mov	 edx, ecx
  00009	56		 push	 esi

; 369  :     struct inflate_state FAR *state;
; 370  :     unsigned dist;
; 371  : 
; 372  :     state = (struct inflate_state FAR *)strm->state;

  0000a	8b 72 1c	 mov	 esi, DWORD PTR [edx+28]

; 373  : 
; 374  :     /* if it hasn't been done already, allocate space for the window */
; 375  :     if (state->window == Z_NULL) {

  0000d	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00010	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  00013	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00016	85 c0		 test	 eax, eax
  00018	75 2f		 jne	 SHORT $LN16@updatewind

; 376  :         state->window = (unsigned char FAR *)

  0001a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001c	b8 01 00 00 00	 mov	 eax, 1
  00021	d3 e0		 shl	 eax, cl
  00023	6a 01		 push	 1
  00025	50		 push	 eax
  00026	ff 72 28	 push	 DWORD PTR [edx+40]
  00029	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0002c	ff d0		 call	 eax
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00031	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00034	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 377  :                         ZALLOC(strm, 1U << state->wbits,
; 378  :                                sizeof(unsigned char));
; 379  :         if (state->window == Z_NULL) return 1;

  00037	85 c0		 test	 eax, eax
  00039	75 0b		 jne	 SHORT $LN17@updatewind
  0003b	5e		 pop	 esi
  0003c	b8 01 00 00 00	 mov	 eax, 1

; 412  : }

  00041	5b		 pop	 ebx
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
$LN17@updatewind:

; 377  :                         ZALLOC(strm, 1U << state->wbits,
; 378  :                                sizeof(unsigned char));
; 379  :         if (state->window == Z_NULL) return 1;

  00046	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
$LN16@updatewind:
  00049	57		 push	 edi

; 380  :     }
; 381  : 
; 382  :     /* if window not in use yet, initialize */
; 383  :     if (state->wsize == 0) {

  0004a	8b 7e 2c	 mov	 edi, DWORD PTR [esi+44]
  0004d	85 ff		 test	 edi, edi
  0004f	75 1a		 jne	 SHORT $LN15@updatewind

; 384  :         state->wsize = 1U << state->wbits;

  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	bf 01 00 00 00	 mov	 edi, 1
  00058	d3 e7		 shl	 edi, cl
  0005a	89 7e 2c	 mov	 DWORD PTR [esi+44], edi

; 385  :         state->wnext = 0;

  0005d	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0

; 386  :         state->whave = 0;

  00064	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
$LN15@updatewind:

; 387  :     }
; 388  : 
; 389  :     /* copy state->wsize or less output bytes into the circular window */
; 390  :     if (copy >= state->wsize) {

  0006b	8b 55 08	 mov	 edx, DWORD PTR _copy$[ebp]
  0006e	3b d7		 cmp	 edx, edi
  00070	72 23		 jb	 SHORT $LN5@updatewind

; 391  :         zmemcpy(state->window, end - state->wsize, state->wsize);

  00072	57		 push	 edi
  00073	2b df		 sub	 ebx, edi
  00075	53		 push	 ebx
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _memcpy

; 392  :         state->wnext = 0;
; 393  :         state->whave = state->wsize;

  0007c	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 409  :         }
; 410  :     }
; 411  :     return 0;

  00082	89 46 30	 mov	 DWORD PTR [esi+48], eax
  00085	33 c0		 xor	 eax, eax
  00087	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi

; 412  : }

  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
$LN5@updatewind:

; 394  :     }
; 395  :     else {
; 396  :         dist = state->wsize - state->wnext;

  00095	2b 7e 34	 sub	 edi, DWORD PTR [esi+52]

; 397  :         if (dist > copy) dist = copy;
; 398  :         zmemcpy(state->window + state->wnext, end - copy, dist);

  00098	8b c3		 mov	 eax, ebx
  0009a	3b fa		 cmp	 edi, edx
  0009c	0f 47 fa	 cmova	 edi, edx
  0009f	2b c2		 sub	 eax, edx
  000a1	57		 push	 edi
  000a2	50		 push	 eax
  000a3	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  000a6	03 46 34	 add	 eax, DWORD PTR [esi+52]
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 _memcpy

; 399  :         copy -= dist;

  000af	8b 45 08	 mov	 eax, DWORD PTR _copy$[ebp]
  000b2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b5	2b c7		 sub	 eax, edi
  000b7	89 45 08	 mov	 DWORD PTR _copy$[ebp], eax

; 400  :         if (copy) {

  000ba	74 24		 je	 SHORT $LN8@updatewind

; 401  :             zmemcpy(state->window, end - copy, copy);

  000bc	50		 push	 eax
  000bd	2b d8		 sub	 ebx, eax
  000bf	53		 push	 ebx
  000c0	ff 76 38	 push	 DWORD PTR [esi+56]
  000c3	e8 00 00 00 00	 call	 _memcpy

; 402  :             state->wnext = copy;
; 403  :             state->whave = state->wsize;

  000c8	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ce	8b 55 08	 mov	 edx, DWORD PTR _copy$[ebp]

; 409  :         }
; 410  :     }
; 411  :     return 0;

  000d1	89 46 30	 mov	 DWORD PTR [esi+48], eax
  000d4	33 c0		 xor	 eax, eax
  000d6	89 56 34	 mov	 DWORD PTR [esi+52], edx
  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi

; 412  : }

  000db	5b		 pop	 ebx
  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c3		 ret	 0
$LN8@updatewind:

; 404  :         }
; 405  :         else {
; 406  :             state->wnext += dist;

  000e0	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]

; 407  :             if (state->wnext == state->wsize) state->wnext = 0;

  000e3	33 d2		 xor	 edx, edx
  000e5	03 cf		 add	 ecx, edi
  000e7	3b 4e 2c	 cmp	 ecx, DWORD PTR [esi+44]
  000ea	0f 44 ca	 cmove	 ecx, edx
  000ed	89 4e 34	 mov	 DWORD PTR [esi+52], ecx

; 408  :             if (state->whave < state->wsize) state->whave += dist;

  000f0	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  000f3	3b 4e 2c	 cmp	 ecx, DWORD PTR [esi+44]
  000f6	73 06		 jae	 SHORT $LN11@updatewind
  000f8	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]

; 409  :         }
; 410  :     }
; 411  :     return 0;

  000fb	89 46 30	 mov	 DWORD PTR [esi+48], eax
$LN11@updatewind:
  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi
  00100	33 c0		 xor	 eax, eax

; 412  : }

  00102	5b		 pop	 ebx
  00103	8b e5		 mov	 esp, ebp
  00105	5d		 pop	 ebp
  00106	c3		 ret	 0
_updatewindow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateGetDictionary@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateGetDictionary@12 PROC				; COMDAT

; 1279 :                                  uInt *dictLength) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1280 :     struct inflate_state FAR *state;
; 1281 : 
; 1282 :     /* check state */
; 1283 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateGet
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1296 : }

  00014	5d		 pop	 ebp
  00015	c2 0c 00	 ret	 12			; 0000000cH
$LN2@inflateGet:
  00018	56		 push	 esi

; 1284 :     state = (struct inflate_state FAR *)strm->state;

  00019	8b 71 1c	 mov	 esi, DWORD PTR [ecx+28]

; 1285 : 
; 1286 :     /* copy dictionary */
; 1287 :     if (state->whave && dictionary != Z_NULL) {

  0001c	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0001f	85 c0		 test	 eax, eax
  00021	74 31		 je	 SHORT $LN3@inflateGet
  00023	57		 push	 edi
  00024	8b 7d 0c	 mov	 edi, DWORD PTR _dictionary$[ebp]
  00027	85 ff		 test	 edi, edi
  00029	74 28		 je	 SHORT $LN10@inflateGet

; 1288 :         zmemcpy(dictionary, state->window + state->wnext,

  0002b	2b 46 34	 sub	 eax, DWORD PTR [esi+52]
  0002e	50		 push	 eax
  0002f	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00032	03 46 34	 add	 eax, DWORD PTR [esi+52]
  00035	50		 push	 eax
  00036	57		 push	 edi
  00037	e8 00 00 00 00	 call	 _memcpy

; 1289 :                 state->whave - state->wnext);
; 1290 :         zmemcpy(dictionary + state->whave - state->wnext,

  0003c	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  0003f	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00042	51		 push	 ecx
  00043	ff 76 38	 push	 DWORD PTR [esi+56]
  00046	2b c1		 sub	 eax, ecx
  00048	03 c7		 add	 eax, edi
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 _memcpy
  00050	83 c4 18	 add	 esp, 24			; 00000018H
$LN10@inflateGet:
  00053	5f		 pop	 edi
$LN3@inflateGet:

; 1291 :                 state->window, state->wnext);
; 1292 :     }
; 1293 :     if (dictLength != Z_NULL)

  00054	8b 4d 10	 mov	 ecx, DWORD PTR _dictLength$[ebp]
  00057	85 c9		 test	 ecx, ecx
  00059	74 05		 je	 SHORT $LN4@inflateGet

; 1294 :         *dictLength = state->whave;

  0005b	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0005e	89 01		 mov	 DWORD PTR [ecx], eax
$LN4@inflateGet:

; 1295 :     return Z_OK;

  00060	33 c0		 xor	 eax, eax
  00062	5e		 pop	 esi

; 1296 : }

  00063	5d		 pop	 ebp
  00064	c2 0c 00	 ret	 12			; 0000000cH
_inflateGetDictionary@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateSetDictionary@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateSetDictionary@12 PROC				; COMDAT

; 1299 :                                  uInt dictLength) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1300 :     struct inflate_state FAR *state;
; 1301 :     unsigned long dictid;
; 1302 :     int ret;
; 1303 : 
; 1304 :     /* check state */
; 1305 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _strm$[ebp]
  00007	8b cb		 mov	 ecx, ebx
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	e8 00 00 00 00	 call	 _inflateStateCheck
  00010	85 c0		 test	 eax, eax
  00012	75 7d		 jne	 SHORT $LN10@inflateSet

; 1306 :     state = (struct inflate_state FAR *)strm->state;

  00014	8b 7b 1c	 mov	 edi, DWORD PTR [ebx+28]

; 1307 :     if (state->wrap != 0 && state->mode != DICT)

  00017	39 47 0c	 cmp	 DWORD PTR [edi+12], eax
  0001a	74 09		 je	 SHORT $LN9@inflateSet
  0001c	81 7f 04 3e 3f
	00 00		 cmp	 DWORD PTR [edi+4], 16190 ; 00003f3eH
  00023	75 6c		 jne	 SHORT $LN10@inflateSet
$LN9@inflateSet:

; 1308 :         return Z_STREAM_ERROR;
; 1309 : 
; 1310 :     /* check for correct dictionary identifier */
; 1311 :     if (state->mode == DICT) {

  00025	81 7f 04 3e 3f
	00 00		 cmp	 DWORD PTR [edi+4], 16190 ; 00003f3eH
  0002c	75 28		 jne	 SHORT $LN5@inflateSet

; 1312 :         dictid = adler32(0L, Z_NULL, 0);

  0002e	6a 00		 push	 0
  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	e8 00 00 00 00	 call	 _adler32@12

; 1313 :         dictid = adler32(dictid, dictionary, dictLength);

  00039	ff 75 10	 push	 DWORD PTR _dictLength$[ebp]
  0003c	ff 75 0c	 push	 DWORD PTR _dictionary$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _adler32@12

; 1314 :         if (dictid != state->check)

  00045	3b 47 1c	 cmp	 eax, DWORD PTR [edi+28]
  00048	74 0c		 je	 SHORT $LN5@inflateSet

; 1328 : }

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00051	5b		 pop	 ebx
  00052	5d		 pop	 ebp
  00053	c2 0c 00	 ret	 12			; 0000000cH
$LN5@inflateSet:

; 1315 :             return Z_DATA_ERROR;
; 1316 :     }
; 1317 : 
; 1318 :     /* copy dictionary to window using updatewindow(), which will amend the
; 1319 :        existing dictionary if appropriate */
; 1320 :     ret = updatewindow(strm, dictionary + dictLength, dictLength);

  00056	8b 45 10	 mov	 eax, DWORD PTR _dictLength$[ebp]
  00059	8b cb		 mov	 ecx, ebx
  0005b	8b 55 0c	 mov	 edx, DWORD PTR _dictionary$[ebp]
  0005e	50		 push	 eax
  0005f	8d 14 02	 lea	 edx, DWORD PTR [edx+eax]
  00062	e8 00 00 00 00	 call	 _updatewindow
  00067	83 c4 04	 add	 esp, 4

; 1321 :     if (ret) {

  0006a	85 c0		 test	 eax, eax
  0006c	74 13		 je	 SHORT $LN6@inflateSet

; 1322 :         state->mode = MEM;

  0006e	c7 47 04 52 3f
	00 00		 mov	 DWORD PTR [edi+4], 16210 ; 00003f52H

; 1323 :         return Z_MEM_ERROR;

  00075	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0007a	5f		 pop	 edi

; 1328 : }

  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	5d		 pop	 ebp
  0007e	c2 0c 00	 ret	 12			; 0000000cH
$LN6@inflateSet:

; 1324 :     }
; 1325 :     state->havedict = 1;

  00081	c7 47 10 01 00
	00 00		 mov	 DWORD PTR [edi+16], 1

; 1326 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1327 :     return Z_OK;

  00088	33 c0		 xor	 eax, eax
  0008a	5f		 pop	 edi

; 1328 : }

  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx
  0008d	5d		 pop	 ebp
  0008e	c2 0c 00	 ret	 12			; 0000000cH
$LN10@inflateSet:
  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00098	5b		 pop	 ebx
  00099	5d		 pop	 ebp
  0009a	c2 0c 00	 ret	 12			; 0000000cH
_inflateSetDictionary@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateGetHeader@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_head$ = 12						; size = 4
_inflateGetHeader@8 PROC				; COMDAT

; 1330 : int ZEXPORT inflateGetHeader(z_streamp strm, gz_headerp head) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1331 :     struct inflate_state FAR *state;
; 1332 : 
; 1333 :     /* check state */
; 1334 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	75 1c		 jne	 SHORT $LN5@inflateGet

; 1335 :     state = (struct inflate_state FAR *)strm->state;

  0000f	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]

; 1336 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00012	f6 41 0c 02	 test	 BYTE PTR [ecx+12], 2
  00016	74 13		 je	 SHORT $LN5@inflateGet

; 1337 : 
; 1338 :     /* save header structure */
; 1339 :     state->head = head;

  00018	8b 45 0c	 mov	 eax, DWORD PTR _head$[ebp]
  0001b	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 1340 :     head->done = 0;

  0001e	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 1341 :     return Z_OK;

  00025	33 c0		 xor	 eax, eax

; 1342 : }

  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
$LN5@inflateGet:

; 1336 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  0002b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1342 : }

  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
_inflateGetHeader@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _syncsearch
_TEXT	SEGMENT
_buf$1$ = -8						; size = 4
_have$1$ = -4						; size = 4
_len$ = 8						; size = 4
_syncsearch PROC					; COMDAT
; _have$ = ecx
; _buf$ = edx

; 1356 :                           unsigned len) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1357 :     unsigned got;
; 1358 :     unsigned next;
; 1359 : 
; 1360 :     got = *have;

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	56		 push	 esi
  00009	57		 push	 edi

; 1361 :     next = 0;
; 1362 :     while (next < len && got < 4) {

  0000a	8b 7d 08	 mov	 edi, DWORD PTR _len$[ebp]
  0000d	33 f6		 xor	 esi, esi
  0000f	89 55 f8	 mov	 DWORD PTR _buf$1$[ebp], edx
  00012	89 4d fc	 mov	 DWORD PTR _have$1$[ebp], ecx
  00015	85 ff		 test	 edi, edi
  00017	74 50		 je	 SHORT $LN13@syncsearch
  00019	53		 push	 ebx
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL2@syncsearch:
  00020	83 f8 04	 cmp	 eax, 4
  00023	73 36		 jae	 SHORT $LN14@syncsearch

; 1363 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  00025	8a 1c 16	 mov	 bl, BYTE PTR [esi+edx]
  00028	83 f8 02	 cmp	 eax, 2
  0002b	0f b6 cb	 movzx	 ecx, bl
  0002e	1b d2		 sbb	 edx, edx
  00030	81 e2 01 ff ff
	ff		 and	 edx, -255		; ffffff01H
  00036	81 c2 ff 00 00
	00		 add	 edx, 255		; 000000ffH
  0003c	3b ca		 cmp	 ecx, edx
  0003e	75 03		 jne	 SHORT $LN4@syncsearch

; 1364 :             got++;

  00040	40		 inc	 eax
  00041	eb 10		 jmp	 SHORT $LN7@syncsearch
$LN4@syncsearch:

; 1365 :         else if (buf[next])
; 1366 :             got = 0;
; 1367 :         else
; 1368 :             got = 4 - got;

  00043	b9 04 00 00 00	 mov	 ecx, 4
  00048	33 d2		 xor	 edx, edx
  0004a	2b c8		 sub	 ecx, eax
  0004c	84 db		 test	 bl, bl
  0004e	8b c1		 mov	 eax, ecx
  00050	0f 45 c2	 cmovne	 eax, edx
$LN7@syncsearch:

; 1369 :         next++;

  00053	8b 55 f8	 mov	 edx, DWORD PTR _buf$1$[ebp]
  00056	46		 inc	 esi
  00057	3b f7		 cmp	 esi, edi
  00059	72 c5		 jb	 SHORT $LL2@syncsearch
$LN14@syncsearch:

; 1370 :     }
; 1371 :     *have = got;

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _have$1$[ebp]
  0005e	5b		 pop	 ebx
  0005f	5f		 pop	 edi
  00060	89 01		 mov	 DWORD PTR [ecx], eax

; 1372 :     return next;

  00062	8b c6		 mov	 eax, esi

; 1373 : }

  00064	5e		 pop	 esi
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
$LN13@syncsearch:

; 1370 :     }
; 1371 :     *have = got;

  00069	89 01		 mov	 DWORD PTR [ecx], eax

; 1372 :     return next;

  0006b	8b c6		 mov	 eax, esi
  0006d	5f		 pop	 edi

; 1373 : }

  0006e	5e		 pop	 esi
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_syncsearch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateSync@4
_TEXT	SEGMENT
tv434 = -8						; size = 4
_state$1$ = -8						; size = 4
tv443 = -4						; size = 4
_buf$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateSync@4 PROC					; COMDAT

; 1375 : int ZEXPORT inflateSync(z_streamp strm) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 1376 :     unsigned len;               /* number of bytes to look at or looked at */
; 1377 :     int flags;                  /* temporary to save header status */
; 1378 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1379 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1380 :     struct inflate_state FAR *state;
; 1381 : 
; 1382 :     /* check parameters */
; 1383 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00007	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  0000a	8b ce		 mov	 ecx, esi
  0000c	e8 00 00 00 00	 call	 _inflateStateCheck
  00011	85 c0		 test	 eax, eax
  00013	74 0c		 je	 SHORT $LN4@inflateSyn
  00015	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0001a	5e		 pop	 esi

; 1421 : }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
$LN4@inflateSyn:

; 1384 :     state = (struct inflate_state FAR *)strm->state;
; 1385 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  00021	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00025	53		 push	 ebx
  00026	8b 5e 1c	 mov	 ebx, DWORD PTR [esi+28]
  00029	57		 push	 edi
  0002a	89 5d f8	 mov	 DWORD PTR _state$1$[ebp], ebx
  0002d	8d 7b 40	 lea	 edi, DWORD PTR [ebx+64]
  00030	75 13		 jne	 SHORT $LN17@inflateSyn
  00032	83 3f 08	 cmp	 DWORD PTR [edi], 8
  00035	73 0e		 jae	 SHORT $LN17@inflateSyn
  00037	5f		 pop	 edi
  00038	5b		 pop	 ebx
  00039	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  0003e	5e		 pop	 esi

; 1421 : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN17@inflateSyn:

; 1386 : 
; 1387 :     /* if first time, start search in bit buffer */
; 1388 :     if (state->mode != SYNC) {

  00045	81 7b 04 53 3f
	00 00		 cmp	 DWORD PTR [ebx+4], 16211 ; 00003f53H
  0004c	74 59		 je	 SHORT $LN15@inflateSyn

; 1389 :         state->mode = SYNC;
; 1390 :         state->hold <<= state->bits & 7;

  0004e	8b 17		 mov	 edx, DWORD PTR [edi]
  00050	8b ca		 mov	 ecx, edx
  00052	8b 43 3c	 mov	 eax, DWORD PTR [ebx+60]
  00055	83 e1 07	 and	 ecx, 7
  00058	d3 e0		 shl	 eax, cl

; 1391 :         state->bits -= state->bits & 7;

  0005a	2b d1		 sub	 edx, ecx

; 1392 :         len = 0;

  0005c	33 c9		 xor	 ecx, ecx
  0005e	c7 43 04 53 3f
	00 00		 mov	 DWORD PTR [ebx+4], 16211 ; 00003f53H
  00065	89 45 fc	 mov	 DWORD PTR tv443[ebp], eax
  00068	89 43 3c	 mov	 DWORD PTR [ebx+60], eax
  0006b	89 17		 mov	 DWORD PTR [edi], edx

; 1393 :         while (state->bits >= 8) {

  0006d	83 fa 08	 cmp	 edx, 8
  00070	72 1c		 jb	 SHORT $LN3@inflateSyn
  00072	8b d8		 mov	 ebx, eax
$LL2@inflateSyn:

; 1394 :             buf[len++] = (unsigned char)(state->hold);

  00074	88 5c 0d fc	 mov	 BYTE PTR _buf$[ebp+ecx], bl

; 1395 :             state->hold >>= 8;
; 1396 :             state->bits -= 8;

  00078	83 ea 08	 sub	 edx, 8
  0007b	c1 e8 08	 shr	 eax, 8
  0007e	41		 inc	 ecx
  0007f	8a d8		 mov	 bl, al
  00081	83 fa 08	 cmp	 edx, 8
  00084	73 ee		 jae	 SHORT $LL2@inflateSyn
  00086	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
  00089	89 17		 mov	 DWORD PTR [edi], edx
  0008b	89 43 3c	 mov	 DWORD PTR [ebx+60], eax
$LN3@inflateSyn:

; 1397 :         }
; 1398 :         state->have = 0;

  0008e	8d 7b 6c	 lea	 edi, DWORD PTR [ebx+108]

; 1399 :         syncsearch(&(state->have), buf, len);

  00091	8d 55 fc	 lea	 edx, DWORD PTR _buf$[ebp]
  00094	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  0009a	51		 push	 ecx
  0009b	8b cf		 mov	 ecx, edi
  0009d	e8 00 00 00 00	 call	 _syncsearch
  000a2	83 c4 04	 add	 esp, 4
  000a5	eb 03		 jmp	 SHORT $LN6@inflateSyn
$LN15@inflateSyn:
  000a7	8d 7b 6c	 lea	 edi, DWORD PTR [ebx+108]
$LN6@inflateSyn:

; 1400 :     }
; 1401 : 
; 1402 :     /* search available input */
; 1403 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  000aa	ff 76 04	 push	 DWORD PTR [esi+4]
  000ad	8b 16		 mov	 edx, DWORD PTR [esi]
  000af	8b cf		 mov	 ecx, edi
  000b1	e8 00 00 00 00	 call	 _syncsearch

; 1404 :     strm->avail_in -= len;

  000b6	29 46 04	 sub	 DWORD PTR [esi+4], eax
  000b9	83 c4 04	 add	 esp, 4

; 1405 :     strm->next_in += len;

  000bc	01 06		 add	 DWORD PTR [esi], eax

; 1406 :     strm->total_in += len;

  000be	01 46 08	 add	 DWORD PTR [esi+8], eax

; 1407 : 
; 1408 :     /* return no joy or set up to restart inflate() on a new block */
; 1409 :     if (state->have != 4) return Z_DATA_ERROR;

  000c1	83 3f 04	 cmp	 DWORD PTR [edi], 4
  000c4	74 0e		 je	 SHORT $LN7@inflateSyn
  000c6	5f		 pop	 edi
  000c7	5b		 pop	 ebx
  000c8	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  000cd	5e		 pop	 esi

; 1421 : }

  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c2 04 00	 ret	 4
$LN7@inflateSyn:

; 1410 :     if (state->flags == -1)

  000d4	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  000d7	89 45 f8	 mov	 DWORD PTR tv434[ebp], eax
  000da	83 f8 ff	 cmp	 eax, -1
  000dd	75 09		 jne	 SHORT $LN8@inflateSyn

; 1411 :         state->wrap = 0;    /* if no header yet, treat as raw */

  000df	c7 43 0c 00 00
	00 00		 mov	 DWORD PTR [ebx+12], 0
  000e6	eb 04		 jmp	 SHORT $LN9@inflateSyn
$LN8@inflateSyn:

; 1412 :     else
; 1413 :         state->wrap &= ~4;  /* no point in computing a check value now */

  000e8	83 63 0c fb	 and	 DWORD PTR [ebx+12], -5	; fffffffbH
$LN9@inflateSyn:

; 1414 :     flags = state->flags;
; 1415 :     in = strm->total_in;  out = strm->total_out;

  000ec	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]

; 1416 :     inflateReset(strm);

  000ef	ff 75 08	 push	 DWORD PTR _strm$[ebp]
  000f2	8b 76 14	 mov	 esi, DWORD PTR [esi+20]
  000f5	e8 00 00 00 00	 call	 _inflateReset@4

; 1417 :     strm->total_in = in;  strm->total_out = out;

  000fa	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  000fd	89 78 08	 mov	 DWORD PTR [eax+8], edi
  00100	89 70 14	 mov	 DWORD PTR [eax+20], esi

; 1418 :     state->flags = flags;

  00103	8b 45 f8	 mov	 eax, DWORD PTR tv434[ebp]
  00106	5f		 pop	 edi
  00107	89 43 14	 mov	 DWORD PTR [ebx+20], eax

; 1419 :     state->mode = TYPE;
; 1420 :     return Z_OK;

  0010a	33 c0		 xor	 eax, eax
  0010c	c7 43 04 3f 3f
	00 00		 mov	 DWORD PTR [ebx+4], 16191 ; 00003f3fH
  00113	5b		 pop	 ebx
  00114	5e		 pop	 esi

; 1421 : }

  00115	8b e5		 mov	 esp, ebp
  00117	5d		 pop	 ebp
  00118	c2 04 00	 ret	 4
_inflateSync@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateSyncPoint@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateSyncPoint@4 PROC				; COMDAT

; 1431 : int ZEXPORT inflateSyncPoint(z_streamp strm) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1432 :     struct inflate_state FAR *state;
; 1433 : 
; 1434 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateSyn
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1437 : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN2@inflateSyn:

; 1435 :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 1436 :     return state->mode == STORED && state->bits == 0;

  0001b	81 78 04 41 3f
	00 00		 cmp	 DWORD PTR [eax+4], 16193 ; 00003f41H
  00022	75 0f		 jne	 SHORT $LN4@inflateSyn
  00024	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00028	75 09		 jne	 SHORT $LN4@inflateSyn
  0002a	b8 01 00 00 00	 mov	 eax, 1

; 1437 : }

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
$LN4@inflateSyn:

; 1436 :     return state->mode == STORED && state->bits == 0;

  00033	33 c0		 xor	 eax, eax

; 1437 : }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
_inflateSyncPoint@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateCopy@8
_TEXT	SEGMENT
$T1 = -4						; size = 4
_dest$ = 8						; size = 4
_window$1$ = 12						; size = 4
_source$ = 12						; size = 4
_inflateCopy@8 PROC					; COMDAT

; 1439 : int ZEXPORT inflateCopy(z_streamp dest, z_streamp source) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 1440 :     struct inflate_state FAR *state;
; 1441 :     struct inflate_state FAR *copy;
; 1442 :     unsigned char FAR *window;
; 1443 :     unsigned wsize;
; 1444 : 
; 1445 :     /* check input */
; 1446 :     if (inflateStateCheck(source) || dest == Z_NULL)

  00005	8b 7d 0c	 mov	 edi, DWORD PTR _source$[ebp]
  00008	8b cf		 mov	 ecx, edi
  0000a	e8 00 00 00 00	 call	 _inflateStateCheck
  0000f	85 c0		 test	 eax, eax
  00011	0f 85 3c 01 00
	00		 jne	 $LN3@inflateCop
  00017	39 45 08	 cmp	 DWORD PTR _dest$[ebp], eax
  0001a	0f 84 33 01 00
	00		 je	 $LN3@inflateCop

; 1448 :     state = (struct inflate_state FAR *)source->state;
; 1449 : 
; 1450 :     /* allocate space */
; 1451 :     copy = (struct inflate_state FAR *)

  00020	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00023	53		 push	 ebx
  00024	8b 5f 1c	 mov	 ebx, DWORD PTR [edi+28]
  00027	56		 push	 esi
  00028	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  0002d	6a 01		 push	 1
  0002f	ff 77 28	 push	 DWORD PTR [edi+40]
  00032	ff d0		 call	 eax
  00034	8b f0		 mov	 esi, eax
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1452 :            ZALLOC(source, 1, sizeof(struct inflate_state));
; 1453 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  00039	85 f6		 test	 esi, esi
  0003b	74 3d		 je	 SHORT $LN23@inflateCop

; 1454 :     window = Z_NULL;
; 1455 :     if (state->window != Z_NULL) {

  0003d	83 7b 38 00	 cmp	 DWORD PTR [ebx+56], 0
  00041	8d 4b 28	 lea	 ecx, DWORD PTR [ebx+40]
  00044	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _window$1$[ebp], 0
  0004b	89 4d fc	 mov	 DWORD PTR $T1[ebp], ecx
  0004e	74 38		 je	 SHORT $LN11@inflateCop

; 1456 :         window = (unsigned char FAR *)

  00050	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00052	b8 01 00 00 00	 mov	 eax, 1
  00057	d3 e0		 shl	 eax, cl
  00059	6a 01		 push	 1
  0005b	50		 push	 eax
  0005c	ff 77 28	 push	 DWORD PTR [edi+40]
  0005f	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00062	ff d0		 call	 eax
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH
  00067	89 45 0c	 mov	 DWORD PTR _window$1$[ebp], eax

; 1457 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
; 1458 :         if (window == Z_NULL) {

  0006a	85 c0		 test	 eax, eax
  0006c	75 1d		 jne	 SHORT $LN12@inflateCop

; 1459 :             ZFREE(source, copy);

  0006e	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  00071	56		 push	 esi
  00072	ff 77 28	 push	 DWORD PTR [edi+40]
  00075	ff d0		 call	 eax
  00077	83 c4 08	 add	 esp, 8
$LN23@inflateCop:

; 1460 :             return Z_MEM_ERROR;

  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00081	5f		 pop	 edi

; 1481 : }

  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 08 00	 ret	 8
$LN11@inflateCop:
  00088	89 4d fc	 mov	 DWORD PTR $T1[ebp], ecx
$LN12@inflateCop:

; 1461 :         }
; 1462 :     }
; 1463 : 
; 1464 :     /* copy state */
; 1465 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  0008b	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  0008e	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]

; 1466 :     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));

  00091	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  00096	53		 push	 ebx
  00097	56		 push	 esi
  00098	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  0009b	0f 10 47 10	 movups	 xmm0, XMMWORD PTR [edi+16]
  0009f	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0
  000a3	0f 10 47 20	 movups	 xmm0, XMMWORD PTR [edi+32]
  000a7	0f 11 40 20	 movups	 XMMWORD PTR [eax+32], xmm0
  000ab	f3 0f 7e 47 30	 movq	 xmm0, QWORD PTR [edi+48]
  000b0	66 0f d6 40 30	 movq	 QWORD PTR [eax+48], xmm0
  000b5	e8 00 00 00 00	 call	 _memcpy

; 1467 :     copy->strm = dest;

  000ba	8b 7d 08	 mov	 edi, DWORD PTR _dest$[ebp]

; 1468 :     if (state->lencode >= state->codes &&

  000bd	8d 83 34 05 00
	00		 lea	 eax, DWORD PTR [ebx+1332]
  000c3	89 3e		 mov	 DWORD PTR [esi], edi
  000c5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c8	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
  000cb	3b c8		 cmp	 ecx, eax
  000cd	72 38		 jb	 SHORT $LN7@inflateCop
  000cf	8d 83 c0 1b 00
	00		 lea	 eax, DWORD PTR [ebx+7104]
  000d5	3b c8		 cmp	 ecx, eax
  000d7	77 2e		 ja	 SHORT $LN7@inflateCop

; 1469 :         state->lencode <= state->codes + ENOUGH - 1) {
; 1470 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  000d9	2b cb		 sub	 ecx, ebx
  000db	8d 81 cc fa ff
	ff		 lea	 eax, DWORD PTR [ecx-1332]
  000e1	c1 f8 02	 sar	 eax, 2
  000e4	05 4d 01 00 00	 add	 eax, 333		; 0000014dH
  000e9	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  000ec	89 46 50	 mov	 DWORD PTR [esi+80], eax

; 1471 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  000ef	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  000f2	2b c3		 sub	 eax, ebx
  000f4	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  000f9	c1 f8 02	 sar	 eax, 2
  000fc	05 4d 01 00 00	 add	 eax, 333		; 0000014dH
  00101	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  00104	89 46 54	 mov	 DWORD PTR [esi+84], eax
$LN7@inflateCop:

; 1472 :     }
; 1473 :     copy->next = copy->codes + (state->next - state->codes);

  00107	8b 43 70	 mov	 eax, DWORD PTR [ebx+112]
  0010a	2b c3		 sub	 eax, ebx
  0010c	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  00111	c1 f8 02	 sar	 eax, 2
  00114	05 4d 01 00 00	 add	 eax, 333		; 0000014dH
  00119	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  0011c	89 46 70	 mov	 DWORD PTR [esi+112], eax

; 1474 :     if (window != Z_NULL) {

  0011f	8b 45 0c	 mov	 eax, DWORD PTR _window$1$[ebp]
  00122	85 c0		 test	 eax, eax
  00124	74 1c		 je	 SHORT $LN8@inflateCop

; 1475 :         wsize = 1U << state->wbits;

  00126	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00129	ba 01 00 00 00	 mov	 edx, 1
  0012e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00130	d3 e2		 shl	 edx, cl

; 1476 :         zmemcpy(window, state->window, wsize);

  00132	52		 push	 edx
  00133	ff 73 38	 push	 DWORD PTR [ebx+56]
  00136	50		 push	 eax
  00137	e8 00 00 00 00	 call	 _memcpy
  0013c	8b 45 0c	 mov	 eax, DWORD PTR _window$1$[ebp]
  0013f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@inflateCop:

; 1477 :     }
; 1478 :     copy->window = window;

  00142	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 1479 :     dest->state = (struct internal_state FAR *)copy;
; 1480 :     return Z_OK;

  00145	33 c0		 xor	 eax, eax
  00147	89 77 1c	 mov	 DWORD PTR [edi+28], esi
  0014a	5e		 pop	 esi
  0014b	5b		 pop	 ebx
  0014c	5f		 pop	 edi

; 1481 : }

  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c2 08 00	 ret	 8
$LN3@inflateCop:

; 1447 :         return Z_STREAM_ERROR;

  00153	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00158	5f		 pop	 edi

; 1481 : }

  00159	8b e5		 mov	 esp, ebp
  0015b	5d		 pop	 ebp
  0015c	c2 08 00	 ret	 8
_inflateCopy@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateUndermine@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_subvert$ = 12						; size = 4
_inflateUndermine@8 PROC				; COMDAT

; 1483 : int ZEXPORT inflateUndermine(z_streamp strm, int subvert) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1484 :     struct inflate_state FAR *state;
; 1485 : 
; 1486 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateUnd
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1495 : #endif
; 1496 : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
$LN2@inflateUnd:

; 1487 :     state = (struct inflate_state FAR *)strm->state;
; 1488 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1489 :     state->sane = !subvert;
; 1490 :     return Z_OK;
; 1491 : #else
; 1492 :     (void)subvert;
; 1493 :     state->sane = 1;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0001b	c7 80 c4 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+7108], 1

; 1494 :     return Z_DATA_ERROR;

  00025	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 1495 : #endif
; 1496 : }

  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
_inflateUndermine@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateValidate@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_check$ = 12						; size = 4
_inflateValidate@8 PROC					; COMDAT

; 1498 : int ZEXPORT inflateValidate(z_streamp strm, int check) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1499 :     struct inflate_state FAR *state;
; 1500 : 
; 1501 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateVal
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1508 : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
$LN2@inflateVal:

; 1502 :     state = (struct inflate_state FAR *)strm->state;
; 1503 :     if (check && state->wrap)

  00018	83 7d 0c 00	 cmp	 DWORD PTR _check$[ebp], 0
  0001c	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0001f	74 13		 je	 SHORT $LN6@inflateVal
  00021	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00024	85 c9		 test	 ecx, ecx
  00026	74 0c		 je	 SHORT $LN6@inflateVal

; 1504 :         state->wrap |= 4;

  00028	83 c9 04	 or	 ecx, 4
  0002b	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 1507 :     return Z_OK;

  0002e	33 c0		 xor	 eax, eax

; 1508 : }

  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
$LN6@inflateVal:

; 1505 :     else
; 1506 :         state->wrap &= ~4;

  00034	83 60 0c fb	 and	 DWORD PTR [eax+12], -5	; fffffffbH

; 1507 :     return Z_OK;

  00038	33 c0		 xor	 eax, eax

; 1508 : }

  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
_inflateValidate@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateMark@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateMark@4 PROC					; COMDAT

; 1510 : long ZEXPORT inflateMark(z_streamp strm) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1511 :     struct inflate_state FAR *state;
; 1512 : 
; 1513 :     if (inflateStateCheck(strm))

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateMar

; 1514 :         return -(1L << 16);

  0000f	b8 00 00 ff ff	 mov	 eax, -65536		; ffff0000H

; 1517 :         (state->mode == COPY ? state->length :
; 1518 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1519 : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN2@inflateMar:

; 1515 :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 1516 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	81 f9 43 3f 00
	00		 cmp	 ecx, 16195		; 00003f43H
  00024	75 12		 jne	 SHORT $LN6@inflateMar
  00026	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00029	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  0002f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00032	03 c1		 add	 eax, ecx

; 1517 :         (state->mode == COPY ? state->length :
; 1518 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1519 : }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN6@inflateMar:

; 1516 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  00038	81 f9 4c 3f 00
	00		 cmp	 ecx, 16204		; 00003f4cH
  0003e	75 18		 jne	 SHORT $LN4@inflateMar
  00040	8b 88 cc 1b 00
	00		 mov	 ecx, DWORD PTR [eax+7116]
  00046	2b 48 44	 sub	 ecx, DWORD PTR [eax+68]
  00049	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  0004f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00052	03 c1		 add	 eax, ecx

; 1517 :         (state->mode == COPY ? state->length :
; 1518 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1519 : }

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
$LN4@inflateMar:

; 1516 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  00058	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  0005e	33 c9		 xor	 ecx, ecx
  00060	c1 e0 10	 shl	 eax, 16			; 00000010H
  00063	03 c1		 add	 eax, ecx

; 1517 :         (state->mode == COPY ? state->length :
; 1518 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1519 : }

  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
_inflateMark@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateCodesUsed@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateCodesUsed@4 PROC				; COMDAT

; 1521 : unsigned long ZEXPORT inflateCodesUsed(z_streamp strm) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1522 :     struct inflate_state FAR *state;
; 1523 :     if (inflateStateCheck(strm)) return (unsigned long)-1;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 07		 je	 SHORT $LN2@inflateCod
  0000f	83 c8 ff	 or	 eax, -1

; 1526 : }

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
$LN2@inflateCod:

; 1524 :     state = (struct inflate_state FAR *)strm->state;

  00016	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]

; 1525 :     return (unsigned long)(state->next - state->codes);

  00019	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  0001c	2b c1		 sub	 eax, ecx
  0001e	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  00023	c1 f8 02	 sar	 eax, 2

; 1526 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
_inflateCodesUsed@4 ENDP
_TEXT	ENDS
END
