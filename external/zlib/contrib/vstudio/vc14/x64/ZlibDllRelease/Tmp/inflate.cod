; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31935.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check@	; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@	; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check@	; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check@ DB 'incorrect length check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@ DB 'unknown header flags '
	DB	'set', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ DB 'unknown compression '
	DB	'method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check@ DB 'incorrect header check', 00H ; `string'
	ORG $+10
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	inflateCodesUsed
PUBLIC	inflateMark
PUBLIC	inflateValidate
PUBLIC	inflateUndermine
PUBLIC	inflateCopy
PUBLIC	inflateSyncPoint
PUBLIC	inflateSync
PUBLIC	inflateGetHeader
PUBLIC	inflateSetDictionary
PUBLIC	inflateGetDictionary
PUBLIC	inflatePrime
PUBLIC	inflateInit_
PUBLIC	inflateReset2
PUBLIC	inflateResetKeep
PUBLIC	inflateEnd
PUBLIC	inflate
PUBLIC	inflateInit2_
PUBLIC	inflateReset
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateCodesUsed DD imagerel $LN5
	DD	imagerel $LN5+52
	DD	imagerel $unwind$inflateCodesUsed
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateMark DD imagerel $LN9
	DD	imagerel $LN9+108
	DD	imagerel $unwind$inflateMark
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateValidate DD imagerel $LN9
	DD	imagerel $LN9+62
	DD	imagerel $unwind$inflateValidate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateUndermine DD imagerel $LN5
	DD	imagerel $LN5+47
	DD	imagerel $unwind$inflateUndermine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateCopy DD imagerel $LN19
	DD	imagerel $LN19+48
	DD	imagerel $unwind$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$inflateCopy DD imagerel $LN19+48
	DD	imagerel $LN19+92
	DD	imagerel $chain$2$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateCopy DD imagerel $LN19+92
	DD	imagerel $LN19+161
	DD	imagerel $chain$4$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$inflateCopy DD imagerel $LN19+161
	DD	imagerel $LN19+183
	DD	imagerel $chain$5$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$inflateCopy DD imagerel $LN19+183
	DD	imagerel $LN19+417
	DD	imagerel $chain$7$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$inflateCopy DD imagerel $LN19+417
	DD	imagerel $LN19+429
	DD	imagerel $chain$8$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSyncPoint DD imagerel $LN7
	DD	imagerel $LN7+59
	DD	imagerel $unwind$inflateSyncPoint
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSync DD imagerel $LN22
	DD	imagerel $LN22+34
	DD	imagerel $unwind$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$inflateSync DD imagerel $LN22+34
	DD	imagerel $LN22+68
	DD	imagerel $chain$0$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateSync DD imagerel $LN22+68
	DD	imagerel $LN22+237
	DD	imagerel $chain$4$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$inflateSync DD imagerel $LN22+237
	DD	imagerel $LN22+300
	DD	imagerel $chain$5$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$inflateSync DD imagerel $LN22+300
	DD	imagerel $LN22+322
	DD	imagerel $chain$6$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$syncsearch DD imagerel syncsearch
	DD	imagerel syncsearch+101
	DD	imagerel $unwind$syncsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateGetHeader DD imagerel $LN8
	DD	imagerel $LN8+51
	DD	imagerel $unwind$inflateGetHeader
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSetDictionary DD imagerel $LN13
	DD	imagerel $LN13+184
	DD	imagerel $unwind$inflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateGetDictionary DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$inflateGetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$updatewindow DD imagerel updatewindow
	DD	imagerel updatewindow+266
	DD	imagerel $unwind$updatewindow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflatePrime DD imagerel $LN9
	DD	imagerel $LN9+96
	DD	imagerel $unwind$inflatePrime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateReset2 DD imagerel $LN15
	DD	imagerel $LN15+152
	DD	imagerel $unwind$inflateReset2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateResetKeep DD imagerel $LN6
	DD	imagerel $LN6+145
	DD	imagerel $unwind$inflateResetKeep
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateEnd DD imagerel $LN7
	DD	imagerel $LN7+96
	DD	imagerel $unwind$inflateEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate DD imagerel $LN980
	DD	imagerel $LN980+6172
	DD	imagerel $unwind$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateInit2_ DD imagerel $LN14
	DD	imagerel $LN14+67
	DD	imagerel $unwind$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateInit2_ DD imagerel $LN14+67
	DD	imagerel $LN14+173
	DD	imagerel $chain$1$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateInit2_ DD imagerel $LN14+173
	DD	imagerel $LN14+225
	DD	imagerel $chain$3$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateInit2_ DD imagerel $LN14+225
	DD	imagerel $LN14+241
	DD	imagerel $chain$4$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateReset DD imagerel $LN5
	DD	imagerel $LN5+45
	DD	imagerel $unwind$inflateReset
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateReset DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateInit2_ DD 021H
	DD	imagerel $LN14
	DD	imagerel $LN14+67
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateInit2_ DD 040021H
	DD	077400H
	DD	065400H
	DD	imagerel $LN14
	DD	imagerel $LN14+67
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateInit2_ DD 040c21H
	DD	07740cH
	DD	065405H
	DD	imagerel $LN14
	DD	imagerel $LN14+67
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateInit2_ DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate DD 0a1801H
	DD	0123418H
	DD	0f0149218H
	DD	0d010e012H
	DD	0700cc00eH
	DD	0500a600bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateEnd DD 062b01H
	DD	07742bH
	DD	066426H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateResetKeep DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateReset2 DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflatePrime DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$updatewindow DD 0a6401H
	DD	09f464H
	DD	08745cH
	DD	0a340dH
	DD	0e009320dH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateGetDictionary DD 062e01H
	DD	06342eH
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSetDictionary DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateGetHeader DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$syncsearch DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$inflateSync DD 021H
	DD	imagerel $LN22+68
	DD	imagerel $LN22+237
	DD	imagerel $chain$4$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$inflateSync DD 020521H
	DD	0a5405H
	DD	imagerel $LN22+68
	DD	imagerel $LN22+237
	DD	imagerel $chain$4$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateSync DD 060a21H
	DD	04740aH
	DD	083405H
	DD	056400H
	DD	imagerel $LN22
	DD	imagerel $LN22+34
	DD	imagerel $unwind$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$inflateSync DD 020521H
	DD	056405H
	DD	imagerel $LN22
	DD	imagerel $LN22+34
	DD	imagerel $unwind$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSync DD 020601H
	DD	0e0025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSyncPoint DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$inflateCopy DD 021H
	DD	imagerel $LN19
	DD	imagerel $LN19+48
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$inflateCopy DD 0a0021H
	DD	04f400H
	DD	0be400H
	DD	0ac400H
	DD	096400H
	DD	083400H
	DD	imagerel $LN19
	DD	imagerel $LN19+48
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$inflateCopy DD 021H
	DD	imagerel $LN19+48
	DD	imagerel $LN19+92
	DD	imagerel $chain$2$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateCopy DD 040a21H
	DD	04f40aH
	DD	0ac405H
	DD	imagerel $LN19+48
	DD	imagerel $LN19+92
	DD	imagerel $chain$2$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$inflateCopy DD 061321H
	DD	0be413H
	DD	09640aH
	DD	083405H
	DD	imagerel $LN19
	DD	imagerel $LN19+48
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateCopy DD 030701H
	DD	070034207H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateUndermine DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateValidate DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateMark DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateCodesUsed DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT inflateReset
_TEXT	SEGMENT
strm$ = 48
inflateReset PROC					; COMDAT

; 147  : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 148  :     struct inflate_state FAR *state;
; 149  : 
; 150  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateRes
  0000d	b8 fe ff ff ff	 mov	 eax, -2

; 156  : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateRes:

; 151  :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 152  :     state->wsize = 0;

  0001b	33 d2		 xor	 edx, edx
  0001d	48 89 50 34	 mov	 QWORD PTR [rax+52], rdx

; 153  :     state->whave = 0;
; 154  :     state->wnext = 0;

  00021	89 50 3c	 mov	 DWORD PTR [rax+60], edx

; 156  : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 155  :     return inflateResetKeep(strm);

  00028	e9 00 00 00 00	 jmp	 inflateResetKeep
inflateReset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT inflateInit2_
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
version$ = 64
stream_size$ = 72
inflateInit2_ PROC					; COMDAT

; 203  : {

$LN14:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b f2		 mov	 esi, edx
  0000c	48 8b d9	 mov	 rbx, rcx

; 204  :     int ret;
; 205  :     struct inflate_state FAR *state;
; 206  : 
; 207  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  0000f	4d 85 c0	 test	 r8, r8
  00012	0f 84 c9 00 00
	00		 je	 $LN3@inflateIni
  00018	41 80 38 31	 cmp	 BYTE PTR [r8], 49	; 00000031H
  0001c	0f 85 bf 00 00
	00		 jne	 $LN3@inflateIni
  00022	41 83 f9 58	 cmp	 r9d, 88			; 00000058H
  00026	0f 85 b5 00 00
	00		 jne	 $LN3@inflateIni

; 208  :         stream_size != (int)(sizeof(z_stream)))
; 209  :         return Z_VERSION_ERROR;
; 210  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  0002c	48 85 c9	 test	 rcx, rcx
  0002f	75 0e		 jne	 SHORT $LN4@inflateIni
  00031	8d 41 fe	 lea	 eax, QWORD PTR [rcx-2]

; 240  : }

  00034	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5e		 pop	 rsi
  0003e	c3		 ret	 0
$LN4@inflateIni:

; 211  :     strm->msg = Z_NULL;                 /* in case we return an error */
; 212  :     if (strm->zalloc == (alloc_func)0) {

  0003f	48 8b 41 30	 mov	 rax, QWORD PTR [rcx+48]
  00043	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00048	33 ed		 xor	 ebp, ebp
  0004a	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0004f	48 89 69 20	 mov	 QWORD PTR [rcx+32], rbp
  00053	48 85 c0	 test	 rax, rax
  00056	75 13		 jne	 SHORT $LN10@inflateIni

; 213  : #ifdef Z_SOLO
; 214  :         return Z_STREAM_ERROR;
; 215  : #else
; 216  :         strm->zalloc = zcalloc;

  00058	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc

; 217  :         strm->opaque = (voidpf)0;

  0005f	48 89 69 40	 mov	 QWORD PTR [rcx+64], rbp
  00063	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
  00067	8b cd		 mov	 ecx, ebp
  00069	eb 04		 jmp	 SHORT $LN5@inflateIni
$LN10@inflateIni:
  0006b	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
$LN5@inflateIni:

; 218  : #endif
; 219  :     }
; 220  :     if (strm->zfree == (free_func)0)

  0006f	48 39 6b 38	 cmp	 QWORD PTR [rbx+56], rbp
  00073	75 0b		 jne	 SHORT $LN6@inflateIni

; 221  : #ifdef Z_SOLO
; 222  :         return Z_STREAM_ERROR;
; 223  : #else
; 224  :         strm->zfree = zcfree;

  00075	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:zcfree
  0007c	48 89 53 38	 mov	 QWORD PTR [rbx+56], rdx
$LN6@inflateIni:

; 225  : #endif
; 226  :     state = (struct inflate_state FAR *)

  00080	ba 01 00 00 00	 mov	 edx, 1
  00085	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  0008b	ff d0		 call	 rax
  0008d	48 8b f8	 mov	 rdi, rax

; 227  :             ZALLOC(strm, 1, sizeof(struct inflate_state));
; 228  :     if (state == Z_NULL) return Z_MEM_ERROR;

  00090	48 85 c0	 test	 rax, rax
  00093	75 18		 jne	 SHORT $LN7@inflateIni
  00095	8d 47 fc	 lea	 eax, QWORD PTR [rdi-4]
$LN12@inflateIni:
  00098	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  0009d	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 240  : }

  000a2	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ab	5e		 pop	 rsi
  000ac	c3		 ret	 0
$LN7@inflateIni:

; 229  :     Tracev((stderr, "inflate: allocated\n"));
; 230  :     strm->state = (struct internal_state FAR *)state;

  000ad	48 89 7b 28	 mov	 QWORD PTR [rbx+40], rdi

; 231  :     state->strm = strm;
; 232  :     state->window = Z_NULL;
; 233  :     state->mode = HEAD;     /* to pass state test in inflateReset2() */
; 234  :     ret = inflateReset2(strm, windowBits);

  000b1	8b d6		 mov	 edx, esi
  000b3	48 8b cb	 mov	 rcx, rbx
  000b6	48 89 18	 mov	 QWORD PTR [rax], rbx
  000b9	48 89 68 40	 mov	 QWORD PTR [rax+64], rbp
  000bd	c7 40 08 34 3f
	00 00		 mov	 DWORD PTR [rax+8], 16180 ; 00003f34H
  000c4	e8 00 00 00 00	 call	 inflateReset2
  000c9	8b f0		 mov	 esi, eax

; 235  :     if (ret != Z_OK) {

  000cb	85 c0		 test	 eax, eax
  000cd	74 0e		 je	 SHORT $LN8@inflateIni

; 236  :         ZFREE(strm, state);

  000cf	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000d3	48 8b d7	 mov	 rdx, rdi
  000d6	ff 53 38	 call	 QWORD PTR [rbx+56]

; 237  :         strm->state = Z_NULL;

  000d9	48 89 6b 28	 mov	 QWORD PTR [rbx+40], rbp
$LN8@inflateIni:

; 238  :     }
; 239  :     return ret;

  000dd	8b c6		 mov	 eax, esi
  000df	eb b7		 jmp	 SHORT $LN12@inflateIni
$LN3@inflateIni:

; 240  : }

  000e1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e6	b8 fa ff ff ff	 mov	 eax, -6
  000eb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ef	5e		 pop	 rsi
  000f0	c3		 ret	 0
inflateInit2_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT inflate
_TEXT	SEGMENT
left$1$ = 48
hbuf$ = 52
here$ = 56
in$1$ = 60
put$1$ = 64
strm$ = 144
flush$ = 152
out$1$ = 160
ret$1$ = 168
inflate	PROC						; COMDAT

; 628  : {

$LN980:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	55		 push	 rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 55		 push	 r13
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00018	4c 8b e1	 mov	 r12, rcx

; 629  :     struct inflate_state FAR *state;
; 630  :     z_const unsigned char FAR *next;    /* next input */
; 631  :     unsigned char FAR *put;     /* next output */
; 632  :     unsigned have, left;        /* available input and output */
; 633  :     unsigned long hold;         /* bit buffer */
; 634  :     unsigned bits;              /* bits in bit buffer */
; 635  :     unsigned in, out;           /* save starting available input and output */
; 636  :     unsigned copy;              /* number of stored or match bytes to copy */
; 637  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 638  :     code here;                  /* current decoding table entry */
; 639  :     code last;                  /* parent table entry */
; 640  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 641  :     int ret;                    /* return code */
; 642  : #ifdef GUNZIP
; 643  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 644  : #endif
; 645  :     static const unsigned short order[19] = /* permutation of code lengths */
; 646  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 647  : 
; 648  :     if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||

  0001b	e8 00 00 00 00	 call	 inflateStateCheck
  00020	85 c0		 test	 eax, eax
  00022	0f 85 54 17 00
	00		 jne	 $LN333@inflate
  00028	48 83 79 10 00	 cmp	 QWORD PTR [rcx+16], 0
  0002d	0f 84 49 17 00
	00		 je	 $LN333@inflate
  00033	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  00037	75 09		 jne	 SHORT $LN721@inflate
  00039	39 41 08	 cmp	 DWORD PTR [rcx+8], eax
  0003c	0f 85 3a 17 00
	00		 jne	 $LN333@inflate
$LN721@inflate:

; 651  : 
; 652  :     state = (struct inflate_state FAR *)strm->state;

  00042	4c 8b 69 28	 mov	 r13, QWORD PTR [rcx+40]

; 653  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00046	41 8b 45 08	 mov	 eax, DWORD PTR [r13+8]
  0004a	3d 3f 3f 00 00	 cmp	 eax, 16191		; 00003f3fH
  0004f	75 0d		 jne	 SHORT $LN4@inflate
  00051	41 c7 45 08 40
	3f 00 00	 mov	 DWORD PTR [r13+8], 16192 ; 00003f40H
  00059	b8 40 3f 00 00	 mov	 eax, 16192		; 00003f40H
$LN4@inflate:

; 654  :     LOAD();

  0005e	44 8b 59 18	 mov	 r11d, DWORD PTR [rcx+24]

; 655  :     in = have;
; 656  :     out = left;
; 657  :     ret = Z_OK;

  00062	45 33 ff	 xor	 r15d, r15d
  00065	4c 8b 51 10	 mov	 r10, QWORD PTR [rcx+16]

; 658  :     for (;;)
; 659  :         switch (state->mode) {

  00069	05 cc c0 ff ff	 add	 eax, -16180		; ffffffffffffc0ccH
  0006e	8b 71 08	 mov	 esi, DWORD PTR [rcx+8]
  00071	45 8b c3	 mov	 r8d, r11d
  00074	48 8b 29	 mov	 rbp, QWORD PTR [rcx]
  00077	45 8b 75 48	 mov	 r14d, DWORD PTR [r13+72]
  0007b	41 8b 5d 4c	 mov	 ebx, DWORD PTR [r13+76]
  0007f	4c 89 54 24 40	 mov	 QWORD PTR put$1$[rsp], r10
  00084	44 89 5c 24 30	 mov	 DWORD PTR left$1$[rsp], r11d
  00089	89 74 24 3c	 mov	 DWORD PTR in$1$[rsp], esi
  0008d	44 89 9c 24 a0
	00 00 00	 mov	 DWORD PTR out$1$[rsp], r11d
  00095	44 89 bc 24 a8
	00 00 00	 mov	 DWORD PTR ret$1$[rsp], r15d
  0009d	83 f8 1f	 cmp	 eax, 31
  000a0	0f 87 d6 16 00
	00		 ja	 $LN333@inflate
$LN976@inflate:
  000a6	48 98		 cdqe
  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000af	4d 8d 4d 74	 lea	 r9, QWORD PTR [r13+116]
  000b3	49 8d 7d 70	 lea	 rdi, QWORD PTR [r13+112]
  000b7	8b 8c 81 00 00
	00 00		 mov	 ecx, DWORD PTR $LN820@inflate[rcx+rax*4]
  000be	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:__ImageBase
  000c5	48 03 c8	 add	 rcx, rax
  000c8	ff e1		 jmp	 rcx
$LN335@inflate:

; 660  :         case HEAD:
; 661  :             if (state->wrap == 0) {

  000ca	41 8b 55 10	 mov	 edx, DWORD PTR [r13+16]
  000ce	85 d2		 test	 edx, edx
  000d0	75 0d		 jne	 SHORT $LN12@inflate

; 662  :                 state->mode = TYPEDO;

  000d2	41 c7 45 08 40
	3f 00 00	 mov	 DWORD PTR [r13+8], 16192 ; 00003f40H

; 663  :                 break;

  000da	e9 a2 06 00 00	 jmp	 $LN8@inflate
$LN12@inflate:

; 664  :             }
; 665  :             NEEDBITS(16);

  000df	83 fb 10	 cmp	 ebx, 16
  000e2	73 20		 jae	 SHORT $LN10@inflate
$LL13@inflate:
  000e4	85 f6		 test	 esi, esi
  000e6	0f 84 2b 08 00
	00		 je	 $LN938@inflate
  000ec	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  000f0	8b cb		 mov	 ecx, ebx
  000f2	d3 e0		 shl	 eax, cl
  000f4	ff ce		 dec	 esi
  000f6	44 03 f0	 add	 r14d, eax
  000f9	48 ff c5	 inc	 rbp
  000fc	83 c3 08	 add	 ebx, 8
  000ff	83 fb 10	 cmp	 ebx, 16
  00102	72 e0		 jb	 SHORT $LL13@inflate
$LN10@inflate:

; 666  : #ifdef GUNZIP
; 667  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  00104	f6 c2 02	 test	 dl, 2
  00107	74 5f		 je	 SHORT $LN338@inflate
  00109	41 81 fe 1f 8b
	00 00		 cmp	 r14d, 35615		; 00008b1fH
  00110	75 56		 jne	 SHORT $LN338@inflate

; 668  :                 if (state->wbits == 0)

  00112	41 83 7d 30 00	 cmp	 DWORD PTR [r13+48], 0
  00117	75 08		 jne	 SHORT $LN339@inflate

; 669  :                     state->wbits = 15;

  00119	41 c7 45 30 0f
	00 00 00	 mov	 DWORD PTR [r13+48], 15
$LN339@inflate:

; 670  :                 state->check = crc32(0L, Z_NULL, 0);

  00121	45 33 c0	 xor	 r8d, r8d
  00124	33 d2		 xor	 edx, edx
  00126	33 c9		 xor	 ecx, ecx
  00128	e8 00 00 00 00	 call	 crc32

; 671  :                 CRC2(state->check, hold);

  0012d	44 88 74 24 34	 mov	 BYTE PTR hbuf$[rsp], r14b
  00132	48 8d 54 24 34	 lea	 rdx, QWORD PTR hbuf$[rsp]
  00137	41 c1 ee 08	 shr	 r14d, 8
  0013b	41 b8 02 00 00
	00		 mov	 r8d, 2
  00141	8b c8		 mov	 ecx, eax
  00143	44 88 74 24 35	 mov	 BYTE PTR hbuf$[rsp+1], r14b
  00148	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  0014c	e8 00 00 00 00	 call	 crc32
  00151	41 89 45 20	 mov	 DWORD PTR [r13+32], eax

; 672  :                 INITBITS();

  00155	45 8b f7	 mov	 r14d, r15d
  00158	41 8b df	 mov	 ebx, r15d

; 673  :                 state->mode = FLAGS;

  0015b	41 c7 45 08 35
	3f 00 00	 mov	 DWORD PTR [r13+8], 16181 ; 00003f35H

; 674  :                 break;

  00163	e9 0f 06 00 00	 jmp	 $LN975@inflate
$LN338@inflate:

; 675  :             }
; 676  :             if (state->head != Z_NULL)

  00168	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  0016c	48 85 c0	 test	 rax, rax
  0016f	74 07		 je	 SHORT $LN340@inflate

; 677  :                 state->head->done = -1;

  00171	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1
$LN340@inflate:

; 678  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */

  00178	41 f6 45 10 01	 test	 BYTE PTR [r13+16], 1
  0017d	0f 84 d3 00 00
	00		 je	 $LN342@inflate
  00183	41 0f b6 ce	 movzx	 ecx, r14b
  00187	41 8b c6	 mov	 eax, r14d
  0018a	c1 e8 08	 shr	 eax, 8
  0018d	c1 e1 08	 shl	 ecx, 8
  00190	03 c8		 add	 ecx, eax
  00192	b8 85 10 42 08	 mov	 eax, 138547333		; 08421085H
  00197	f7 e1		 mul	 ecx
  00199	8b c1		 mov	 eax, ecx
  0019b	2b c2		 sub	 eax, edx
  0019d	d1 e8		 shr	 eax, 1
  0019f	03 c2		 add	 eax, edx
  001a1	c1 e8 04	 shr	 eax, 4
  001a4	6b c0 1f	 imul	 eax, eax, 31
  001a7	3b c8		 cmp	 ecx, eax
  001a9	0f 85 a7 00 00
	00		 jne	 $LN342@inflate

; 686  :             }
; 687  :             if (BITS(4) != Z_DEFLATED) {

  001af	41 8b c6	 mov	 eax, r14d
  001b2	24 0f		 and	 al, 15
  001b4	3c 08		 cmp	 al, 8
  001b6	74 19		 je	 SHORT $LN26@inflate

; 688  :                 strm->msg = (char *)"unknown compression method";

  001b8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
  001bf	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 689  :                 state->mode = BAD;

  001c4	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 690  :                 break;

  001cc	e9 b0 05 00 00	 jmp	 $LN8@inflate
$LN26@inflate:

; 691  :             }
; 692  :             DROPBITS(4);
; 693  :             len = BITS(4) + 8;
; 694  :             if (state->wbits == 0)

  001d1	41 8b 45 30	 mov	 eax, DWORD PTR [r13+48]
  001d5	83 c3 fc	 add	 ebx, -4			; fffffffcH
  001d8	41 c1 ee 04	 shr	 r14d, 4
  001dc	41 8b ce	 mov	 ecx, r14d
  001df	83 e1 0f	 and	 ecx, 15
  001e2	83 c1 08	 add	 ecx, 8
  001e5	85 c0		 test	 eax, eax
  001e7	75 06		 jne	 SHORT $LN344@inflate

; 695  :                 state->wbits = len;

  001e9	41 89 4d 30	 mov	 DWORD PTR [r13+48], ecx
  001ed	8b c1		 mov	 eax, ecx
$LN344@inflate:

; 696  :             if (len > 15 || len > state->wbits) {

  001ef	83 f9 0f	 cmp	 ecx, 15
  001f2	77 49		 ja	 SHORT $LN346@inflate
  001f4	3b c8		 cmp	 ecx, eax
  001f6	77 45		 ja	 SHORT $LN346@inflate

; 700  :             }
; 701  :             state->dmax = 1U << len;

  001f8	b8 01 00 00 00	 mov	 eax, 1

; 702  :             state->flags = 0;               /* indicate zlib header */

  001fd	45 89 7d 18	 mov	 DWORD PTR [r13+24], r15d
  00201	d3 e0		 shl	 eax, cl

; 703  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 704  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  00203	45 33 c0	 xor	 r8d, r8d
  00206	33 c9		 xor	 ecx, ecx
  00208	41 89 45 1c	 mov	 DWORD PTR [r13+28], eax
  0020c	33 d2		 xor	 edx, edx
  0020e	e8 00 00 00 00	 call	 adler32

; 705  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  00213	41 c1 ee 08	 shr	 r14d, 8

; 706  :             INITBITS();

  00217	41 8b df	 mov	 ebx, r15d
  0021a	41 f7 d6	 not	 r14d
  0021d	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  00221	41 83 e6 02	 and	 r14d, 2
  00225	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax
  0022a	41 81 ce 3d 3f
	00 00		 or	 r14d, 16189		; 00003f3dH
  00231	45 89 75 08	 mov	 DWORD PTR [r13+8], r14d
  00235	45 8b f7	 mov	 r14d, r15d

; 707  :             break;

  00238	e9 3a 05 00 00	 jmp	 $LN975@inflate
$LN346@inflate:

; 697  :                 strm->msg = (char *)"invalid window size";

  0023d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@EMOGCLGO@invalid?5window?5size@
  00244	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 698  :                 state->mode = BAD;

  00249	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 699  :                 break;

  00251	e9 2b 05 00 00	 jmp	 $LN8@inflate
$LN342@inflate:

; 679  : #else
; 680  :             if (
; 681  : #endif
; 682  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {
; 683  :                 strm->msg = (char *)"incorrect header check";

  00256	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@LIBMMIGA@incorrect?5header?5check@
  0025d	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 684  :                 state->mode = BAD;

  00262	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 685  :                 break;

  0026a	e9 12 05 00 00	 jmp	 $LN8@inflate
$LN32@inflate:

; 708  : #ifdef GUNZIP
; 709  :         case FLAGS:
; 710  :             NEEDBITS(16);

  0026f	83 fb 10	 cmp	 ebx, 16
  00272	73 20		 jae	 SHORT $LN30@inflate
$LL33@inflate:
  00274	85 f6		 test	 esi, esi
  00276	0f 84 9b 06 00
	00		 je	 $LN938@inflate
  0027c	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  00280	8b cb		 mov	 ecx, ebx
  00282	d3 e0		 shl	 eax, cl
  00284	ff ce		 dec	 esi
  00286	44 03 f0	 add	 r14d, eax
  00289	48 ff c5	 inc	 rbp
  0028c	83 c3 08	 add	 ebx, 8
  0028f	83 fb 10	 cmp	 ebx, 16
  00292	72 e0		 jb	 SHORT $LL33@inflate
$LN30@inflate:

; 711  :             state->flags = (int)(hold);

  00294	45 89 75 18	 mov	 DWORD PTR [r13+24], r14d

; 712  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  00298	41 80 fe 08	 cmp	 r14b, 8
  0029c	74 19		 je	 SHORT $LN349@inflate

; 713  :                 strm->msg = (char *)"unknown compression method";

  0029e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
  002a5	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 714  :                 state->mode = BAD;

  002aa	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 715  :                 break;

  002b2	e9 ca 04 00 00	 jmp	 $LN8@inflate
$LN349@inflate:

; 716  :             }
; 717  :             if (state->flags & 0xe000) {

  002b7	41 f7 c6 00 e0
	00 00		 test	 r14d, 57344		; 0000e000H
  002be	74 19		 je	 SHORT $LN350@inflate

; 718  :                 strm->msg = (char *)"unknown header flags set";

  002c0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@
  002c7	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 719  :                 state->mode = BAD;

  002cc	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 720  :                 break;

  002d4	e9 a8 04 00 00	 jmp	 $LN8@inflate
$LN350@inflate:

; 721  :             }
; 722  :             if (state->head != Z_NULL)

  002d9	49 8b 55 28	 mov	 rdx, QWORD PTR [r13+40]
  002dd	41 8b ce	 mov	 ecx, r14d
  002e0	c1 e9 08	 shr	 ecx, 8
  002e3	48 85 d2	 test	 rdx, rdx
  002e6	74 07		 je	 SHORT $LN654@inflate

; 723  :                 state->head->text = (int)((hold >> 8) & 1);

  002e8	8b c1		 mov	 eax, ecx
  002ea	83 e0 01	 and	 eax, 1
  002ed	89 02		 mov	 DWORD PTR [rdx], eax
$LN654@inflate:

; 724  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  002ef	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  002f7	74 28		 je	 SHORT $LN39@inflate
  002f9	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  002fe	74 21		 je	 SHORT $LN39@inflate

; 725  :                 CRC2(state->check, hold);

  00300	88 4c 24 35	 mov	 BYTE PTR hbuf$[rsp+1], cl
  00304	48 8d 54 24 34	 lea	 rdx, QWORD PTR hbuf$[rsp]
  00309	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  0030d	41 b8 02 00 00
	00		 mov	 r8d, 2
  00313	44 88 74 24 34	 mov	 BYTE PTR hbuf$[rsp], r14b
  00318	e8 00 00 00 00	 call	 crc32
  0031d	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN39@inflate:

; 726  :             INITBITS();

  00321	45 8b f7	 mov	 r14d, r15d

; 727  :             state->mode = TIME;

  00324	41 c7 45 08 36
	3f 00 00	 mov	 DWORD PTR [r13+8], 16182 ; 00003f36H
  0032c	41 8b df	 mov	 ebx, r15d

; 728  :                 /* fallthrough */
; 729  :         case TIME:
; 730  :             NEEDBITS(32);

  0032f	eb 05		 jmp	 SHORT $LL47@inflate
$LN46@inflate:
  00331	83 fb 20	 cmp	 ebx, 32			; 00000020H
  00334	73 20		 jae	 SHORT $LN44@inflate
$LL47@inflate:
  00336	85 f6		 test	 esi, esi
  00338	0f 84 d9 05 00
	00		 je	 $LN938@inflate
  0033e	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  00342	8b cb		 mov	 ecx, ebx
  00344	d3 e0		 shl	 eax, cl
  00346	ff ce		 dec	 esi
  00348	44 03 f0	 add	 r14d, eax
  0034b	48 ff c5	 inc	 rbp
  0034e	83 c3 08	 add	 ebx, 8
  00351	83 fb 20	 cmp	 ebx, 32			; 00000020H
  00354	72 e0		 jb	 SHORT $LL47@inflate
$LN44@inflate:

; 731  :             if (state->head != Z_NULL)

  00356	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  0035a	48 85 c0	 test	 rax, rax
  0035d	74 04		 je	 SHORT $LN355@inflate

; 732  :                 state->head->time = hold;

  0035f	44 89 70 04	 mov	 DWORD PTR [rax+4], r14d
$LN355@inflate:

; 733  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  00363	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  0036b	74 41		 je	 SHORT $LN53@inflate
  0036d	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  00372	74 3a		 je	 SHORT $LN53@inflate

; 734  :                 CRC4(state->check, hold);

  00374	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  00378	48 8d 54 24 34	 lea	 rdx, QWORD PTR hbuf$[rsp]
  0037d	41 8b c6	 mov	 eax, r14d
  00380	44 88 74 24 34	 mov	 BYTE PTR hbuf$[rsp], r14b
  00385	c1 e8 08	 shr	 eax, 8
  00388	41 b8 04 00 00
	00		 mov	 r8d, 4
  0038e	88 44 24 35	 mov	 BYTE PTR hbuf$[rsp+1], al
  00392	41 8b c6	 mov	 eax, r14d
  00395	c1 e8 10	 shr	 eax, 16
  00398	41 c1 ee 18	 shr	 r14d, 24
  0039c	88 44 24 36	 mov	 BYTE PTR hbuf$[rsp+2], al
  003a0	44 88 74 24 37	 mov	 BYTE PTR hbuf$[rsp+3], r14b
  003a5	e8 00 00 00 00	 call	 crc32
  003aa	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN53@inflate:

; 735  :             INITBITS();

  003ae	45 8b f7	 mov	 r14d, r15d

; 736  :             state->mode = OS;

  003b1	41 c7 45 08 37
	3f 00 00	 mov	 DWORD PTR [r13+8], 16183 ; 00003f37H
  003b9	41 8b df	 mov	 ebx, r15d

; 737  :                 /* fallthrough */
; 738  :         case OS:
; 739  :             NEEDBITS(16);

  003bc	eb 05		 jmp	 SHORT $LL61@inflate
$LN60@inflate:
  003be	83 fb 10	 cmp	 ebx, 16
  003c1	73 20		 jae	 SHORT $LN58@inflate
$LL61@inflate:
  003c3	85 f6		 test	 esi, esi
  003c5	0f 84 4c 05 00
	00		 je	 $LN938@inflate
  003cb	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  003cf	8b cb		 mov	 ecx, ebx
  003d1	d3 e0		 shl	 eax, cl
  003d3	ff ce		 dec	 esi
  003d5	44 03 f0	 add	 r14d, eax
  003d8	48 ff c5	 inc	 rbp
  003db	83 c3 08	 add	 ebx, 8
  003de	83 fb 10	 cmp	 ebx, 16
  003e1	72 e0		 jb	 SHORT $LL61@inflate
$LN58@inflate:

; 740  :             if (state->head != Z_NULL) {

  003e3	49 8b 55 28	 mov	 rdx, QWORD PTR [r13+40]
  003e7	41 8b ce	 mov	 ecx, r14d
  003ea	c1 e9 08	 shr	 ecx, 8
  003ed	48 85 d2	 test	 rdx, rdx
  003f0	74 0e		 je	 SHORT $LN723@inflate

; 741  :                 state->head->xflags = (int)(hold & 0xff);

  003f2	41 0f b6 c6	 movzx	 eax, r14b
  003f6	89 42 08	 mov	 DWORD PTR [rdx+8], eax

; 742  :                 state->head->os = (int)(hold >> 8);

  003f9	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  003fd	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
$LN723@inflate:

; 743  :             }
; 744  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  00400	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  00408	74 28		 je	 SHORT $LN67@inflate
  0040a	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  0040f	74 21		 je	 SHORT $LN67@inflate

; 745  :                 CRC2(state->check, hold);

  00411	88 4c 24 35	 mov	 BYTE PTR hbuf$[rsp+1], cl
  00415	48 8d 54 24 34	 lea	 rdx, QWORD PTR hbuf$[rsp]
  0041a	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  0041e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00424	44 88 74 24 34	 mov	 BYTE PTR hbuf$[rsp], r14b
  00429	e8 00 00 00 00	 call	 crc32
  0042e	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN67@inflate:

; 746  :             INITBITS();

  00432	45 8b f7	 mov	 r14d, r15d

; 747  :             state->mode = EXLEN;

  00435	41 c7 45 08 38
	3f 00 00	 mov	 DWORD PTR [r13+8], 16184 ; 00003f38H
  0043d	41 8b df	 mov	 ebx, r15d
$LN361@inflate:

; 748  :                 /* fallthrough */
; 749  :         case EXLEN:
; 750  :             if (state->flags & 0x0400) {

  00440	41 f7 45 18 00
	04 00 00	 test	 DWORD PTR [r13+24], 1024 ; 00000400H
  00448	74 76		 je	 SHORT $LN362@inflate

; 751  :                 NEEDBITS(16);

  0044a	83 fb 10	 cmp	 ebx, 16
  0044d	73 21		 jae	 SHORT $LN72@inflate
  0044f	90		 npad	 1
$LL75@inflate:
  00450	85 f6		 test	 esi, esi
  00452	0f 84 bf 04 00
	00		 je	 $LN938@inflate
  00458	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  0045c	8b cb		 mov	 ecx, ebx
  0045e	d3 e0		 shl	 eax, cl
  00460	ff ce		 dec	 esi
  00462	44 03 f0	 add	 r14d, eax
  00465	48 ff c5	 inc	 rbp
  00468	83 c3 08	 add	 ebx, 8
  0046b	83 fb 10	 cmp	 ebx, 16
  0046e	72 e0		 jb	 SHORT $LL75@inflate
$LN72@inflate:

; 752  :                 state->length = (unsigned)(hold);
; 753  :                 if (state->head != Z_NULL)

  00470	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00474	45 89 75 50	 mov	 DWORD PTR [r13+80], r14d
  00478	48 85 c0	 test	 rax, rax
  0047b	74 04		 je	 SHORT $LN365@inflate

; 754  :                     state->head->extra_len = (unsigned)hold;

  0047d	44 89 70 18	 mov	 DWORD PTR [rax+24], r14d
$LN365@inflate:

; 755  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00481	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  00489	74 2d		 je	 SHORT $LN81@inflate
  0048b	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  00490	74 26		 je	 SHORT $LN81@inflate

; 756  :                     CRC2(state->check, hold);

  00492	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  00496	48 8d 54 24 34	 lea	 rdx, QWORD PTR hbuf$[rsp]
  0049b	44 88 74 24 34	 mov	 BYTE PTR hbuf$[rsp], r14b
  004a0	41 b8 02 00 00
	00		 mov	 r8d, 2
  004a6	41 c1 ee 08	 shr	 r14d, 8
  004aa	44 88 74 24 35	 mov	 BYTE PTR hbuf$[rsp+1], r14b
  004af	e8 00 00 00 00	 call	 crc32
  004b4	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN81@inflate:

; 757  :                 INITBITS();

  004b8	45 8b f7	 mov	 r14d, r15d
  004bb	41 8b df	 mov	 ebx, r15d

; 758  :             }

  004be	eb 0d		 jmp	 SHORT $LN367@inflate
$LN362@inflate:

; 759  :             else if (state->head != Z_NULL)

  004c0	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  004c4	48 85 c0	 test	 rax, rax
  004c7	74 04		 je	 SHORT $LN367@inflate

; 760  :                 state->head->extra = Z_NULL;

  004c9	4c 89 78 10	 mov	 QWORD PTR [rax+16], r15
$LN367@inflate:

; 761  :             state->mode = EXTRA;

  004cd	41 c7 45 08 39
	3f 00 00	 mov	 DWORD PTR [r13+8], 16185 ; 00003f39H
$LN368@inflate:

; 762  :                 /* fallthrough */
; 763  :         case EXTRA:
; 764  :             if (state->flags & 0x0400) {

  004d5	41 f7 45 18 00
	04 00 00	 test	 DWORD PTR [r13+24], 1024 ; 00000400H
  004dd	0f 84 9e 00 00
	00		 je	 $LN724@inflate

; 765  :                 copy = state->length;

  004e3	41 8b 45 50	 mov	 eax, DWORD PTR [r13+80]

; 766  :                 if (copy > have) copy = have;
; 767  :                 if (copy) {

  004e7	8b fe		 mov	 edi, esi
  004e9	3b c6		 cmp	 eax, esi
  004eb	0f 46 f8	 cmovbe	 edi, eax
  004ee	85 ff		 test	 edi, edi
  004f0	0f 84 83 00 00
	00		 je	 $LN725@inflate

; 768  :                     if (state->head != Z_NULL &&
; 769  :                         state->head->extra != Z_NULL &&

  004f6	49 8b 4d 28	 mov	 rcx, QWORD PTR [r13+40]
  004fa	44 8b f8	 mov	 r15d, eax
  004fd	48 85 c9	 test	 rcx, rcx
  00500	74 40		 je	 SHORT $LN372@inflate
  00502	4c 8b 51 10	 mov	 r10, QWORD PTR [rcx+16]
  00506	4d 85 d2	 test	 r10, r10
  00509	74 37		 je	 SHORT $LN372@inflate
  0050b	44 8b 49 18	 mov	 r9d, DWORD PTR [rcx+24]
  0050f	44 8b 41 1c	 mov	 r8d, DWORD PTR [rcx+28]
  00513	44 2b c8	 sub	 r9d, eax
  00516	45 3b c8	 cmp	 r9d, r8d
  00519	73 27		 jae	 SHORT $LN372@inflate

; 770  :                         (len = state->head->extra_len - state->length) <
; 771  :                             state->head->extra_max) {
; 772  :                         zmemcpy(state->head->extra + len, next,

  0051b	41 8b d0	 mov	 edx, r8d
  0051e	42 8d 0c 0f	 lea	 ecx, DWORD PTR [rdi+r9]
  00522	41 2b d1	 sub	 edx, r9d
  00525	8b c7		 mov	 eax, edi
  00527	41 3b c8	 cmp	 ecx, r8d
  0052a	41 8b c9	 mov	 ecx, r9d
  0052d	0f 47 c2	 cmova	 eax, edx
  00530	49 03 ca	 add	 rcx, r10
  00533	44 8b c0	 mov	 r8d, eax
  00536	48 8b d5	 mov	 rdx, rbp
  00539	e8 00 00 00 00	 call	 memcpy
  0053e	45 8b 7d 50	 mov	 r15d, DWORD PTR [r13+80]
$LN372@inflate:

; 773  :                                 len + copy > state->head->extra_max ?
; 774  :                                 state->head->extra_max - len : copy);
; 775  :                     }
; 776  :                     if ((state->flags & 0x0200) && (state->wrap & 4))

  00542	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  0054a	74 1a		 je	 SHORT $LN373@inflate
  0054c	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  00551	74 13		 je	 SHORT $LN373@inflate

; 777  :                         state->check = crc32(state->check, next, copy);

  00553	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  00557	44 8b c7	 mov	 r8d, edi
  0055a	48 8b d5	 mov	 rdx, rbp
  0055d	e8 00 00 00 00	 call	 crc32
  00562	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN373@inflate:

; 778  :                     have -= copy;
; 779  :                     next += copy;

  00566	8b c7		 mov	 eax, edi
  00568	2b f7		 sub	 esi, edi
  0056a	48 03 e8	 add	 rbp, rax

; 780  :                     state->length -= copy;

  0056d	41 8b c7	 mov	 eax, r15d
  00570	2b c7		 sub	 eax, edi
  00572	41 89 45 50	 mov	 DWORD PTR [r13+80], eax
  00576	45 33 ff	 xor	 r15d, r15d
$LN725@inflate:

; 781  :                 }
; 782  :                 if (state->length) goto inf_leave;

  00579	85 c0		 test	 eax, eax
  0057b	0f 85 96 03 00
	00		 jne	 $LN938@inflate
$LN724@inflate:

; 783  :             }
; 784  :             state->length = 0;

  00581	45 89 7d 50	 mov	 DWORD PTR [r13+80], r15d

; 785  :             state->mode = NAME;

  00585	41 c7 45 08 3a
	3f 00 00	 mov	 DWORD PTR [r13+8], 16186 ; 00003f3aH
$LN375@inflate:

; 786  :                 /* fallthrough */
; 787  :         case NAME:
; 788  :             if (state->flags & 0x0800) {

  0058d	41 f7 45 18 00
	08 00 00	 test	 DWORD PTR [r13+24], 2048 ; 00000800H
  00595	0f 84 83 00 00
	00		 je	 $LN376@inflate

; 789  :                 if (have == 0) goto inf_leave;

  0059b	85 f6		 test	 esi, esi
  0059d	0f 84 74 03 00
	00		 je	 $LN938@inflate

; 790  :                 copy = 0;

  005a3	41 8b ff	 mov	 edi, r15d
  005a6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL88@inflate:

; 791  :                 do {
; 792  :                     len = (unsigned)(next[copy++]);

  005b0	8b c7		 mov	 eax, edi
  005b2	ff c7		 inc	 edi
  005b4	44 0f b6 3c 28	 movzx	 r15d, BYTE PTR [rax+rbp]

; 793  :                     if (state->head != Z_NULL &&
; 794  :                             state->head->name != Z_NULL &&

  005b9	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  005bd	48 85 c0	 test	 rax, rax
  005c0	74 1a		 je	 SHORT $LN86@inflate
  005c2	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  005c6	48 85 d2	 test	 rdx, rdx
  005c9	74 11		 je	 SHORT $LN86@inflate
  005cb	41 8b 4d 50	 mov	 ecx, DWORD PTR [r13+80]
  005cf	3b 48 28	 cmp	 ecx, DWORD PTR [rax+40]
  005d2	73 08		 jae	 SHORT $LN86@inflate

; 795  :                             state->length < state->head->name_max)
; 796  :                         state->head->name[state->length++] = (Bytef)len;

  005d4	44 88 3c 11	 mov	 BYTE PTR [rcx+rdx], r15b
  005d8	41 ff 45 50	 inc	 DWORD PTR [r13+80]
$LN86@inflate:

; 797  :                 } while (len && copy < have);

  005dc	45 84 ff	 test	 r15b, r15b
  005df	74 04		 je	 SHORT $LN380@inflate
  005e1	3b fe		 cmp	 edi, esi
  005e3	72 cb		 jb	 SHORT $LL88@inflate
$LN380@inflate:

; 798  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  005e5	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  005ed	74 1a		 je	 SHORT $LN381@inflate
  005ef	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  005f4	74 13		 je	 SHORT $LN381@inflate

; 799  :                     state->check = crc32(state->check, next, copy);

  005f6	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  005fa	44 8b c7	 mov	 r8d, edi
  005fd	48 8b d5	 mov	 rdx, rbp
  00600	e8 00 00 00 00	 call	 crc32
  00605	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN381@inflate:

; 800  :                 have -= copy;
; 801  :                 next += copy;

  00609	8b c7		 mov	 eax, edi
  0060b	2b f7		 sub	 esi, edi
  0060d	48 03 e8	 add	 rbp, rax

; 802  :                 if (len) goto inf_leave;

  00610	45 84 ff	 test	 r15b, r15b
  00613	0f 85 fe 02 00
	00		 jne	 $LN938@inflate

; 803  :             }

  00619	45 33 ff	 xor	 r15d, r15d
  0061c	eb 0d		 jmp	 SHORT $LN383@inflate
$LN376@inflate:

; 804  :             else if (state->head != Z_NULL)

  0061e	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00622	48 85 c0	 test	 rax, rax
  00625	74 04		 je	 SHORT $LN383@inflate

; 805  :                 state->head->name = Z_NULL;

  00627	4c 89 78 20	 mov	 QWORD PTR [rax+32], r15
$LN383@inflate:

; 806  :             state->length = 0;

  0062b	45 89 7d 50	 mov	 DWORD PTR [r13+80], r15d

; 807  :             state->mode = COMMENT;

  0062f	41 c7 45 08 3b
	3f 00 00	 mov	 DWORD PTR [r13+8], 16187 ; 00003f3bH
$LN384@inflate:

; 808  :                 /* fallthrough */
; 809  :         case COMMENT:
; 810  :             if (state->flags & 0x1000) {

  00637	41 f7 45 18 00
	10 00 00	 test	 DWORD PTR [r13+24], 4096 ; 00001000H
  0063f	74 7d		 je	 SHORT $LN385@inflate

; 811  :                 if (have == 0) goto inf_leave;

  00641	85 f6		 test	 esi, esi
  00643	0f 84 ce 02 00
	00		 je	 $LN938@inflate

; 812  :                 copy = 0;

  00649	41 8b ff	 mov	 edi, r15d
  0064c	0f 1f 40 00	 npad	 4
$LL91@inflate:

; 813  :                 do {
; 814  :                     len = (unsigned)(next[copy++]);

  00650	8b c7		 mov	 eax, edi
  00652	ff c7		 inc	 edi
  00654	44 0f b6 3c 28	 movzx	 r15d, BYTE PTR [rax+rbp]

; 815  :                     if (state->head != Z_NULL &&
; 816  :                             state->head->comment != Z_NULL &&

  00659	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  0065d	48 85 c0	 test	 rax, rax
  00660	74 1a		 je	 SHORT $LN89@inflate
  00662	48 8b 50 30	 mov	 rdx, QWORD PTR [rax+48]
  00666	48 85 d2	 test	 rdx, rdx
  00669	74 11		 je	 SHORT $LN89@inflate
  0066b	41 8b 4d 50	 mov	 ecx, DWORD PTR [r13+80]
  0066f	3b 48 38	 cmp	 ecx, DWORD PTR [rax+56]
  00672	73 08		 jae	 SHORT $LN89@inflate

; 817  :                             state->length < state->head->comm_max)
; 818  :                         state->head->comment[state->length++] = (Bytef)len;

  00674	44 88 3c 11	 mov	 BYTE PTR [rcx+rdx], r15b
  00678	41 ff 45 50	 inc	 DWORD PTR [r13+80]
$LN89@inflate:

; 819  :                 } while (len && copy < have);

  0067c	45 84 ff	 test	 r15b, r15b
  0067f	74 04		 je	 SHORT $LN389@inflate
  00681	3b fe		 cmp	 edi, esi
  00683	72 cb		 jb	 SHORT $LL91@inflate
$LN389@inflate:

; 820  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00685	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  0068d	74 1a		 je	 SHORT $LN390@inflate
  0068f	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  00694	74 13		 je	 SHORT $LN390@inflate

; 821  :                     state->check = crc32(state->check, next, copy);

  00696	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  0069a	44 8b c7	 mov	 r8d, edi
  0069d	48 8b d5	 mov	 rdx, rbp
  006a0	e8 00 00 00 00	 call	 crc32
  006a5	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN390@inflate:

; 822  :                 have -= copy;
; 823  :                 next += copy;

  006a9	8b c7		 mov	 eax, edi
  006ab	2b f7		 sub	 esi, edi
  006ad	48 03 e8	 add	 rbp, rax

; 824  :                 if (len) goto inf_leave;

  006b0	45 84 ff	 test	 r15b, r15b
  006b3	0f 85 5e 02 00
	00		 jne	 $LN938@inflate

; 825  :             }

  006b9	45 33 ff	 xor	 r15d, r15d
  006bc	eb 0d		 jmp	 SHORT $LN392@inflate
$LN385@inflate:

; 826  :             else if (state->head != Z_NULL)

  006be	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  006c2	48 85 c0	 test	 rax, rax
  006c5	74 04		 je	 SHORT $LN392@inflate

; 827  :                 state->head->comment = Z_NULL;

  006c7	4c 89 78 30	 mov	 QWORD PTR [rax+48], r15
$LN392@inflate:
  006cb	4c 8b 54 24 40	 mov	 r10, QWORD PTR put$1$[rsp]
  006d0	44 8b 5c 24 30	 mov	 r11d, DWORD PTR left$1$[rsp]

; 828  :             state->mode = HCRC;

  006d5	41 c7 45 08 3c
	3f 00 00	 mov	 DWORD PTR [r13+8], 16188 ; 00003f3cH
$LN393@inflate:

; 829  :                 /* fallthrough */
; 830  :         case HCRC:
; 831  :             if (state->flags & 0x0200) {

  006dd	41 8b 55 18	 mov	 edx, DWORD PTR [r13+24]
  006e1	0f ba e2 09	 bt	 edx, 9
  006e5	73 56		 jae	 SHORT $LN101@inflate

; 832  :                 NEEDBITS(16);

  006e7	83 fb 10	 cmp	 ebx, 16
  006ea	73 24		 jae	 SHORT $LN92@inflate
  006ec	0f 1f 40 00	 npad	 4
$LL95@inflate:
  006f0	85 f6		 test	 esi, esi
  006f2	0f 84 1f 02 00
	00		 je	 $LN938@inflate
  006f8	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  006fc	8b cb		 mov	 ecx, ebx
  006fe	d3 e0		 shl	 eax, cl
  00700	ff ce		 dec	 esi
  00702	44 03 f0	 add	 r14d, eax
  00705	48 ff c5	 inc	 rbp
  00708	83 c3 08	 add	 ebx, 8
  0070b	83 fb 10	 cmp	 ebx, 16
  0070e	72 e0		 jb	 SHORT $LL95@inflate
$LN92@inflate:

; 833  :                 if ((state->wrap & 4) && hold != (state->check & 0xffff)) {

  00710	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  00715	74 20		 je	 SHORT $LN102@inflate
  00717	41 0f b7 45 20	 movzx	 eax, WORD PTR [r13+32]
  0071c	44 3b f0	 cmp	 r14d, eax
  0071f	74 16		 je	 SHORT $LN102@inflate

; 834  :                     strm->msg = (char *)"header crc mismatch";

  00721	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@GONKLEPM@header?5crc?5mismatch@
  00728	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 835  :                     state->mode = BAD;

  0072d	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 836  :                     break;

  00735	eb 4a		 jmp	 SHORT $LN8@inflate
$LN102@inflate:

; 837  :                 }
; 838  :                 INITBITS();

  00737	45 8b f7	 mov	 r14d, r15d
  0073a	41 8b df	 mov	 ebx, r15d
$LN101@inflate:

; 839  :             }
; 840  :             if (state->head != Z_NULL) {

  0073d	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00741	48 85 c0	 test	 rax, rax
  00744	74 14		 je	 SHORT $LN397@inflate

; 841  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  00746	c1 fa 09	 sar	 edx, 9
  00749	83 e2 01	 and	 edx, 1
  0074c	89 50 3c	 mov	 DWORD PTR [rax+60], edx

; 842  :                 state->head->done = 1;

  0074f	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00753	c7 40 40 01 00
	00 00		 mov	 DWORD PTR [rax+64], 1
$LN397@inflate:

; 843  :             }
; 844  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  0075a	45 33 c0	 xor	 r8d, r8d
  0075d	33 d2		 xor	 edx, edx
  0075f	33 c9		 xor	 ecx, ecx
  00761	e8 00 00 00 00	 call	 crc32
  00766	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  0076a	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax
$LN978@inflate:

; 658  :     for (;;)
; 659  :         switch (state->mode) {

  0076f	41 c7 45 08 3f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16191 ; 00003f3fH
$LN975@inflate:
  00777	44 8b 5c 24 30	 mov	 r11d, DWORD PTR left$1$[rsp]
$LN905@inflate:
  0077c	4c 8b 54 24 40	 mov	 r10, QWORD PTR put$1$[rsp]
$LN8@inflate:
  00781	41 8b 45 08	 mov	 eax, DWORD PTR [r13+8]
  00785	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  0078a	83 f8 1f	 cmp	 eax, 31
  0078d	0f 87 e9 0f 00
	00		 ja	 $LN333@inflate
  00793	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR out$1$[rsp]
  0079b	45 33 ff	 xor	 r15d, r15d
  0079e	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR flush$[rsp]
  007a5	e9 fc f8 ff ff	 jmp	 $LN976@inflate
$LN105@inflate:

; 845  :             state->mode = TYPE;
; 846  :             break;
; 847  : #endif
; 848  :         case DICTID:
; 849  :             NEEDBITS(32);

  007aa	83 fb 20	 cmp	 ebx, 32			; 00000020H
  007ad	73 21		 jae	 SHORT $LN103@inflate
  007af	90		 npad	 1
$LL106@inflate:
  007b0	85 f6		 test	 esi, esi
  007b2	0f 84 5f 01 00
	00		 je	 $LN938@inflate
  007b8	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  007bc	8b cb		 mov	 ecx, ebx
  007be	d3 e0		 shl	 eax, cl
  007c0	ff ce		 dec	 esi
  007c2	44 03 f0	 add	 r14d, eax
  007c5	48 ff c5	 inc	 rbp
  007c8	83 c3 08	 add	 ebx, 8
  007cb	83 fb 20	 cmp	 ebx, 32			; 00000020H
  007ce	72 e0		 jb	 SHORT $LL106@inflate
$LN103@inflate:

; 850  :             strm->adler = state->check = ZSWAP32(hold);

  007d0	41 8b ce	 mov	 ecx, r14d
  007d3	41 8b c6	 mov	 eax, r14d
  007d6	c1 e0 10	 shl	 eax, 16
  007d9	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  007df	03 c8		 add	 ecx, eax

; 851  :             INITBITS();

  007e1	41 8b df	 mov	 ebx, r15d
  007e4	41 8b c6	 mov	 eax, r14d
  007e7	c1 e1 08	 shl	 ecx, 8
  007ea	c1 e8 08	 shr	 eax, 8
  007ed	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  007f2	41 c1 ee 18	 shr	 r14d, 24
  007f6	03 c1		 add	 eax, ecx
  007f8	41 03 c6	 add	 eax, r14d
  007fb	45 8b f7	 mov	 r14d, r15d
  007fe	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  00802	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax

; 852  :             state->mode = DICT;

  00807	41 c7 45 08 3e
	3f 00 00	 mov	 DWORD PTR [r13+8], 16190 ; 00003f3eH
$LN400@inflate:

; 853  :                 /* fallthrough */
; 854  :         case DICT:
; 855  :             if (state->havedict == 0) {

  0080f	41 83 7d 14 00	 cmp	 DWORD PTR [r13+20], 0
  00814	0f 84 22 0e 00
	00		 je	 $LN587@inflate

; 858  :             }
; 859  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  0081a	45 33 c0	 xor	 r8d, r8d
  0081d	33 d2		 xor	 edx, edx
  0081f	33 c9		 xor	 ecx, ecx
  00821	e8 00 00 00 00	 call	 adler32
  00826	4c 8b 54 24 40	 mov	 r10, QWORD PTR put$1$[rsp]
  0082b	44 8b 5c 24 30	 mov	 r11d, DWORD PTR left$1$[rsp]
  00830	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR flush$[rsp]
  00837	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  0083b	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax

; 860  :             state->mode = TYPE;

  00840	41 c7 45 08 3f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16191 ; 00003f3fH
$LN402@inflate:

; 861  :                 /* fallthrough */
; 862  :         case TYPE:
; 863  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  00848	8d 42 fb	 lea	 eax, DWORD PTR [rdx-5]
  0084b	83 f8 01	 cmp	 eax, 1
  0084e	0f 86 c3 00 00
	00		 jbe	 $LN938@inflate
$LN403@inflate:

; 864  :                 /* fallthrough */
; 865  :         case TYPEDO:
; 866  :             if (state->last) {

  00854	41 83 7d 0c 00	 cmp	 DWORD PTR [r13+12], 0
  00859	74 17		 je	 SHORT $LN122@inflate

; 867  :                 BYTEBITS();

  0085b	8b cb		 mov	 ecx, ebx

; 868  :                 state->mode = CHECK;

  0085d	41 c7 45 08 4e
	3f 00 00	 mov	 DWORD PTR [r13+8], 16206 ; 00003f4eH
  00865	83 e1 07	 and	 ecx, 7
  00868	41 d3 ee	 shr	 r14d, cl
  0086b	2b d9		 sub	 ebx, ecx

; 869  :                 break;

  0086d	e9 0f ff ff ff	 jmp	 $LN8@inflate
$LN122@inflate:

; 870  :             }
; 871  :             NEEDBITS(3);

  00872	83 fb 03	 cmp	 ebx, 3
  00875	73 20		 jae	 SHORT $LN120@inflate
$LL123@inflate:
  00877	85 f6		 test	 esi, esi
  00879	0f 84 98 00 00
	00		 je	 $LN938@inflate
  0087f	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  00883	8b cb		 mov	 ecx, ebx
  00885	d3 e0		 shl	 eax, cl
  00887	ff ce		 dec	 esi
  00889	44 03 f0	 add	 r14d, eax
  0088c	48 ff c5	 inc	 rbp
  0088f	83 c3 08	 add	 ebx, 8
  00892	83 fb 03	 cmp	 ebx, 3
  00895	72 e0		 jb	 SHORT $LL123@inflate
$LN120@inflate:

; 872  :             state->last = BITS(1);

  00897	41 8b c6	 mov	 eax, r14d

; 873  :             DROPBITS(1);

  0089a	41 d1 ee	 shr	 r14d, 1
  0089d	83 e0 01	 and	 eax, 1
  008a0	41 89 45 0c	 mov	 DWORD PTR [r13+12], eax

; 874  :             switch (BITS(2)) {

  008a4	41 8b c6	 mov	 eax, r14d
  008a7	83 e0 03	 and	 eax, 3
  008aa	0f 84 01 01 00
	00		 je	 $LN408@inflate
  008b0	83 e8 01	 sub	 eax, 1
  008b3	74 42		 je	 SHORT $LN409@inflate
  008b5	83 e8 01	 sub	 eax, 1
  008b8	74 29		 je	 SHORT $LN411@inflate
  008ba	83 f8 01	 cmp	 eax, 1
  008bd	0f 85 f6 00 00
	00		 jne	 $LN138@inflate

; 887  :                     goto inf_leave;
; 888  :                 }
; 889  :                 break;
; 890  :             case 2:                             /* dynamic block */
; 891  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 892  :                         state->last ? " (last)" : ""));
; 893  :                 state->mode = TABLE;
; 894  :                 break;
; 895  :             case 3:
; 896  :                 strm->msg = (char *)"invalid block type";

  008c3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type@

; 897  :                 state->mode = BAD;
; 898  :             }
; 899  :             DROPBITS(2);

  008ca	41 c1 ee 02	 shr	 r14d, 2
  008ce	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax
  008d3	83 c3 fd	 add	 ebx, -3			; fffffffdH
  008d6	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 900  :             break;

  008de	e9 9e fe ff ff	 jmp	 $LN8@inflate
$LN411@inflate:

; 897  :                 state->mode = BAD;
; 898  :             }
; 899  :             DROPBITS(2);

  008e3	41 c1 ee 02	 shr	 r14d, 2
  008e7	83 c3 fd	 add	 ebx, -3			; fffffffdH
  008ea	41 c7 45 08 44
	3f 00 00	 mov	 DWORD PTR [r13+8], 16196 ; 00003f44H

; 900  :             break;

  008f2	e9 8a fe ff ff	 jmp	 $LN8@inflate
$LN409@inflate:

; 879  :                 break;
; 880  :             case 1:                             /* fixed block */
; 881  :                 fixedtables(state);

  008f7	49 8b cd	 mov	 rcx, r13
  008fa	e8 00 00 00 00	 call	 fixedtables

; 882  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 883  :                         state->last ? " (last)" : ""));
; 884  :                 state->mode = LEN_;             /* decode codes */

  008ff	41 c7 45 08 47
	3f 00 00	 mov	 DWORD PTR [r13+8], 16199 ; 00003f47H

; 885  :                 if (flush == Z_TREES) {

  00907	83 fa 06	 cmp	 edx, 6
  0090a	0f 85 a9 00 00
	00		 jne	 $LN138@inflate

; 886  :                     DROPBITS(2);

  00910	41 c1 ee 02	 shr	 r14d, 2
  00914	83 c3 fd	 add	 ebx, -3			; fffffffdH
$LN938@inflate:

; 1265 :             goto inf_leave;
; 1266 :         case MEM:
; 1267 :             return Z_MEM_ERROR;
; 1268 :         case SYNC:
; 1269 :                 /* fallthrough */
; 1270 :         default:
; 1271 :             return Z_STREAM_ERROR;
; 1272 :         }
; 1273 : 
; 1274 :     /*
; 1275 :        Return from inflate(), updating the total counts and the check value.
; 1276 :        If there was no progress during the inflate() call, return a buffer
; 1277 :        error.  Call updatewindow() to create and/or update the window state.
; 1278 :        Note: a memory error from inflate() is non-recoverable.
; 1279 :      */
; 1280 :   inf_leave:
; 1281 :     RESTORE();

  00917	8b bc 24 a0 00
	00 00		 mov	 edi, DWORD PTR out$1$[rsp]
$LN942@inflate:
  0091e	44 8b bc 24 a8
	00 00 00	 mov	 r15d, DWORD PTR ret$1$[rsp]
$LN977@inflate:
  00926	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR flush$[rsp]
$inf_leave$981:
  0092d	48 8b 44 24 40	 mov	 rax, QWORD PTR put$1$[rsp]
  00932	49 89 44 24 10	 mov	 QWORD PTR [r12+16], rax
  00937	8b 44 24 30	 mov	 eax, DWORD PTR left$1$[rsp]
  0093b	41 89 44 24 18	 mov	 DWORD PTR [r12+24], eax
  00940	49 89 2c 24	 mov	 QWORD PTR [r12], rbp
  00944	41 89 74 24 08	 mov	 DWORD PTR [r12+8], esi

; 1282 :     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&

  00949	41 83 7d 34 00	 cmp	 DWORD PTR [r13+52], 0
  0094e	45 89 75 48	 mov	 DWORD PTR [r13+72], r14d
  00952	41 89 5d 4c	 mov	 DWORD PTR [r13+76], ebx
  00956	75 2a		 jne	 SHORT $LN503@inflate
  00958	41 3b 7c 24 18	 cmp	 edi, DWORD PTR [r12+24]
  0095d	0f 84 47 0d 00
	00		 je	 $LN504@inflate
  00963	41 8b 45 08	 mov	 eax, DWORD PTR [r13+8]
  00967	3d 51 3f 00 00	 cmp	 eax, 16209		; 00003f51H
  0096c	0f 8d 38 0d 00
	00		 jge	 $LN504@inflate
  00972	3d 4e 3f 00 00	 cmp	 eax, 16206		; 00003f4eH
  00977	7c 09		 jl	 SHORT $LN503@inflate
  00979	83 f9 04	 cmp	 ecx, 4
  0097c	0f 84 28 0d 00
	00		 je	 $LN504@inflate
$LN503@inflate:

; 1283 :             (state->mode < CHECK || flush != Z_FINISH)))
; 1284 :         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {

  00982	49 8b 54 24 10	 mov	 rdx, QWORD PTR [r12+16]
  00987	44 8b c7	 mov	 r8d, edi
  0098a	45 2b 44 24 18	 sub	 r8d, DWORD PTR [r12+24]
  0098f	49 8b cc	 mov	 rcx, r12
  00992	e8 00 00 00 00	 call	 updatewindow
  00997	85 c0		 test	 eax, eax
  00999	0f 84 0b 0d 00
	00		 je	 $LN504@inflate

; 1285 :             state->mode = MEM;

  0099f	41 c7 45 08 52
	3f 00 00	 mov	 DWORD PTR [r13+8], 16210 ; 00003f52H
$LN498@inflate:

; 1302 : }

  009a7	b8 fc ff ff ff	 mov	 eax, -4
  009ac	e9 d0 0d 00 00	 jmp	 $LN1@inflate
$LN408@inflate:

; 875  :             case 0:                             /* stored block */
; 876  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 877  :                         state->last ? " (last)" : ""));
; 878  :                 state->mode = STORED;

  009b1	41 c7 45 08 41
	3f 00 00	 mov	 DWORD PTR [r13+8], 16193 ; 00003f41H
$LN138@inflate:

; 897  :                 state->mode = BAD;
; 898  :             }
; 899  :             DROPBITS(2);

  009b9	41 c1 ee 02	 shr	 r14d, 2
  009bd	83 c3 fd	 add	 ebx, -3			; fffffffdH

; 900  :             break;

  009c0	e9 bc fd ff ff	 jmp	 $LN8@inflate
$LN141@inflate:

; 901  :         case STORED:
; 902  :             BYTEBITS();                         /* go to byte boundary */

  009c5	8b cb		 mov	 ecx, ebx
  009c7	83 e1 07	 and	 ecx, 7
  009ca	41 d3 ee	 shr	 r14d, cl
  009cd	2b d9		 sub	 ebx, ecx

; 903  :             NEEDBITS(32);

  009cf	83 fb 20	 cmp	 ebx, 32			; 00000020H
  009d2	73 20		 jae	 SHORT $LN142@inflate
$LL145@inflate:
  009d4	85 f6		 test	 esi, esi
  009d6	0f 84 3b ff ff
	ff		 je	 $LN938@inflate
  009dc	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  009e0	8b cb		 mov	 ecx, ebx
  009e2	d3 e0		 shl	 eax, cl
  009e4	ff ce		 dec	 esi
  009e6	44 03 f0	 add	 r14d, eax
  009e9	48 ff c5	 inc	 rbp
  009ec	83 c3 08	 add	 ebx, 8
  009ef	83 fb 20	 cmp	 ebx, 32			; 00000020H
  009f2	72 e0		 jb	 SHORT $LL145@inflate
$LN142@inflate:

; 904  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  009f4	41 8b c6	 mov	 eax, r14d
  009f7	41 0f b7 ce	 movzx	 ecx, r14w
  009fb	f7 d0		 not	 eax
  009fd	c1 e8 10	 shr	 eax, 16
  00a00	3b c8		 cmp	 ecx, eax
  00a02	74 19		 je	 SHORT $LN415@inflate

; 905  :                 strm->msg = (char *)"invalid stored block lengths";

  00a04	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@
  00a0b	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 906  :                 state->mode = BAD;

  00a10	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 907  :                 break;

  00a18	e9 64 fd ff ff	 jmp	 $LN8@inflate
$LN415@inflate:

; 908  :             }
; 909  :             state->length = (unsigned)hold & 0xffff;

  00a1d	41 89 4d 50	 mov	 DWORD PTR [r13+80], ecx

; 910  :             Tracev((stderr, "inflate:       stored length %u\n",
; 911  :                     state->length));
; 912  :             INITBITS();

  00a21	45 8b f7	 mov	 r14d, r15d

; 913  :             state->mode = COPY_;

  00a24	41 c7 45 08 42
	3f 00 00	 mov	 DWORD PTR [r13+8], 16194 ; 00003f42H
  00a2c	41 8b df	 mov	 ebx, r15d

; 914  :             if (flush == Z_TREES) goto inf_leave;

  00a2f	83 fa 06	 cmp	 edx, 6
  00a32	0f 84 df fe ff
	ff		 je	 $LN938@inflate
$LN416@inflate:

; 915  :                 /* fallthrough */
; 916  :         case COPY_:
; 917  :             state->mode = COPY;

  00a38	41 c7 45 08 43
	3f 00 00	 mov	 DWORD PTR [r13+8], 16195 ; 00003f43H
$LN418@inflate:

; 918  :                 /* fallthrough */
; 919  :         case COPY:
; 920  :             copy = state->length;

  00a40	41 8b 4d 50	 mov	 ecx, DWORD PTR [r13+80]

; 921  :             if (copy) {

  00a44	85 c9		 test	 ecx, ecx
  00a46	74 54		 je	 SHORT $LN419@inflate

; 922  :                 if (copy > have) copy = have;
; 923  :                 if (copy > left) copy = left;

  00a48	3b ce		 cmp	 ecx, esi
  00a4a	8b c6		 mov	 eax, esi

; 924  :                 if (copy == 0) goto inf_leave;

  00a4c	45 8b fb	 mov	 r15d, r11d
  00a4f	0f 46 c1	 cmovbe	 eax, ecx
  00a52	41 3b c3	 cmp	 eax, r11d
  00a55	44 0f 46 f8	 cmovbe	 r15d, eax
  00a59	45 85 ff	 test	 r15d, r15d
  00a5c	0f 84 b5 fe ff
	ff		 je	 $LN938@inflate

; 925  :                 zmemcpy(put, next, copy);

  00a62	45 8b c7	 mov	 r8d, r15d
  00a65	48 8b d5	 mov	 rdx, rbp
  00a68	49 8b ca	 mov	 rcx, r10
  00a6b	41 8b ff	 mov	 edi, r15d
  00a6e	e8 00 00 00 00	 call	 memcpy

; 926  :                 have -= copy;
; 927  :                 next += copy;
; 928  :                 left -= copy;

  00a73	44 8b 5c 24 30	 mov	 r11d, DWORD PTR left$1$[rsp]
  00a78	41 2b f7	 sub	 esi, r15d

; 929  :                 put += copy;

  00a7b	4c 8b 54 24 40	 mov	 r10, QWORD PTR put$1$[rsp]
  00a80	45 2b df	 sub	 r11d, r15d
  00a83	4c 03 d7	 add	 r10, rdi
  00a86	44 89 5c 24 30	 mov	 DWORD PTR left$1$[rsp], r11d
  00a8b	48 03 ef	 add	 rbp, rdi
  00a8e	4c 89 54 24 40	 mov	 QWORD PTR put$1$[rsp], r10

; 930  :                 state->length -= copy;

  00a93	45 29 7d 50	 sub	 DWORD PTR [r13+80], r15d

; 931  :                 break;

  00a97	e9 e5 fc ff ff	 jmp	 $LN8@inflate
$LN419@inflate:

; 932  :             }
; 933  :             Tracev((stderr, "inflate:       stored end\n"));
; 934  :             state->mode = TYPE;

  00a9c	41 c7 45 08 3f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16191 ; 00003f3fH

; 935  :             break;

  00aa4	e9 d8 fc ff ff	 jmp	 $LN8@inflate
$LN155@inflate:

; 936  :         case TABLE:
; 937  :             NEEDBITS(14);

  00aa9	83 fb 0e	 cmp	 ebx, 14
  00aac	73 22		 jae	 SHORT $LN153@inflate
  00aae	66 90		 npad	 2
$LL156@inflate:
  00ab0	85 f6		 test	 esi, esi
  00ab2	0f 84 5f fe ff
	ff		 je	 $LN938@inflate
  00ab8	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  00abc	8b cb		 mov	 ecx, ebx
  00abe	d3 e0		 shl	 eax, cl
  00ac0	ff ce		 dec	 esi
  00ac2	44 03 f0	 add	 r14d, eax
  00ac5	48 ff c5	 inc	 rbp
  00ac8	83 c3 08	 add	 ebx, 8
  00acb	83 fb 0e	 cmp	 ebx, 14
  00ace	72 e0		 jb	 SHORT $LL156@inflate
$LN153@inflate:

; 938  :             state->nlen = BITS(5) + 257;

  00ad0	41 8b ce	 mov	 ecx, r14d

; 939  :             DROPBITS(5);
; 940  :             state->ndist = BITS(5) + 1;
; 941  :             DROPBITS(5);
; 942  :             state->ncode = BITS(4) + 4;
; 943  :             DROPBITS(4);

  00ad3	83 c3 f2	 add	 ebx, -14		; fffffff2H
  00ad6	41 c1 ee 05	 shr	 r14d, 5
  00ada	83 e1 1f	 and	 ecx, 31
  00add	41 8b d6	 mov	 edx, r14d
  00ae0	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  00ae6	41 c1 ee 05	 shr	 r14d, 5
  00aea	83 e2 1f	 and	 edx, 31
  00aed	41 8b c6	 mov	 eax, r14d
  00af0	41 89 4d 7c	 mov	 DWORD PTR [r13+124], ecx
  00af4	83 e0 0f	 and	 eax, 15
  00af7	41 c1 ee 04	 shr	 r14d, 4
  00afb	83 c0 04	 add	 eax, 4
  00afe	ff c2		 inc	 edx
  00b00	41 89 95 80 00
	00 00		 mov	 DWORD PTR [r13+128], edx
  00b07	41 89 45 78	 mov	 DWORD PTR [r13+120], eax

; 944  : #ifndef PKZIP_BUG_WORKAROUND
; 945  :             if (state->nlen > 286 || state->ndist > 30) {

  00b0b	81 f9 1e 01 00
	00		 cmp	 ecx, 286		; 0000011eH
  00b11	0f 87 1e 01 00
	00		 ja	 $LN426@inflate
  00b17	83 fa 1e	 cmp	 edx, 30
  00b1a	0f 87 15 01 00
	00		 ja	 $LN426@inflate

; 949  :             }
; 950  : #endif
; 951  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 952  :             state->have = 0;

  00b20	45 89 bd 84 00
	00 00		 mov	 DWORD PTR [r13+132], r15d

; 953  :             state->mode = LENLENS;

  00b27	41 c7 45 08 45
	3f 00 00	 mov	 DWORD PTR [r13+8], 16197 ; 00003f45H
$LN533@inflate:

; 954  :                 /* fallthrough */
; 955  :         case LENLENS:
; 956  :             while (state->have < state->ncode) {

  00b2f	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00b36	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00b3d	41 3b 45 78	 cmp	 eax, DWORD PTR [r13+120]
  00b41	73 60		 jae	 SHORT $LN535@inflate
$LL170@inflate:

; 957  :                 NEEDBITS(3);

  00b43	83 fb 03	 cmp	 ebx, 3
  00b46	73 20		 jae	 SHORT $LN172@inflate
$LL175@inflate:
  00b48	85 f6		 test	 esi, esi
  00b4a	0f 84 c7 fd ff
	ff		 je	 $LN938@inflate
  00b50	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  00b54	8b cb		 mov	 ecx, ebx
  00b56	d3 e0		 shl	 eax, cl
  00b58	ff ce		 dec	 esi
  00b5a	44 03 f0	 add	 r14d, eax
  00b5d	48 ff c5	 inc	 rbp
  00b60	83 c3 08	 add	 ebx, 8
  00b63	83 fb 03	 cmp	 ebx, 3
  00b66	72 e0		 jb	 SHORT $LL175@inflate
$LN172@inflate:

; 958  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00b68	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00b6f	41 0f b7 ce	 movzx	 ecx, r14w
  00b73	66 83 e1 07	 and	 cx, 7

; 959  :                 DROPBITS(3);

  00b77	41 c1 ee 03	 shr	 r14d, 3
  00b7b	83 c3 fd	 add	 ebx, -3			; fffffffdH
  00b7e	0f b7 84 42 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[rdx+rax*2]
  00b86	66 41 89 8c 45
	90 00 00 00	 mov	 WORD PTR [r13+rax*2+144], cx
  00b8f	41 ff 85 84 00
	00 00		 inc	 DWORD PTR [r13+132]
  00b96	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00b9d	41 3b 45 78	 cmp	 eax, DWORD PTR [r13+120]
  00ba1	72 a0		 jb	 SHORT $LL170@inflate
$LN535@inflate:

; 960  :             }
; 961  :             while (state->have < 19)

  00ba3	83 f8 13	 cmp	 eax, 19
  00ba6	73 26		 jae	 SHORT $LN184@inflate
$LL183@inflate:

; 962  :                 state->lens[order[state->have++]] = 0;

  00ba8	0f b7 84 42 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[rdx+rax*2]
  00bb0	66 45 89 bc 45
	90 00 00 00	 mov	 WORD PTR [r13+rax*2+144], r15w
  00bb9	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00bc0	ff c0		 inc	 eax
  00bc2	41 89 85 84 00
	00 00		 mov	 DWORD PTR [r13+132], eax
  00bc9	83 f8 13	 cmp	 eax, 19
  00bcc	72 da		 jb	 SHORT $LL183@inflate
$LN184@inflate:

; 963  :             state->next = state->codes;

  00bce	49 8d 85 50 05
	00 00		 lea	 rax, QWORD PTR [r13+1360]

; 964  :             state->lencode = (const code FAR *)(state->next);
; 965  :             state->lenbits = 7;

  00bd5	c7 07 07 00 00
	00		 mov	 DWORD PTR [rdi], 7
  00bdb	4d 8d 8d 88 00
	00 00		 lea	 r9, QWORD PTR [r13+136]
  00be2	49 89 45 60	 mov	 QWORD PTR [r13+96], rax

; 966  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  00be6	33 c9		 xor	 ecx, ecx
  00be8	49 89 01	 mov	 QWORD PTR [r9], rax
  00beb	49 8d 85 10 03
	00 00		 lea	 rax, QWORD PTR [r13+784]
  00bf2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00bf7	49 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR [r13+144]
  00bfe	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00c03	44 8d 41 13	 lea	 r8d, QWORD PTR [rcx+19]
  00c07	e8 00 00 00 00	 call	 inflate_table

; 967  :                                 &(state->lenbits), state->work);
; 968  :             if (ret) {

  00c0c	44 8b 5c 24 30	 mov	 r11d, DWORD PTR left$1$[rsp]
  00c11	89 84 24 a8 00
	00 00		 mov	 DWORD PTR ret$1$[rsp], eax
  00c18	85 c0		 test	 eax, eax
  00c1a	74 32		 je	 SHORT $LN429@inflate

; 969  :                 strm->msg = (char *)"invalid code lengths set";

  00c1c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@
  00c23	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 970  :                 state->mode = BAD;

  00c28	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 971  :                 break;

  00c30	e9 47 fb ff ff	 jmp	 $LN905@inflate
$LN426@inflate:

; 946  :                 strm->msg = (char *)"too many length or distance symbols";

  00c35	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@
  00c3c	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 947  :                 state->mode = BAD;

  00c41	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 948  :                 break;

  00c49	e9 33 fb ff ff	 jmp	 $LN8@inflate
$LN429@inflate:

; 972  :             }
; 973  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 974  :             state->have = 0;

  00c4e	45 89 bd 84 00
	00 00		 mov	 DWORD PTR [r13+132], r15d

; 975  :             state->mode = CODELENS;

  00c55	41 c7 45 08 46
	3f 00 00	 mov	 DWORD PTR [r13+8], 16198 ; 00003f46H
$LN536@inflate:

; 976  :                 /* fallthrough */
; 977  :         case CODELENS:
; 978  :             while (state->have < state->nlen + state->ndist) {

  00c5d	41 8b 85 80 00
	00 00		 mov	 eax, DWORD PTR [r13+128]
  00c64	41 03 45 7c	 add	 eax, DWORD PTR [r13+124]
  00c68	41 39 85 84 00
	00 00		 cmp	 DWORD PTR [r13+132], eax
  00c6f	0f 83 38 02 00
	00		 jae	 $LN186@inflate
  00c75	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL185@inflate:

; 979  :                 for (;;) {
; 980  :                     here = state->lencode[BITS(state->lenbits)];

  00c80	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  00c82	41 b9 01 00 00
	00		 mov	 r9d, 1
  00c88	4d 8b 55 60	 mov	 r10, QWORD PTR [r13+96]
  00c8c	41 d3 e1	 shl	 r9d, cl
  00c8f	41 ff c9	 dec	 r9d
  00c92	41 8b c6	 mov	 eax, r14d
  00c95	41 8b c9	 mov	 ecx, r9d
  00c98	48 23 c8	 and	 rcx, rax
  00c9b	41 8b 04 8a	 mov	 eax, DWORD PTR [r10+rcx*4]
  00c9f	44 8b c0	 mov	 r8d, eax
  00ca2	41 c1 e8 08	 shr	 r8d, 8
  00ca6	8b d0		 mov	 edx, eax
  00ca8	41 0f b6 c8	 movzx	 ecx, r8b
  00cac	c1 ea 10	 shr	 edx, 16
  00caf	89 44 24 38	 mov	 DWORD PTR here$[rsp], eax

; 981  :                     if ((unsigned)(here.bits) <= bits) break;

  00cb3	3b cb		 cmp	 ecx, ebx
  00cb5	76 43		 jbe	 SHORT $LN563@inflate
$LL187@inflate:

; 982  :                     PULLBYTE();

  00cb7	85 f6		 test	 esi, esi
  00cb9	0f 84 58 fc ff
	ff		 je	 $LN938@inflate
  00cbf	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  00cc3	8b cb		 mov	 ecx, ebx
  00cc5	d3 e0		 shl	 eax, cl
  00cc7	ff ce		 dec	 esi
  00cc9	44 03 f0	 add	 r14d, eax
  00ccc	48 ff c5	 inc	 rbp
  00ccf	41 8b c1	 mov	 eax, r9d
  00cd2	83 c3 08	 add	 ebx, 8
  00cd5	41 8b ce	 mov	 ecx, r14d
  00cd8	48 23 c8	 and	 rcx, rax
  00cdb	41 8b 04 8a	 mov	 eax, DWORD PTR [r10+rcx*4]
  00cdf	44 8b c0	 mov	 r8d, eax
  00ce2	41 c1 e8 08	 shr	 r8d, 8
  00ce6	8b c8		 mov	 ecx, eax
  00ce8	41 0f b6 d0	 movzx	 edx, r8b
  00cec	c1 e9 10	 shr	 ecx, 16
  00cef	89 44 24 38	 mov	 DWORD PTR here$[rsp], eax
  00cf3	3b d3		 cmp	 edx, ebx
  00cf5	77 c0		 ja	 SHORT $LL187@inflate

; 981  :                     if ((unsigned)(here.bits) <= bits) break;

  00cf7	0f b7 d1	 movzx	 edx, cx
$LN563@inflate:

; 983  :                 }
; 984  :                 if (here.val < 16) {

  00cfa	66 83 fa 10	 cmp	 dx, 16
  00cfe	73 36		 jae	 SHORT $LN433@inflate

; 985  :                     DROPBITS(here.bits);

  00d00	41 8b c8	 mov	 ecx, r8d
  00d03	41 d3 ee	 shr	 r14d, cl
  00d06	8b c8		 mov	 ecx, eax
  00d08	c1 e9 08	 shr	 ecx, 8
  00d0b	0f b6 c9	 movzx	 ecx, cl
  00d0e	2b d9		 sub	 ebx, ecx

; 986  :                     state->lens[state->have++] = here.val;

  00d10	c1 e8 10	 shr	 eax, 16
  00d13	41 8b 8d 84 00
	00 00		 mov	 ecx, DWORD PTR [r13+132]
  00d1a	66 41 89 84 4d
	90 00 00 00	 mov	 WORD PTR [r13+rcx*2+144], ax
  00d23	41 ff 85 84 00
	00 00		 inc	 DWORD PTR [r13+132]
  00d2a	45 8b 85 84 00
	00 00		 mov	 r8d, DWORD PTR [r13+132]

; 987  :                 }

  00d31	e9 4d 01 00 00	 jmp	 $LN611@inflate
$LN433@inflate:

; 988  :                 else {
; 989  :                     if (here.val == 16) {

  00d36	75 6f		 jne	 SHORT $LN435@inflate

; 990  :                         NEEDBITS(here.bits + 2);

  00d38	c1 e8 08	 shr	 eax, 8
  00d3b	41 0f b6 d0	 movzx	 edx, r8b
  00d3f	83 c2 02	 add	 edx, 2
  00d42	44 0f b6 c8	 movzx	 r9d, al
  00d46	3b da		 cmp	 ebx, edx
  00d48	73 25		 jae	 SHORT $LN196@inflate
  00d4a	66 0f 1f 44 00
	00		 npad	 6
$LL199@inflate:
  00d50	85 f6		 test	 esi, esi
  00d52	0f 84 bf fb ff
	ff		 je	 $LN938@inflate
  00d58	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  00d5c	8b cb		 mov	 ecx, ebx
  00d5e	d3 e0		 shl	 eax, cl
  00d60	ff ce		 dec	 esi
  00d62	44 03 f0	 add	 r14d, eax
  00d65	48 ff c5	 inc	 rbp
  00d68	83 c3 08	 add	 ebx, 8
  00d6b	3b da		 cmp	 ebx, edx
  00d6d	72 e1		 jb	 SHORT $LL199@inflate
$LN196@inflate:

; 991  :                         DROPBITS(here.bits);
; 992  :                         if (state->have == 0) {

  00d6f	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00d76	41 8b c9	 mov	 ecx, r9d
  00d79	41 d3 ee	 shr	 r14d, cl
  00d7c	41 2b d9	 sub	 ebx, r9d
  00d7f	85 c0		 test	 eax, eax
  00d81	0f 84 12 01 00
	00		 je	 $LN569@inflate

; 993  :                             strm->msg = (char *)"invalid bit length repeat";
; 994  :                             state->mode = BAD;
; 995  :                             break;
; 996  :                         }
; 997  :                         len = state->lens[state->have - 1];
; 998  :                         copy = 3 + BITS(2);

  00d87	41 8b d6	 mov	 edx, r14d

; 999  :                         DROPBITS(2);

  00d8a	83 c3 fe	 add	 ebx, -2			; fffffffeH
  00d8d	83 e2 03	 and	 edx, 3
  00d90	41 c1 ee 02	 shr	 r14d, 2
  00d94	83 c2 03	 add	 edx, 3
  00d97	ff c8		 dec	 eax
  00d99	45 0f b7 8c 45
	90 00 00 00	 movzx	 r9d, WORD PTR [r13+rax*2+144]

; 1000 :                     }

  00da2	e9 9f 00 00 00	 jmp	 $LN236@inflate
$LN435@inflate:

; 1001 :                     else if (here.val == 17) {

  00da7	44 0f b6 4c 24
	39		 movzx	 r9d, BYTE PTR here$[rsp+1]
  00dad	66 83 fa 11	 cmp	 dx, 17
  00db1	41 0f b6 d0	 movzx	 edx, r8b
  00db5	75 48		 jne	 SHORT $LN226@inflate

; 1002 :                         NEEDBITS(here.bits + 3);

  00db7	83 c2 03	 add	 edx, 3
  00dba	3b da		 cmp	 ebx, edx
  00dbc	73 21		 jae	 SHORT $LN210@inflate
  00dbe	66 90		 npad	 2
$LL213@inflate:
  00dc0	85 f6		 test	 esi, esi
  00dc2	0f 84 4f fb ff
	ff		 je	 $LN938@inflate
  00dc8	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  00dcc	8b cb		 mov	 ecx, ebx
  00dce	d3 e0		 shl	 eax, cl
  00dd0	ff ce		 dec	 esi
  00dd2	44 03 f0	 add	 r14d, eax
  00dd5	48 ff c5	 inc	 rbp
  00dd8	83 c3 08	 add	 ebx, 8
  00ddb	3b da		 cmp	 ebx, edx
  00ddd	72 e1		 jb	 SHORT $LL213@inflate
$LN210@inflate:

; 1003 :                         DROPBITS(here.bits);

  00ddf	41 8b c9	 mov	 ecx, r9d

; 1004 :                         len = 0;
; 1005 :                         copy = 3 + BITS(3);
; 1006 :                         DROPBITS(3);

  00de2	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00de7	41 d3 ee	 shr	 r14d, cl
  00dea	41 8b d6	 mov	 edx, r14d
  00ded	41 c1 ee 03	 shr	 r14d, 3
  00df1	83 e2 07	 and	 edx, 7
  00df4	83 c2 03	 add	 edx, 3
  00df7	41 2b c1	 sub	 eax, r9d
  00dfa	45 8b cf	 mov	 r9d, r15d

; 1007 :                     }

  00dfd	eb 45		 jmp	 SHORT $LN972@inflate
$LN226@inflate:

; 1008 :                     else {
; 1009 :                         NEEDBITS(here.bits + 7);

  00dff	83 c2 07	 add	 edx, 7
  00e02	3b da		 cmp	 ebx, edx
  00e04	73 1f		 jae	 SHORT $LN224@inflate
$LL227@inflate:
  00e06	85 f6		 test	 esi, esi
  00e08	0f 84 09 fb ff
	ff		 je	 $LN938@inflate
  00e0e	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  00e12	8b cb		 mov	 ecx, ebx
  00e14	d3 e0		 shl	 eax, cl
  00e16	ff ce		 dec	 esi
  00e18	44 03 f0	 add	 r14d, eax
  00e1b	48 ff c5	 inc	 rbp
  00e1e	83 c3 08	 add	 ebx, 8
  00e21	3b da		 cmp	 ebx, edx
  00e23	72 e1		 jb	 SHORT $LL227@inflate
$LN224@inflate:

; 1010 :                         DROPBITS(here.bits);

  00e25	41 8b c9	 mov	 ecx, r9d

; 1011 :                         len = 0;
; 1012 :                         copy = 11 + BITS(7);
; 1013 :                         DROPBITS(7);

  00e28	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
  00e2d	41 d3 ee	 shr	 r14d, cl
  00e30	41 8b d6	 mov	 edx, r14d
  00e33	41 c1 ee 07	 shr	 r14d, 7
  00e37	83 e2 7f	 and	 edx, 127		; 0000007fH
  00e3a	83 c2 0b	 add	 edx, 11
  00e3d	41 2b c1	 sub	 eax, r9d
  00e40	45 0f b7 cf	 movzx	 r9d, r15w
$LN972@inflate:

; 1014 :                     }
; 1015 :                     if (state->have + copy > state->nlen + state->ndist) {

  00e44	03 d8		 add	 ebx, eax
$LN236@inflate:
  00e46	45 8b 85 84 00
	00 00		 mov	 r8d, DWORD PTR [r13+132]
  00e4d	41 8b 4d 7c	 mov	 ecx, DWORD PTR [r13+124]
  00e51	41 03 8d 80 00
	00 00		 add	 ecx, DWORD PTR [r13+128]
  00e58	41 8d 04 10	 lea	 eax, DWORD PTR [r8+rdx]
  00e5c	3b c1		 cmp	 eax, ecx
  00e5e	77 39		 ja	 SHORT $LN569@inflate
$LL238@inflate:

; 1016 :                         strm->msg = (char *)"invalid bit length repeat";
; 1017 :                         state->mode = BAD;
; 1018 :                         break;
; 1019 :                     }
; 1020 :                     while (copy--)
; 1021 :                         state->lens[state->have++] = (unsigned short)len;

  00e60	41 8b c0	 mov	 eax, r8d
  00e63	66 45 89 8c 45
	90 00 00 00	 mov	 WORD PTR [r13+rax*2+144], r9w
  00e6c	45 8b 85 84 00
	00 00		 mov	 r8d, DWORD PTR [r13+132]
  00e73	45 8d 40 01	 lea	 r8d, DWORD PTR [r8+1]
  00e77	45 89 85 84 00
	00 00		 mov	 DWORD PTR [r13+132], r8d
  00e7e	83 c2 ff	 add	 edx, -1			; ffffffffH
  00e81	75 dd		 jne	 SHORT $LL238@inflate
$LN611@inflate:

; 976  :                 /* fallthrough */
; 977  :         case CODELENS:
; 978  :             while (state->have < state->nlen + state->ndist) {

  00e83	41 8b 45 7c	 mov	 eax, DWORD PTR [r13+124]
  00e87	41 03 85 80 00
	00 00		 add	 eax, DWORD PTR [r13+128]
  00e8e	44 3b c0	 cmp	 r8d, eax
  00e91	0f 82 e9 fd ff
	ff		 jb	 $LL185@inflate
  00e97	eb 14		 jmp	 SHORT $LN186@inflate
$LN569@inflate:

; 1022 :                 }
; 1023 :             }
; 1024 : 
; 1025 :             /* handle error breaks in while */
; 1026 :             if (state->mode == BAD) break;

  00e99	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
  00ea0	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax
  00ea5	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
$LN186@inflate:
  00ead	41 81 7d 08 51
	3f 00 00	 cmp	 DWORD PTR [r13+8], 16209 ; 00003f51H
  00eb5	0f 84 c1 f8 ff
	ff		 je	 $LN905@inflate

; 1027 : 
; 1028 :             /* check for end-of-block code (better have one) */
; 1029 :             if (state->lens[256] == 0) {

  00ebb	66 41 83 bd 90
	02 00 00 00	 cmp	 WORD PTR [r13+656], 0
  00ec4	75 19		 jne	 SHORT $LN445@inflate

; 1030 :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00ec6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@
  00ecd	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1031 :                 state->mode = BAD;

  00ed2	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1032 :                 break;

  00eda	e9 9d f8 ff ff	 jmp	 $LN905@inflate
$LN445@inflate:

; 1033 :             }
; 1034 : 
; 1035 :             /* build code tables -- note: do not change the lenbits or distbits
; 1036 :                values here (9 and 6) without reading the comments in inftrees.h
; 1037 :                concerning the ENOUGH constants, which depend on those values */
; 1038 :             state->next = state->codes;
; 1039 :             state->lencode = (const code FAR *)(state->next);
; 1040 :             state->lenbits = 9;
; 1041 :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  00edf	45 8b 45 7c	 mov	 r8d, DWORD PTR [r13+124]
  00ee3	49 8d 85 50 05
	00 00		 lea	 rax, QWORD PTR [r13+1360]
  00eea	49 89 85 88 00
	00 00		 mov	 QWORD PTR [r13+136], rax
  00ef1	4d 8d bd 10 03
	00 00		 lea	 r15, QWORD PTR [r13+784]
  00ef8	49 89 45 60	 mov	 QWORD PTR [r13+96], rax
  00efc	49 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR [r13+144]
  00f03	49 8d 45 70	 lea	 rax, QWORD PTR [r13+112]
  00f07	4c 89 7c 24 28	 mov	 QWORD PTR [rsp+40], r15
  00f0c	4d 8d 8d 88 00
	00 00		 lea	 r9, QWORD PTR [r13+136]
  00f13	c7 00 09 00 00
	00		 mov	 DWORD PTR [rax], 9
  00f19	b9 01 00 00 00	 mov	 ecx, 1
  00f1e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f23	e8 00 00 00 00	 call	 inflate_table
  00f28	89 84 24 a8 00
	00 00		 mov	 DWORD PTR ret$1$[rsp], eax

; 1042 :                                 &(state->lenbits), state->work);
; 1043 :             if (ret) {

  00f2f	85 c0		 test	 eax, eax
  00f31	74 19		 je	 SHORT $LN446@inflate

; 1044 :                 strm->msg = (char *)"invalid literal/lengths set";

  00f33	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@
  00f3a	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax
  00f3f	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  00f47	e9 2b f8 ff ff	 jmp	 $LN975@inflate
$LN446@inflate:

; 1045 :                 state->mode = BAD;
; 1046 :                 break;
; 1047 :             }
; 1048 :             state->distcode = (const code FAR *)(state->next);

  00f4c	49 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR [r13+136]

; 1049 :             state->distbits = 6;

  00f53	49 8d 4d 74	 lea	 rcx, QWORD PTR [r13+116]

; 1050 :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  00f57	45 8b 85 80 00
	00 00		 mov	 r8d, DWORD PTR [r13+128]
  00f5e	4d 8d 8d 88 00
	00 00		 lea	 r9, QWORD PTR [r13+136]
  00f65	49 89 45 68	 mov	 QWORD PTR [r13+104], rax
  00f69	41 8b 45 7c	 mov	 eax, DWORD PTR [r13+124]
  00f6d	c7 01 06 00 00
	00		 mov	 DWORD PTR [rcx], 6
  00f73	4c 89 7c 24 28	 mov	 QWORD PTR [rsp+40], r15
  00f78	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00f7d	b9 02 00 00 00	 mov	 ecx, 2
  00f82	48 8d 14 45 90
	00 00 00	 lea	 rdx, QWORD PTR [rax*2+144]
  00f8a	49 03 d5	 add	 rdx, r13
  00f8d	e8 00 00 00 00	 call	 inflate_table
  00f92	89 84 24 a8 00
	00 00		 mov	 DWORD PTR ret$1$[rsp], eax
  00f99	44 8b f8	 mov	 r15d, eax

; 1051 :                             &(state->next), &(state->distbits), state->work);
; 1052 :             if (ret) {

  00f9c	85 c0		 test	 eax, eax
  00f9e	74 19		 je	 SHORT $LN447@inflate

; 1053 :                 strm->msg = (char *)"invalid distances set";

  00fa0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set@
  00fa7	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax
  00fac	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  00fb4	e9 be f7 ff ff	 jmp	 $LN975@inflate
$LN447@inflate:

; 1054 :                 state->mode = BAD;
; 1055 :                 break;
; 1056 :             }
; 1057 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1058 :             state->mode = LEN_;
; 1059 :             if (flush == Z_TREES) goto inf_leave;

  00fb9	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR flush$[rsp]
  00fc0	41 c7 45 08 47
	3f 00 00	 mov	 DWORD PTR [r13+8], 16199 ; 00003f47H
  00fc8	83 f9 06	 cmp	 ecx, 6
  00fcb	0f 84 cd 06 00
	00		 je	 $LN916@inflate
  00fd1	4c 8b 54 24 40	 mov	 r10, QWORD PTR put$1$[rsp]
  00fd6	49 8d 7d 70	 lea	 rdi, QWORD PTR [r13+112]
  00fda	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR out$1$[rsp]
  00fe2	45 33 ff	 xor	 r15d, r15d
  00fe5	44 8b 5c 24 30	 mov	 r11d, DWORD PTR left$1$[rsp]
$LN448@inflate:

; 1060 :                 /* fallthrough */
; 1061 :         case LEN_:
; 1062 :             state->mode = LEN;

  00fea	41 c7 45 08 48
	3f 00 00	 mov	 DWORD PTR [r13+8], 16200 ; 00003f48H
$LN450@inflate:

; 1063 :                 /* fallthrough */
; 1064 :         case LEN:
; 1065 :             if (have >= 6 && left >= 258) {

  00ff2	83 fe 06	 cmp	 esi, 6
  00ff5	72 72		 jb	 SHORT $LN451@inflate
  00ff7	41 81 fb 02 01
	00 00		 cmp	 r11d, 258		; 00000102H
  00ffe	72 69		 jb	 SHORT $LN451@inflate

; 1066 :                 RESTORE();

  01000	4d 89 54 24 10	 mov	 QWORD PTR [r12+16], r10

; 1067 :                 inflate_fast(strm, out);

  01005	41 8b d0	 mov	 edx, r8d
  01008	45 89 5c 24 18	 mov	 DWORD PTR [r12+24], r11d
  0100d	49 8b cc	 mov	 rcx, r12
  01010	49 89 2c 24	 mov	 QWORD PTR [r12], rbp
  01014	41 89 74 24 08	 mov	 DWORD PTR [r12+8], esi
  01019	45 89 75 48	 mov	 DWORD PTR [r13+72], r14d
  0101d	41 89 5d 4c	 mov	 DWORD PTR [r13+76], ebx
  01021	e8 00 00 00 00	 call	 inflate_fast

; 1068 :                 LOAD();
; 1069 :                 if (state->mode == TYPE)

  01026	41 81 7d 08 3f
	3f 00 00	 cmp	 DWORD PTR [r13+8], 16191 ; 00003f3fH
  0102e	4d 8b 54 24 10	 mov	 r10, QWORD PTR [r12+16]
  01033	45 8b 5c 24 18	 mov	 r11d, DWORD PTR [r12+24]
  01038	49 8b 2c 24	 mov	 rbp, QWORD PTR [r12]
  0103c	41 8b 74 24 08	 mov	 esi, DWORD PTR [r12+8]
  01041	45 8b 75 48	 mov	 r14d, DWORD PTR [r13+72]
  01045	41 8b 5d 4c	 mov	 ebx, DWORD PTR [r13+76]
  01049	4c 89 54 24 40	 mov	 QWORD PTR put$1$[rsp], r10
  0104e	44 89 5c 24 30	 mov	 DWORD PTR left$1$[rsp], r11d
  01053	0f 85 28 f7 ff
	ff		 jne	 $LN8@inflate

; 1070 :                     state->back = -1;

  01059	41 c7 85 e4 1b
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [r13+7140], -1

; 1071 :                 break;

  01064	e9 18 f7 ff ff	 jmp	 $LN8@inflate
$LN451@inflate:

; 1072 :             }
; 1073 :             state->back = 0;
; 1074 :             for (;;) {
; 1075 :                 here = state->lencode[BITS(state->lenbits)];

  01069	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  0106b	ba 01 00 00 00	 mov	 edx, 1
  01070	4d 8b 4d 60	 mov	 r9, QWORD PTR [r13+96]
  01074	d3 e2		 shl	 edx, cl
  01076	ff ca		 dec	 edx
  01078	41 8b c6	 mov	 eax, r14d
  0107b	8b ca		 mov	 ecx, edx
  0107d	48 23 c8	 and	 rcx, rax
  01080	45 89 bd e4 1b
	00 00		 mov	 DWORD PTR [r13+7140], r15d
  01087	41 8b 04 89	 mov	 eax, DWORD PTR [r9+rcx*4]
  0108b	8b c8		 mov	 ecx, eax
  0108d	c1 e9 08	 shr	 ecx, 8
  01090	0f b6 c9	 movzx	 ecx, cl

; 1076 :                 if ((unsigned)(here.bits) <= bits) break;

  01093	3b cb		 cmp	 ecx, ebx
  01095	76 33		 jbe	 SHORT $LN570@inflate
$LL246@inflate:

; 1077 :                 PULLBYTE();

  01097	85 f6		 test	 esi, esi
  01099	0f 84 78 f8 ff
	ff		 je	 $LN938@inflate
  0109f	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  010a3	8b cb		 mov	 ecx, ebx
  010a5	d3 e0		 shl	 eax, cl
  010a7	ff ce		 dec	 esi
  010a9	44 03 f0	 add	 r14d, eax
  010ac	48 ff c5	 inc	 rbp
  010af	8b c2		 mov	 eax, edx
  010b1	83 c3 08	 add	 ebx, 8
  010b4	41 8b ce	 mov	 ecx, r14d
  010b7	48 23 c8	 and	 rcx, rax
  010ba	41 8b 04 89	 mov	 eax, DWORD PTR [r9+rcx*4]
  010be	8b c8		 mov	 ecx, eax
  010c0	c1 e9 08	 shr	 ecx, 8
  010c3	0f b6 c9	 movzx	 ecx, cl
  010c6	3b cb		 cmp	 ecx, ebx
  010c8	77 cd		 ja	 SHORT $LL246@inflate
$LN570@inflate:

; 1078 :             }
; 1079 :             if (here.op && (here.op & 0xf0) == 0) {

  010ca	84 c0		 test	 al, al
  010cc	0f 84 9b 00 00
	00		 je	 $LN263@inflate
  010d2	a8 f0		 test	 al, 240			; 000000f0H
  010d4	0f 85 93 00 00
	00		 jne	 $LN263@inflate

; 1080 :                 last = here;

  010da	8b c8		 mov	 ecx, eax
  010dc	44 8b d0	 mov	 r10d, eax
  010df	c1 e9 08	 shr	 ecx, 8

; 1081 :                 for (;;) {
; 1082 :                     here = state->lencode[last.val +

  010e2	41 bb 01 00 00
	00		 mov	 r11d, 1
  010e8	44 0f b6 c1	 movzx	 r8d, cl
  010ec	0f b6 c8	 movzx	 ecx, al
  010ef	41 03 c8	 add	 ecx, r8d
  010f2	41 c1 ea 10	 shr	 r10d, 16
  010f6	41 d3 e3	 shl	 r11d, cl
  010f9	41 8b c8	 mov	 ecx, r8d
  010fc	41 8d 43 ff	 lea	 eax, DWORD PTR [r11-1]
  01100	41 23 c6	 and	 eax, r14d
  01103	d3 e8		 shr	 eax, cl
  01105	41 03 c2	 add	 eax, r10d
  01108	41 8b 04 81	 mov	 eax, DWORD PTR [r9+rax*4]
  0110c	8b c8		 mov	 ecx, eax
  0110e	c1 e9 08	 shr	 ecx, 8

; 1083 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1084 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01111	0f b6 d1	 movzx	 edx, cl
  01114	41 03 d0	 add	 edx, r8d
  01117	3b d3		 cmp	 edx, ebx
  01119	76 42		 jbe	 SHORT $LN260@inflate
  0111b	0f 1f 44 00 00	 npad	 5
$LL252@inflate:

; 1085 :                     PULLBYTE();

  01120	85 f6		 test	 esi, esi
  01122	0f 84 ef f7 ff
	ff		 je	 $LN938@inflate
  01128	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  0112c	8b cb		 mov	 ecx, ebx
  0112e	d3 e0		 shl	 eax, cl
  01130	ff ce		 dec	 esi
  01132	44 03 f0	 add	 r14d, eax
  01135	41 8b c8	 mov	 ecx, r8d
  01138	41 8d 43 ff	 lea	 eax, DWORD PTR [r11-1]
  0113c	48 ff c5	 inc	 rbp
  0113f	41 23 c6	 and	 eax, r14d
  01142	83 c3 08	 add	 ebx, 8
  01145	d3 e8		 shr	 eax, cl
  01147	41 03 c2	 add	 eax, r10d
  0114a	41 8b 04 81	 mov	 eax, DWORD PTR [r9+rax*4]
  0114e	8b c8		 mov	 ecx, eax
  01150	c1 e9 08	 shr	 ecx, 8
  01153	0f b6 d1	 movzx	 edx, cl
  01156	41 03 d0	 add	 edx, r8d
  01159	3b d3		 cmp	 edx, ebx
  0115b	77 c3		 ja	 SHORT $LL252@inflate
$LN260@inflate:

; 1086 :                 }
; 1087 :                 DROPBITS(last.bits);

  0115d	41 8b c8	 mov	 ecx, r8d

; 1088 :                 state->back += last.bits;

  01160	45 89 85 e4 1b
	00 00		 mov	 DWORD PTR [r13+7140], r8d
  01167	41 d3 ee	 shr	 r14d, cl
  0116a	41 2b d8	 sub	 ebx, r8d
$LN263@inflate:

; 1089 :             }
; 1090 :             DROPBITS(here.bits);

  0116d	8b c8		 mov	 ecx, eax
  0116f	c1 e9 08	 shr	 ecx, 8
  01172	0f b6 c9	 movzx	 ecx, cl

; 1091 :             state->back += here.bits;

  01175	41 01 8d e4 1b
	00 00		 add	 DWORD PTR [r13+7140], ecx
  0117c	2b d9		 sub	 ebx, ecx
  0117e	41 d3 ee	 shr	 r14d, cl

; 1092 :             state->length = (unsigned)here.val;

  01181	8b c8		 mov	 ecx, eax
  01183	c1 e9 10	 shr	 ecx, 16
  01186	41 89 4d 50	 mov	 DWORD PTR [r13+80], ecx

; 1093 :             if ((int)(here.op) == 0) {

  0118a	84 c0		 test	 al, al
  0118c	75 0d		 jne	 SHORT $LN458@inflate

; 1094 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1095 :                         "inflate:         literal '%c'\n" :
; 1096 :                         "inflate:         literal 0x%02x\n", here.val));
; 1097 :                 state->mode = LIT;

  0118e	41 c7 45 08 4d
	3f 00 00	 mov	 DWORD PTR [r13+8], 16205 ; 00003f4dH

; 1098 :                 break;

  01196	e9 dc f5 ff ff	 jmp	 $LN975@inflate
$LN458@inflate:

; 1099 :             }
; 1100 :             if (here.op & 32) {

  0119b	a8 20		 test	 al, 32			; 00000020H
  0119d	74 10		 je	 SHORT $LN459@inflate

; 1101 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1102 :                 state->back = -1;

  0119f	41 c7 85 e4 1b
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [r13+7140], -1

; 1103 :                 state->mode = TYPE;
; 1104 :                 break;

  011aa	e9 c0 f5 ff ff	 jmp	 $LN978@inflate
$LN459@inflate:

; 1105 :             }
; 1106 :             if (here.op & 64) {

  011af	a8 40		 test	 al, 64			; 00000040H
  011b1	74 19		 je	 SHORT $LN460@inflate

; 1107 :                 strm->msg = (char *)"invalid literal/length code";

  011b3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
  011ba	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax
  011bf	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  011c7	e9 ab f5 ff ff	 jmp	 $LN975@inflate
$LN460@inflate:

; 1108 :                 state->mode = BAD;
; 1109 :                 break;
; 1110 :             }
; 1111 :             state->extra = (unsigned)(here.op) & 15;

  011cc	0f b6 c8	 movzx	 ecx, al

; 1112 :             state->mode = LENEXT;

  011cf	4d 8d 4d 74	 lea	 r9, QWORD PTR [r13+116]
  011d3	83 e1 0f	 and	 ecx, 15
  011d6	41 c7 45 08 49
	3f 00 00	 mov	 DWORD PTR [r13+8], 16201 ; 00003f49H
  011de	41 89 4d 58	 mov	 DWORD PTR [r13+88], ecx
$LN461@inflate:

; 1113 :                 /* fallthrough */
; 1114 :         case LENEXT:
; 1115 :             if (state->extra) {

  011e2	41 8b 55 58	 mov	 edx, DWORD PTR [r13+88]
  011e6	85 d2		 test	 edx, edx
  011e8	74 43		 je	 SHORT $LN728@inflate

; 1116 :                 NEEDBITS(state->extra);

  011ea	3b da		 cmp	 ebx, edx
  011ec	73 21		 jae	 SHORT $LN264@inflate
  011ee	66 90		 npad	 2
$LL267@inflate:
  011f0	85 f6		 test	 esi, esi
  011f2	0f 84 1f f7 ff
	ff		 je	 $LN938@inflate
  011f8	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  011fc	8b cb		 mov	 ecx, ebx
  011fe	d3 e0		 shl	 eax, cl
  01200	ff ce		 dec	 esi
  01202	44 03 f0	 add	 r14d, eax
  01205	48 ff c5	 inc	 rbp
  01208	83 c3 08	 add	 ebx, 8
  0120b	3b da		 cmp	 ebx, edx
  0120d	72 e1		 jb	 SHORT $LL267@inflate
$LN264@inflate:

; 1117 :                 state->length += BITS(state->extra);

  0120f	8b ca		 mov	 ecx, edx
  01211	b8 01 00 00 00	 mov	 eax, 1
  01216	d3 e0		 shl	 eax, cl

; 1118 :                 DROPBITS(state->extra);

  01218	2b da		 sub	 ebx, edx
  0121a	ff c8		 dec	 eax
  0121c	41 23 c6	 and	 eax, r14d
  0121f	41 d3 ee	 shr	 r14d, cl
  01222	41 01 45 50	 add	 DWORD PTR [r13+80], eax

; 1119 :                 state->back += state->extra;

  01226	41 01 95 e4 1b
	00 00		 add	 DWORD PTR [r13+7140], edx
$LN728@inflate:

; 1120 :             }
; 1121 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1122 :             state->was = state->length;

  0122d	41 8b 45 50	 mov	 eax, DWORD PTR [r13+80]
  01231	41 89 85 e8 1b
	00 00		 mov	 DWORD PTR [r13+7144], eax

; 1123 :             state->mode = DIST;

  01238	41 c7 45 08 4a
	3f 00 00	 mov	 DWORD PTR [r13+8], 16202 ; 00003f4aH
$LN464@inflate:

; 1124 :                 /* fallthrough */
; 1125 :         case DIST:
; 1126 :             for (;;) {
; 1127 :                 here = state->distcode[BITS(state->distbits)];

  01240	41 8b 09	 mov	 ecx, DWORD PTR [r9]
  01243	ba 01 00 00 00	 mov	 edx, 1
  01248	4d 8b 4d 68	 mov	 r9, QWORD PTR [r13+104]
  0124c	d3 e2		 shl	 edx, cl
  0124e	ff ca		 dec	 edx
  01250	41 8b c6	 mov	 eax, r14d
  01253	8b ca		 mov	 ecx, edx
  01255	48 23 c8	 and	 rcx, rax
  01258	41 8b 04 89	 mov	 eax, DWORD PTR [r9+rcx*4]
  0125c	8b c8		 mov	 ecx, eax
  0125e	c1 e9 08	 shr	 ecx, 8
  01261	0f b6 c9	 movzx	 ecx, cl

; 1128 :                 if ((unsigned)(here.bits) <= bits) break;

  01264	3b cb		 cmp	 ecx, ebx
  01266	76 33		 jbe	 SHORT $LN575@inflate
$LL275@inflate:

; 1129 :                 PULLBYTE();

  01268	85 f6		 test	 esi, esi
  0126a	0f 84 a7 f6 ff
	ff		 je	 $LN938@inflate
  01270	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  01274	8b cb		 mov	 ecx, ebx
  01276	d3 e0		 shl	 eax, cl
  01278	ff ce		 dec	 esi
  0127a	44 03 f0	 add	 r14d, eax
  0127d	48 ff c5	 inc	 rbp
  01280	41 8b ce	 mov	 ecx, r14d
  01283	83 c3 08	 add	 ebx, 8
  01286	8b c2		 mov	 eax, edx
  01288	48 23 c1	 and	 rax, rcx
  0128b	41 8b 04 81	 mov	 eax, DWORD PTR [r9+rax*4]
  0128f	8b c8		 mov	 ecx, eax
  01291	c1 e9 08	 shr	 ecx, 8
  01294	0f b6 c9	 movzx	 ecx, cl
  01297	3b cb		 cmp	 ecx, ebx
  01299	77 cd		 ja	 SHORT $LL275@inflate
$LN575@inflate:

; 1130 :             }
; 1131 :             if ((here.op & 0xf0) == 0) {

  0129b	a8 f0		 test	 al, 240			; 000000f0H
  0129d	0f 85 8e 00 00
	00		 jne	 $LN292@inflate

; 1132 :                 last = here;

  012a3	8b c8		 mov	 ecx, eax
  012a5	44 8b d0	 mov	 r10d, eax
  012a8	c1 e9 08	 shr	 ecx, 8

; 1133 :                 for (;;) {
; 1134 :                     here = state->distcode[last.val +

  012ab	41 bb 01 00 00
	00		 mov	 r11d, 1
  012b1	44 0f b6 c1	 movzx	 r8d, cl
  012b5	0f b6 c8	 movzx	 ecx, al
  012b8	41 03 c8	 add	 ecx, r8d
  012bb	41 c1 ea 10	 shr	 r10d, 16
  012bf	41 d3 e3	 shl	 r11d, cl
  012c2	41 8b c8	 mov	 ecx, r8d
  012c5	41 8d 43 ff	 lea	 eax, DWORD PTR [r11-1]
  012c9	41 23 c6	 and	 eax, r14d
  012cc	d3 e8		 shr	 eax, cl
  012ce	41 03 c2	 add	 eax, r10d
  012d1	41 8b 04 81	 mov	 eax, DWORD PTR [r9+rax*4]
  012d5	8b c8		 mov	 ecx, eax
  012d7	c1 e9 08	 shr	 ecx, 8

; 1135 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1136 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  012da	0f b6 d1	 movzx	 edx, cl
  012dd	41 03 d0	 add	 edx, r8d
  012e0	3b d3		 cmp	 edx, ebx
  012e2	76 3d		 jbe	 SHORT $LN289@inflate
$LL281@inflate:

; 1137 :                     PULLBYTE();

  012e4	85 f6		 test	 esi, esi
  012e6	0f 84 2b f6 ff
	ff		 je	 $LN938@inflate
  012ec	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  012f0	8b cb		 mov	 ecx, ebx
  012f2	d3 e0		 shl	 eax, cl
  012f4	ff ce		 dec	 esi
  012f6	44 03 f0	 add	 r14d, eax
  012f9	41 8b c8	 mov	 ecx, r8d
  012fc	41 8d 43 ff	 lea	 eax, DWORD PTR [r11-1]
  01300	48 ff c5	 inc	 rbp
  01303	41 23 c6	 and	 eax, r14d
  01306	83 c3 08	 add	 ebx, 8
  01309	d3 e8		 shr	 eax, cl
  0130b	41 03 c2	 add	 eax, r10d
  0130e	41 8b 04 81	 mov	 eax, DWORD PTR [r9+rax*4]
  01312	8b c8		 mov	 ecx, eax
  01314	c1 e9 08	 shr	 ecx, 8
  01317	0f b6 d1	 movzx	 edx, cl
  0131a	41 03 d0	 add	 edx, r8d
  0131d	3b d3		 cmp	 edx, ebx
  0131f	77 c3		 ja	 SHORT $LL281@inflate
$LN289@inflate:

; 1138 :                 }
; 1139 :                 DROPBITS(last.bits);

  01321	41 8b c8	 mov	 ecx, r8d
  01324	41 2b d8	 sub	 ebx, r8d
  01327	41 d3 ee	 shr	 r14d, cl

; 1140 :                 state->back += last.bits;

  0132a	45 01 85 e4 1b
	00 00		 add	 DWORD PTR [r13+7140], r8d
$LN292@inflate:

; 1141 :             }
; 1142 :             DROPBITS(here.bits);
; 1143 :             state->back += here.bits;
; 1144 :             if (here.op & 64) {

  01331	4c 8b 54 24 40	 mov	 r10, QWORD PTR put$1$[rsp]
  01336	8b c8		 mov	 ecx, eax
  01338	44 8b 5c 24 30	 mov	 r11d, DWORD PTR left$1$[rsp]
  0133d	c1 e9 08	 shr	 ecx, 8
  01340	0f b6 c9	 movzx	 ecx, cl
  01343	41 01 8d e4 1b
	00 00		 add	 DWORD PTR [r13+7140], ecx
  0134a	2b d9		 sub	 ebx, ecx
  0134c	41 d3 ee	 shr	 r14d, cl
  0134f	a8 40		 test	 al, 64			; 00000040H
  01351	74 19		 je	 SHORT $LN470@inflate

; 1145 :                 strm->msg = (char *)"invalid distance code";

  01353	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code@
  0135a	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1146 :                 state->mode = BAD;

  0135f	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1147 :                 break;

  01367	e9 15 f4 ff ff	 jmp	 $LN8@inflate
$LN470@inflate:
  0136c	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR out$1$[rsp]

; 1148 :             }
; 1149 :             state->offset = (unsigned)here.val;

  01374	8b c8		 mov	 ecx, eax
  01376	c1 e9 10	 shr	 ecx, 16
  01379	41 89 4d 54	 mov	 DWORD PTR [r13+84], ecx

; 1150 :             state->extra = (unsigned)(here.op) & 15;

  0137d	0f b6 c8	 movzx	 ecx, al
  01380	83 e1 0f	 and	 ecx, 15

; 1151 :             state->mode = DISTEXT;

  01383	41 c7 45 08 4b
	3f 00 00	 mov	 DWORD PTR [r13+8], 16203 ; 00003f4bH
  0138b	41 89 4d 58	 mov	 DWORD PTR [r13+88], ecx
$LN471@inflate:

; 1152 :                 /* fallthrough */
; 1153 :         case DISTEXT:
; 1154 :             if (state->extra) {

  0138f	41 8b 55 58	 mov	 edx, DWORD PTR [r13+88]
  01393	85 d2		 test	 edx, edx
  01395	74 46		 je	 SHORT $LN730@inflate

; 1155 :                 NEEDBITS(state->extra);

  01397	3b da		 cmp	 ebx, edx
  01399	73 24		 jae	 SHORT $LN293@inflate
  0139b	0f 1f 44 00 00	 npad	 5
$LL296@inflate:
  013a0	85 f6		 test	 esi, esi
  013a2	0f 84 6f f5 ff
	ff		 je	 $LN938@inflate
  013a8	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  013ac	8b cb		 mov	 ecx, ebx
  013ae	d3 e0		 shl	 eax, cl
  013b0	ff ce		 dec	 esi
  013b2	44 03 f0	 add	 r14d, eax
  013b5	48 ff c5	 inc	 rbp
  013b8	83 c3 08	 add	 ebx, 8
  013bb	3b da		 cmp	 ebx, edx
  013bd	72 e1		 jb	 SHORT $LL296@inflate
$LN293@inflate:

; 1156 :                 state->offset += BITS(state->extra);

  013bf	8b ca		 mov	 ecx, edx
  013c1	b8 01 00 00 00	 mov	 eax, 1
  013c6	d3 e0		 shl	 eax, cl

; 1157 :                 DROPBITS(state->extra);

  013c8	2b da		 sub	 ebx, edx
  013ca	ff c8		 dec	 eax
  013cc	41 23 c6	 and	 eax, r14d
  013cf	41 d3 ee	 shr	 r14d, cl
  013d2	41 01 45 54	 add	 DWORD PTR [r13+84], eax

; 1158 :                 state->back += state->extra;

  013d6	41 01 95 e4 1b
	00 00		 add	 DWORD PTR [r13+7140], edx
$LN730@inflate:

; 1159 :             }
; 1160 : #ifdef INFLATE_STRICT
; 1161 :             if (state->offset > state->dmax) {
; 1162 :                 strm->msg = (char *)"invalid distance too far back";
; 1163 :                 state->mode = BAD;
; 1164 :                 break;
; 1165 :             }
; 1166 : #endif
; 1167 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1168 :             state->mode = MATCH;

  013dd	41 c7 45 08 4c
	3f 00 00	 mov	 DWORD PTR [r13+8], 16204 ; 00003f4cH
$LN474@inflate:

; 1169 :                 /* fallthrough */
; 1170 :         case MATCH:
; 1171 :             if (left == 0) goto inf_leave;

  013e5	45 85 db	 test	 r11d, r11d
  013e8	0f 84 29 f5 ff
	ff		 je	 $LN938@inflate

; 1172 :             copy = out - left;
; 1173 :             if (state->offset > copy) {         /* copy from window */

  013ee	41 8b 45 54	 mov	 eax, DWORD PTR [r13+84]
  013f2	41 8b c8	 mov	 ecx, r8d
  013f5	41 2b cb	 sub	 ecx, r11d
  013f8	3b c1		 cmp	 eax, ecx
  013fa	76 51		 jbe	 SHORT $LN476@inflate

; 1174 :                 copy = state->offset - copy;

  013fc	2b c1		 sub	 eax, ecx

; 1175 :                 if (copy > state->whave) {

  013fe	41 3b 45 38	 cmp	 eax, DWORD PTR [r13+56]
  01402	76 23		 jbe	 SHORT $LN479@inflate

; 1176 :                     if (state->sane) {

  01404	41 83 bd e0 1b
	00 00 00	 cmp	 DWORD PTR [r13+7136], 0
  0140c	74 19		 je	 SHORT $LN479@inflate

; 1177 :                         strm->msg = (char *)"invalid distance too far back";

  0140e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@
  01415	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1178 :                         state->mode = BAD;

  0141a	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1179 :                         break;

  01422	e9 5a f3 ff ff	 jmp	 $LN8@inflate
$LN479@inflate:

; 1180 :                     }
; 1181 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1182 :                     Trace((stderr, "inflate.c too far\n"));
; 1183 :                     copy -= state->whave;
; 1184 :                     if (copy > state->length) copy = state->length;
; 1185 :                     if (copy > left) copy = left;
; 1186 :                     left -= copy;
; 1187 :                     state->length -= copy;
; 1188 :                     do {
; 1189 :                         *put++ = 0;
; 1190 :                     } while (--copy);
; 1191 :                     if (state->length == 0) state->mode = LEN;
; 1192 :                     break;
; 1193 : #endif
; 1194 :                 }
; 1195 :                 if (copy > state->wnext) {

  01427	41 8b 4d 3c	 mov	 ecx, DWORD PTR [r13+60]
  0142b	3b c1		 cmp	 eax, ecx
  0142d	76 06		 jbe	 SHORT $LN480@inflate

; 1196 :                     copy -= state->wnext;

  0142f	2b c1		 sub	 eax, ecx

; 1197 :                     from = state->window + (state->wsize - copy);

  01431	41 8b 4d 34	 mov	 ecx, DWORD PTR [r13+52]
$LN480@inflate:

; 1198 :                 }
; 1199 :                 else
; 1200 :                     from = state->window + (state->wnext - copy);
; 1201 :                 if (copy > state->length) copy = state->length;

  01435	45 8b 45 50	 mov	 r8d, DWORD PTR [r13+80]
  01439	2b c8		 sub	 ecx, eax

; 1202 :             }

  0143b	41 3b c0	 cmp	 eax, r8d
  0143e	8b d1		 mov	 edx, ecx
  01440	45 8b c8	 mov	 r9d, r8d
  01443	44 0f 46 c8	 cmovbe	 r9d, eax
  01447	49 03 55 40	 add	 rdx, QWORD PTR [r13+64]
  0144b	eb 0d		 jmp	 SHORT $LN477@inflate
$LN476@inflate:

; 1203 :             else {                              /* copy from output */
; 1204 :                 from = put - state->offset;
; 1205 :                 copy = state->length;

  0144d	45 8b 45 50	 mov	 r8d, DWORD PTR [r13+80]
  01451	49 8b d2	 mov	 rdx, r10
  01454	48 2b d0	 sub	 rdx, rax
  01457	45 8b c8	 mov	 r9d, r8d
$LN477@inflate:

; 1206 :             }
; 1207 :             if (copy > left) copy = left;
; 1208 :             left -= copy;

  0145a	45 3b cb	 cmp	 r9d, r11d
  0145d	41 8b cb	 mov	 ecx, r11d
  01460	41 0f 46 c9	 cmovbe	 ecx, r9d
  01464	44 2b d9	 sub	 r11d, ecx

; 1209 :             state->length -= copy;

  01467	44 2b c1	 sub	 r8d, ecx
  0146a	44 89 5c 24 30	 mov	 DWORD PTR left$1$[rsp], r11d
  0146f	49 2b d2	 sub	 rdx, r10
  01472	45 89 45 50	 mov	 DWORD PTR [r13+80], r8d
  01476	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL306@inflate:

; 1210 :             do {
; 1211 :                 *put++ = *from++;

  01480	42 0f b6 04 12	 movzx	 eax, BYTE PTR [rdx+r10]
  01485	41 88 02	 mov	 BYTE PTR [r10], al
  01488	49 ff c2	 inc	 r10

; 1212 :             } while (--copy);

  0148b	83 c1 ff	 add	 ecx, -1			; ffffffffH
  0148e	75 f0		 jne	 SHORT $LL306@inflate

; 1213 :             if (state->length == 0) state->mode = LEN;

  01490	4c 89 54 24 40	 mov	 QWORD PTR put$1$[rsp], r10
  01495	41 39 4d 50	 cmp	 DWORD PTR [r13+80], ecx
  01499	0f 85 e2 f2 ff
	ff		 jne	 $LN8@inflate
  0149f	41 c7 45 08 48
	3f 00 00	 mov	 DWORD PTR [r13+8], 16200 ; 00003f48H

; 1214 :             break;

  014a7	e9 d5 f2 ff ff	 jmp	 $LN8@inflate
$LN485@inflate:

; 1215 :         case LIT:
; 1216 :             if (left == 0) goto inf_leave;

  014ac	45 85 db	 test	 r11d, r11d
  014af	0f 84 62 f4 ff
	ff		 je	 $LN938@inflate

; 1217 :             *put++ = (unsigned char)(state->length);

  014b5	41 0f b6 45 50	 movzx	 eax, BYTE PTR [r13+80]
  014ba	41 88 02	 mov	 BYTE PTR [r10], al
  014bd	49 ff c2	 inc	 r10

; 1218 :             left--;

  014c0	41 ff cb	 dec	 r11d
  014c3	4c 89 54 24 40	 mov	 QWORD PTR put$1$[rsp], r10
  014c8	44 89 5c 24 30	 mov	 DWORD PTR left$1$[rsp], r11d

; 1219 :             state->mode = LEN;

  014cd	41 c7 45 08 48
	3f 00 00	 mov	 DWORD PTR [r13+8], 16200 ; 00003f48H

; 1220 :             break;

  014d5	e9 a7 f2 ff ff	 jmp	 $LN8@inflate
$LN487@inflate:

; 1221 :         case CHECK:
; 1222 :             if (state->wrap) {

  014da	41 83 7d 10 00	 cmp	 DWORD PTR [r13+16], 0
  014df	0f 84 e7 00 00
	00		 je	 $LN941@inflate

; 1223 :                 NEEDBITS(32);

  014e5	83 fb 20	 cmp	 ebx, 32			; 00000020H
  014e8	73 26		 jae	 SHORT $LN307@inflate
  014ea	66 0f 1f 44 00
	00		 npad	 6
$LL310@inflate:
  014f0	85 f6		 test	 esi, esi
  014f2	0f 84 1f f4 ff
	ff		 je	 $LN938@inflate
  014f8	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  014fc	8b cb		 mov	 ecx, ebx
  014fe	d3 e0		 shl	 eax, cl
  01500	ff ce		 dec	 esi
  01502	44 03 f0	 add	 r14d, eax
  01505	48 ff c5	 inc	 rbp
  01508	83 c3 08	 add	 ebx, 8
  0150b	83 fb 20	 cmp	 ebx, 32			; 00000020H
  0150e	72 e0		 jb	 SHORT $LL310@inflate
$LN307@inflate:

; 1224 :                 out -= left;

  01510	45 2b c3	 sub	 r8d, r11d

; 1225 :                 strm->total_out += out;

  01513	45 01 44 24 1c	 add	 DWORD PTR [r12+28], r8d

; 1226 :                 state->total += out;

  01518	45 01 45 24	 add	 DWORD PTR [r13+36], r8d

; 1227 :                 if ((state->wrap & 4) && out)

  0151c	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  01521	74 38		 je	 SHORT $LN490@inflate
  01523	45 85 c0	 test	 r8d, r8d
  01526	74 33		 je	 SHORT $LN490@inflate

; 1228 :                     strm->adler = state->check =

  01528	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  0152c	49 8b d2	 mov	 rdx, r10
  0152f	41 8b c0	 mov	 eax, r8d
  01532	48 2b d0	 sub	 rdx, rax
  01535	41 83 7d 18 00	 cmp	 DWORD PTR [r13+24], 0
  0153a	74 07		 je	 SHORT $LN512@inflate
  0153c	e8 00 00 00 00	 call	 crc32
  01541	eb 05		 jmp	 SHORT $LN513@inflate
$LN512@inflate:
  01543	e8 00 00 00 00	 call	 adler32
$LN513@inflate:
  01548	4c 8b 54 24 40	 mov	 r10, QWORD PTR put$1$[rsp]
  0154d	44 8b 5c 24 30	 mov	 r11d, DWORD PTR left$1$[rsp]
  01552	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  01556	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax
$LN490@inflate:

; 1229 :                         UPDATE_CHECK(state->check, put - out, out);
; 1230 :                 out = left;
; 1231 :                 if ((state->wrap & 4) && (

  0155b	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  01560	41 8b fb	 mov	 edi, r11d
  01563	44 89 9c 24 a0
	00 00 00	 mov	 DWORD PTR out$1$[rsp], r11d
  0156b	74 4f		 je	 SHORT $LN317@inflate
  0156d	41 83 7d 18 00	 cmp	 DWORD PTR [r13+24], 0
  01572	41 8b ce	 mov	 ecx, r14d
  01575	75 26		 jne	 SHORT $LN515@inflate
  01577	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  0157d	41 8b c6	 mov	 eax, r14d
  01580	c1 e0 10	 shl	 eax, 16
  01583	03 c8		 add	 ecx, eax
  01585	41 8b c6	 mov	 eax, r14d
  01588	c1 e8 08	 shr	 eax, 8
  0158b	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  01590	c1 e1 08	 shl	 ecx, 8
  01593	03 c8		 add	 ecx, eax
  01595	41 8b c6	 mov	 eax, r14d
  01598	c1 e8 18	 shr	 eax, 24
  0159b	03 c8		 add	 ecx, eax
$LN515@inflate:
  0159d	41 3b 4d 20	 cmp	 ecx, DWORD PTR [r13+32]
  015a1	74 19		 je	 SHORT $LN317@inflate

; 1232 : #ifdef GUNZIP
; 1233 :                      state->flags ? hold :
; 1234 : #endif
; 1235 :                      ZSWAP32(hold)) != state->check) {
; 1236 :                     strm->msg = (char *)"incorrect data check";

  015a3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
  015aa	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1237 :                     state->mode = BAD;

  015af	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1238 :                     break;

  015b7	e9 c5 f1 ff ff	 jmp	 $LN8@inflate
$LN317@inflate:

; 1239 :                 }
; 1240 :                 INITBITS();

  015bc	45 8b f7	 mov	 r14d, r15d

; 1241 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1242 :             }
; 1243 : #ifdef GUNZIP
; 1244 :             state->mode = LENGTH;

  015bf	41 c7 45 08 4f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16207 ; 00003f4fH
  015c7	41 8b df	 mov	 ebx, r15d
  015ca	eb 18		 jmp	 SHORT $LN492@inflate
$LN941@inflate:

; 1221 :         case CHECK:
; 1222 :             if (state->wrap) {

  015cc	8b bc 24 a0 00
	00 00		 mov	 edi, DWORD PTR out$1$[rsp]

; 1241 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1242 :             }
; 1243 : #ifdef GUNZIP
; 1244 :             state->mode = LENGTH;

  015d3	41 c7 45 08 4f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16207 ; 00003f4fH
  015db	eb 07		 jmp	 SHORT $LN492@inflate
$LN940@inflate:

; 658  :     for (;;)
; 659  :         switch (state->mode) {

  015dd	8b bc 24 a0 00
	00 00		 mov	 edi, DWORD PTR out$1$[rsp]
$LN492@inflate:

; 1245 :                 /* fallthrough */
; 1246 :         case LENGTH:
; 1247 :             if (state->wrap && state->flags) {

  015e4	41 8b 55 10	 mov	 edx, DWORD PTR [r13+16]
  015e8	85 d2		 test	 edx, edx
  015ea	74 7b		 je	 SHORT $LN327@inflate
  015ec	41 83 7d 18 00	 cmp	 DWORD PTR [r13+24], 0
  015f1	74 74		 je	 SHORT $LN327@inflate

; 1248 :                 NEEDBITS(32);

  015f3	83 fb 20	 cmp	 ebx, 32			; 00000020H
  015f6	73 20		 jae	 SHORT $LN318@inflate
$LL321@inflate:
  015f8	85 f6		 test	 esi, esi
  015fa	0f 84 1e f3 ff
	ff		 je	 $LN942@inflate
  01600	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  01604	8b cb		 mov	 ecx, ebx
  01606	d3 e0		 shl	 eax, cl
  01608	ff ce		 dec	 esi
  0160a	44 03 f0	 add	 r14d, eax
  0160d	48 ff c5	 inc	 rbp
  01610	83 c3 08	 add	 ebx, 8
  01613	83 fb 20	 cmp	 ebx, 32			; 00000020H
  01616	72 e0		 jb	 SHORT $LL321@inflate
$LN318@inflate:

; 1249 :                 if ((state->wrap & 4) && hold != (state->total & 0xffffffff)) {

  01618	f6 c2 04	 test	 dl, 4
  0161b	74 44		 je	 SHORT $LN328@inflate
  0161d	45 3b 75 24	 cmp	 r14d, DWORD PTR [r13+36]
  01621	74 3e		 je	 SHORT $LN328@inflate

; 1250 :                     strm->msg = (char *)"incorrect length check";

  01623	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
  0162a	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1251 :                     state->mode = BAD;

  0162f	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  01637	e9 45 f1 ff ff	 jmp	 $LN8@inflate
$LN587@inflate:

; 856  :                 RESTORE();

  0163c	4d 89 54 24 10	 mov	 QWORD PTR [r12+16], r10

; 857  :                 return Z_NEED_DICT;

  01641	b8 02 00 00 00	 mov	 eax, 2
  01646	45 89 5c 24 18	 mov	 DWORD PTR [r12+24], r11d
  0164b	49 89 2c 24	 mov	 QWORD PTR [r12], rbp
  0164f	41 89 74 24 08	 mov	 DWORD PTR [r12+8], esi
  01654	45 89 75 48	 mov	 DWORD PTR [r13+72], r14d
  01658	41 89 5d 4c	 mov	 DWORD PTR [r13+76], ebx
  0165c	e9 20 01 00 00	 jmp	 $LN1@inflate
$LN328@inflate:

; 1252 :                     break;
; 1253 :                 }
; 1254 :                 INITBITS();

  01661	45 8b f7	 mov	 r14d, r15d
  01664	41 8b df	 mov	 ebx, r15d
$LN327@inflate:

; 1255 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1256 :             }
; 1257 : #endif
; 1258 :             state->mode = DONE;

  01667	41 c7 45 08 50
	3f 00 00	 mov	 DWORD PTR [r13+8], 16208 ; 00003f50H

; 1259 :                 /* fallthrough */
; 1260 :         case DONE:
; 1261 :             ret = Z_STREAM_END;

  0166f	41 bf 01 00 00
	00		 mov	 r15d, 1

; 1262 :             goto inf_leave;

  01675	e9 ac f2 ff ff	 jmp	 $LN977@inflate
$LN939@inflate:

; 658  :     for (;;)
; 659  :         switch (state->mode) {

  0167a	8b bc 24 a0 00
	00 00		 mov	 edi, DWORD PTR out$1$[rsp]

; 1259 :                 /* fallthrough */
; 1260 :         case DONE:
; 1261 :             ret = Z_STREAM_END;

  01681	41 bf 01 00 00
	00		 mov	 r15d, 1

; 1262 :             goto inf_leave;

  01687	e9 9a f2 ff ff	 jmp	 $LN977@inflate
$LN497@inflate:
  0168c	8b bc 24 a0 00
	00 00		 mov	 edi, DWORD PTR out$1$[rsp]

; 1263 :         case BAD:
; 1264 :             ret = Z_DATA_ERROR;

  01693	41 bf fd ff ff
	ff		 mov	 r15d, -3
  01699	e9 88 f2 ff ff	 jmp	 $LN977@inflate
$LN916@inflate:

; 1054 :                 state->mode = BAD;
; 1055 :                 break;
; 1056 :             }
; 1057 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1058 :             state->mode = LEN_;
; 1059 :             if (flush == Z_TREES) goto inf_leave;

  0169e	8b bc 24 a0 00
	00 00		 mov	 edi, DWORD PTR out$1$[rsp]
  016a5	e9 83 f2 ff ff	 jmp	 $inf_leave$981
$LN504@inflate:

; 1286 :             return Z_MEM_ERROR;
; 1287 :         }
; 1288 :     in -= strm->avail_in;
; 1289 :     out -= strm->avail_out;

  016aa	41 2b 7c 24 18	 sub	 edi, DWORD PTR [r12+24]
  016af	44 8b 54 24 3c	 mov	 r10d, DWORD PTR in$1$[rsp]
  016b4	45 2b 54 24 08	 sub	 r10d, DWORD PTR [r12+8]

; 1290 :     strm->total_in += in;

  016b9	45 01 54 24 0c	 add	 DWORD PTR [r12+12], r10d

; 1291 :     strm->total_out += out;

  016be	41 01 7c 24 1c	 add	 DWORD PTR [r12+28], edi

; 1292 :     state->total += out;

  016c3	41 01 7d 24	 add	 DWORD PTR [r13+36], edi

; 1293 :     if ((state->wrap & 4) && out)

  016c7	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  016cc	44 89 54 24 3c	 mov	 DWORD PTR in$1$[rsp], r10d
  016d1	74 36		 je	 SHORT $LN505@inflate
  016d3	85 ff		 test	 edi, edi
  016d5	74 32		 je	 SHORT $LN505@inflate

; 1294 :         strm->adler = state->check =

  016d7	49 8b 54 24 10	 mov	 rdx, QWORD PTR [r12+16]
  016dc	44 8b c7	 mov	 r8d, edi
  016df	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  016e3	8b c7		 mov	 eax, edi
  016e5	48 2b d0	 sub	 rdx, rax
  016e8	41 83 7d 18 00	 cmp	 DWORD PTR [r13+24], 0
  016ed	74 07		 je	 SHORT $LN516@inflate
  016ef	e8 00 00 00 00	 call	 crc32
  016f4	eb 05		 jmp	 SHORT $LN517@inflate
$LN516@inflate:
  016f6	e8 00 00 00 00	 call	 adler32
$LN517@inflate:
  016fb	44 8b 54 24 3c	 mov	 r10d, DWORD PTR in$1$[rsp]
  01700	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  01704	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax
$LN505@inflate:

; 1295 :             UPDATE_CHECK(state->check, strm->next_out - out, out);
; 1296 :     strm->data_type = (int)state->bits + (state->last ? 64 : 0) +

  01709	41 8b 55 08	 mov	 edx, DWORD PTR [r13+8]
  0170d	81 fa 47 3f 00
	00		 cmp	 edx, 16199		; 00003f47H
  01713	74 10		 je	 SHORT $LN518@inflate
  01715	81 fa 42 3f 00
	00		 cmp	 edx, 16194		; 00003f42H
  0171b	74 08		 je	 SHORT $LN518@inflate
  0171d	45 33 c9	 xor	 r9d, r9d
  01720	45 8b c1	 mov	 r8d, r9d
  01723	eb 09		 jmp	 SHORT $LN519@inflate
$LN518@inflate:
  01725	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0172b	45 33 c9	 xor	 r9d, r9d
$LN519@inflate:
  0172e	41 8b 45 0c	 mov	 eax, DWORD PTR [r13+12]
  01732	f7 d8		 neg	 eax
  01734	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  01739	1b c9		 sbb	 ecx, ecx
  0173b	83 e1 40	 and	 ecx, 64			; 00000040H
  0173e	81 fa 3f 3f 00
	00		 cmp	 edx, 16191		; 00003f3fH
  01744	44 0f 44 c8	 cmove	 r9d, eax
  01748	41 8d 04 08	 lea	 eax, DWORD PTR [r8+rcx]
  0174c	44 03 c8	 add	 r9d, eax
  0174f	45 03 4d 4c	 add	 r9d, DWORD PTR [r13+76]
  01753	45 89 4c 24 48	 mov	 DWORD PTR [r12+72], r9d

; 1297 :                       (state->mode == TYPE ? 128 : 0) +
; 1298 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
; 1299 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  01758	45 85 d2	 test	 r10d, r10d
  0175b	75 04		 jne	 SHORT $LN508@inflate
  0175d	85 ff		 test	 edi, edi
  0175f	74 0a		 je	 SHORT $LN507@inflate
$LN508@inflate:
  01761	83 bc 24 98 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  01769	75 0c		 jne	 SHORT $LN506@inflate
$LN507@inflate:
  0176b	45 85 ff	 test	 r15d, r15d
  0176e	b8 fb ff ff ff	 mov	 eax, -5
  01773	44 0f 44 f8	 cmove	 r15d, eax
$LN506@inflate:

; 1300 :         ret = Z_BUF_ERROR;
; 1301 :     return ret;

  01777	41 8b c7	 mov	 eax, r15d
  0177a	eb 05		 jmp	 SHORT $LN1@inflate
$LN333@inflate:

; 649  :         (strm->next_in == Z_NULL && strm->avail_in != 0))
; 650  :         return Z_STREAM_ERROR;

  0177c	b8 fe ff ff ff	 mov	 eax, -2
$LN1@inflate:

; 1302 : }

  01781	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  01789	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0178d	41 5f		 pop	 r15
  0178f	41 5e		 pop	 r14
  01791	41 5d		 pop	 r13
  01793	41 5c		 pop	 r12
  01795	5f		 pop	 rdi
  01796	5e		 pop	 rsi
  01797	5d		 pop	 rbp
  01798	c3		 ret	 0
  01799	0f 1f 00	 npad	 3
$LN820@inflate:
  0179c	00 00 00 00	 DD	 $LN335@inflate
  017a0	00 00 00 00	 DD	 $LN32@inflate
  017a4	00 00 00 00	 DD	 $LN46@inflate
  017a8	00 00 00 00	 DD	 $LN60@inflate
  017ac	00 00 00 00	 DD	 $LN361@inflate
  017b0	00 00 00 00	 DD	 $LN368@inflate
  017b4	00 00 00 00	 DD	 $LN375@inflate
  017b8	00 00 00 00	 DD	 $LN384@inflate
  017bc	00 00 00 00	 DD	 $LN393@inflate
  017c0	00 00 00 00	 DD	 $LN105@inflate
  017c4	00 00 00 00	 DD	 $LN400@inflate
  017c8	00 00 00 00	 DD	 $LN402@inflate
  017cc	00 00 00 00	 DD	 $LN403@inflate
  017d0	00 00 00 00	 DD	 $LN141@inflate
  017d4	00 00 00 00	 DD	 $LN416@inflate
  017d8	00 00 00 00	 DD	 $LN418@inflate
  017dc	00 00 00 00	 DD	 $LN155@inflate
  017e0	00 00 00 00	 DD	 $LN533@inflate
  017e4	00 00 00 00	 DD	 $LN536@inflate
  017e8	00 00 00 00	 DD	 $LN448@inflate
  017ec	00 00 00 00	 DD	 $LN450@inflate
  017f0	00 00 00 00	 DD	 $LN461@inflate
  017f4	00 00 00 00	 DD	 $LN464@inflate
  017f8	00 00 00 00	 DD	 $LN471@inflate
  017fc	00 00 00 00	 DD	 $LN474@inflate
  01800	00 00 00 00	 DD	 $LN485@inflate
  01804	00 00 00 00	 DD	 $LN487@inflate
  01808	00 00 00 00	 DD	 $LN940@inflate
  0180c	00 00 00 00	 DD	 $LN939@inflate
  01810	00 00 00 00	 DD	 $LN497@inflate
  01814	00 00 00 00	 DD	 $LN498@inflate
  01818	00 00 00 00	 DD	 $LN333@inflate
inflate	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT inflateEnd
_TEXT	SEGMENT
strm$ = 48
inflateEnd PROC						; COMDAT

; 1306 : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1307 :     struct inflate_state FAR *state;
; 1308 :     if (inflateStateCheck(strm))

  00009	e8 00 00 00 00	 call	 inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0b		 je	 SHORT $LN2@inflateEnd

; 1309 :         return Z_STREAM_ERROR;

  00012	b8 fe ff ff ff	 mov	 eax, -2

; 1316 : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5b		 pop	 rbx
  0001c	c3		 ret	 0
$LN2@inflateEnd:

; 1310 :     state = (struct inflate_state FAR *)strm->state;
; 1311 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  0001d	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00021	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00026	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0002b	48 8b 50 40	 mov	 rdx, QWORD PTR [rax+64]
  0002f	48 85 d2	 test	 rdx, rdx
  00032	74 07		 je	 SHORT $LN5@inflateEnd
  00034	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00038	ff 53 38	 call	 QWORD PTR [rbx+56]
$LN5@inflateEnd:

; 1312 :     ZFREE(strm, strm->state);

  0003b	48 8b 53 28	 mov	 rdx, QWORD PTR [rbx+40]
  0003f	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00043	ff 53 38	 call	 QWORD PTR [rbx+56]

; 1313 :     strm->state = Z_NULL;
; 1314 :     Tracev((stderr, "inflate: end\n"));
; 1315 :     return Z_OK;

  00046	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  0004b	33 c0		 xor	 eax, eax
  0004d	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00052	48 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [rbx+40], 0

; 1316 : }

  0005a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005e	5b		 pop	 rbx
  0005f	c3		 ret	 0
inflateEnd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT inflateStateCheck
_TEXT	SEGMENT
strm$ = 8
inflateStateCheck PROC					; COMDAT

; 108  :     struct inflate_state FAR *state;
; 109  :     if (strm == Z_NULL ||
; 110  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 2c		 je	 SHORT $LN3@inflateSta
  00005	48 83 79 30 00	 cmp	 QWORD PTR [rcx+48], 0
  0000a	74 25		 je	 SHORT $LN3@inflateSta
  0000c	48 83 79 38 00	 cmp	 QWORD PTR [rcx+56], 0
  00011	74 1e		 je	 SHORT $LN3@inflateSta

; 112  :     state = (struct inflate_state FAR *)strm->state;

  00013	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 113  :     if (state == Z_NULL || state->strm != strm ||
; 114  :         state->mode < HEAD || state->mode > SYNC)

  00017	48 85 c0	 test	 rax, rax
  0001a	74 15		 je	 SHORT $LN3@inflateSta
  0001c	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0001f	75 10		 jne	 SHORT $LN3@inflateSta
  00021	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00024	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  00029	83 f8 1f	 cmp	 eax, 31
  0002c	77 03		 ja	 SHORT $LN3@inflateSta

; 115  :         return 1;
; 116  :     return 0;

  0002e	33 c0		 xor	 eax, eax

; 117  : }

  00030	c3		 ret	 0
$LN3@inflateSta:

; 111  :         return 1;

  00031	b8 01 00 00 00	 mov	 eax, 1

; 117  : }

  00036	c3		 ret	 0
inflateStateCheck ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT inflateResetKeep
_TEXT	SEGMENT
strm$ = 48
inflateResetKeep PROC					; COMDAT

; 121  : {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8b d1	 mov	 rdx, rcx

; 122  :     struct inflate_state FAR *state;
; 123  : 
; 124  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00007	e8 00 00 00 00	 call	 inflateStateCheck
  0000c	85 c0		 test	 eax, eax
  0000e	74 0a		 je	 SHORT $LN2@inflateRes
  00010	b8 fe ff ff ff	 mov	 eax, -2

; 143  : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
$LN2@inflateRes:

; 125  :     state = (struct inflate_state FAR *)strm->state;

  0001a	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]

; 126  :     strm->total_in = strm->total_out = state->total = 0;

  0001e	45 33 c0	 xor	 r8d, r8d
  00021	44 89 41 24	 mov	 DWORD PTR [rcx+36], r8d
  00025	44 89 42 1c	 mov	 DWORD PTR [rdx+28], r8d
  00029	44 89 42 0c	 mov	 DWORD PTR [rdx+12], r8d

; 127  :     strm->msg = Z_NULL;

  0002d	4c 89 42 20	 mov	 QWORD PTR [rdx+32], r8

; 128  :     if (state->wrap)        /* to support ill-conceived Java test suite */

  00031	8b 41 10	 mov	 eax, DWORD PTR [rcx+16]
  00034	85 c0		 test	 eax, eax
  00036	74 06		 je	 SHORT $LN3@inflateRes

; 129  :         strm->adler = state->wrap & 1;

  00038	83 e0 01	 and	 eax, 1
  0003b	89 42 4c	 mov	 DWORD PTR [rdx+76], eax
$LN3@inflateRes:

; 130  :     state->mode = HEAD;
; 131  :     state->last = 0;
; 132  :     state->havedict = 0;
; 133  :     state->flags = -1;
; 134  :     state->dmax = 32768U;
; 135  :     state->head = Z_NULL;
; 136  :     state->hold = 0;
; 137  :     state->bits = 0;
; 138  :     state->lencode = state->distcode = state->next = state->codes;

  0003e	48 8d 81 50 05
	00 00		 lea	 rax, QWORD PTR [rcx+1360]
  00045	48 c7 41 08 34
	3f 00 00	 mov	 QWORD PTR [rcx+8], 16180 ; 00003f34H
  0004d	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  00054	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00058	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 139  :     state->sane = 1;
; 140  :     state->back = -1;
; 141  :     Tracev((stderr, "inflate: reset\n"));
; 142  :     return Z_OK;

  0005c	33 c0		 xor	 eax, eax
  0005e	44 89 41 14	 mov	 DWORD PTR [rcx+20], r8d
  00062	c7 41 18 ff ff
	ff ff		 mov	 DWORD PTR [rcx+24], -1
  00069	c7 41 1c 00 80
	00 00		 mov	 DWORD PTR [rcx+28], 32768 ; 00008000H
  00070	4c 89 41 28	 mov	 QWORD PTR [rcx+40], r8
  00074	4c 89 41 48	 mov	 QWORD PTR [rcx+72], r8
  00078	c7 81 e0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rcx+7136], 1
  00082	c7 81 e4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [rcx+7140], -1

; 143  : }

  0008c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00090	c3		 ret	 0
inflateResetKeep ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT inflateReset2
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
inflateReset2 PROC					; COMDAT

; 161  : {

$LN15:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	8b da		 mov	 ebx, edx
  00016	48 8b e9	 mov	 rbp, rcx

; 162  :     int wrap;
; 163  :     struct inflate_state FAR *state;
; 164  : 
; 165  :     /* get the state */
; 166  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00019	e8 00 00 00 00	 call	 inflateStateCheck
  0001e	85 c0		 test	 eax, eax
  00020	75 5c		 jne	 SHORT $LN8@inflateRes

; 167  :     state = (struct inflate_state FAR *)strm->state;

  00022	48 8b 71 28	 mov	 rsi, QWORD PTR [rcx+40]

; 168  : 
; 169  :     /* extract wrap request from windowBits parameter */
; 170  :     if (windowBits < 0) {

  00026	85 d2		 test	 edx, edx
  00028	79 0b		 jns	 SHORT $LN3@inflateRes

; 171  :         if (windowBits < -15)

  0002a	83 fa f1	 cmp	 edx, -15
  0002d	7c 4f		 jl	 SHORT $LN8@inflateRes

; 172  :             return Z_STREAM_ERROR;
; 173  :         wrap = 0;

  0002f	33 ff		 xor	 edi, edi

; 174  :         windowBits = -windowBits;

  00031	f7 db		 neg	 ebx

; 175  :     }

  00033	eb 10		 jmp	 SHORT $LN6@inflateRes
$LN3@inflateRes:

; 176  :     else {
; 177  :         wrap = (windowBits >> 4) + 5;

  00035	8b fb		 mov	 edi, ebx
  00037	c1 ef 04	 shr	 edi, 4
  0003a	83 c7 05	 add	 edi, 5

; 178  : #ifdef GUNZIP
; 179  :         if (windowBits < 48)

  0003d	83 fb 30	 cmp	 ebx, 48			; 00000030H
  00040	7d 03		 jge	 SHORT $LN6@inflateRes

; 180  :             windowBits &= 15;

  00042	83 e3 0f	 and	 ebx, 15
$LN6@inflateRes:

; 181  : #endif
; 182  :     }
; 183  : 
; 184  :     /* set number of window bits, free window if different */
; 185  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  00045	85 db		 test	 ebx, ebx
  00047	74 08		 je	 SHORT $LN7@inflateRes
  00049	8d 43 f8	 lea	 eax, DWORD PTR [rbx-8]
  0004c	83 f8 07	 cmp	 eax, 7
  0004f	77 2d		 ja	 SHORT $LN8@inflateRes
$LN7@inflateRes:

; 187  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  00051	48 8b 56 40	 mov	 rdx, QWORD PTR [rsi+64]
  00055	48 85 d2	 test	 rdx, rdx
  00058	74 14		 je	 SHORT $LN9@inflateRes
  0005a	39 5e 30	 cmp	 DWORD PTR [rsi+48], ebx
  0005d	74 0f		 je	 SHORT $LN9@inflateRes

; 188  :         ZFREE(strm, state->window);

  0005f	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00063	ff 55 38	 call	 QWORD PTR [rbp+56]

; 189  :         state->window = Z_NULL;

  00066	48 c7 46 40 00
	00 00 00	 mov	 QWORD PTR [rsi+64], 0
$LN9@inflateRes:

; 190  :     }
; 191  : 
; 192  :     /* update state and reset the rest of it */
; 193  :     state->wrap = wrap;
; 194  :     state->wbits = (unsigned)windowBits;
; 195  :     return inflateReset(strm);

  0006e	48 8b cd	 mov	 rcx, rbp
  00071	89 7e 10	 mov	 DWORD PTR [rsi+16], edi
  00074	89 5e 30	 mov	 DWORD PTR [rsi+48], ebx
  00077	e8 00 00 00 00	 call	 inflateReset
  0007c	eb 05		 jmp	 SHORT $LN1@inflateRes
$LN8@inflateRes:

; 186  :         return Z_STREAM_ERROR;

  0007e	b8 fe ff ff ff	 mov	 eax, -2
$LN1@inflateRes:

; 196  : }

  00083	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00088	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0008d	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00092	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00096	5f		 pop	 rdi
  00097	c3		 ret	 0
inflateReset2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT inflateInit_
_TEXT	SEGMENT
strm$ = 8
version$ = 16
stream_size$ = 24
inflateInit_ PROC					; COMDAT

; 247  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00000	45 8b c8	 mov	 r9d, r8d
  00003	4c 8b c2	 mov	 r8, rdx
  00006	ba 0f 00 00 00	 mov	 edx, 15
  0000b	e9 00 00 00 00	 jmp	 inflateInit2_
inflateInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT inflatePrime
_TEXT	SEGMENT
strm$ = 48
bits$ = 56
value$ = 64
inflatePrime PROC					; COMDAT

; 254  : {

$LN9:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	45 8b d8	 mov	 r11d, r8d

; 255  :     struct inflate_state FAR *state;
; 256  : 
; 257  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00007	e8 00 00 00 00	 call	 inflateStateCheck
  0000c	85 c0		 test	 eax, eax
  0000e	75 46		 jne	 SHORT $LN5@inflatePri

; 258  :     state = (struct inflate_state FAR *)strm->state;

  00010	4c 8b 49 28	 mov	 r9, QWORD PTR [rcx+40]

; 259  :     if (bits < 0) {

  00014	85 d2		 test	 edx, edx
  00016	79 09		 jns	 SHORT $LN3@inflatePri

; 260  :         state->hold = 0;

  00018	49 89 41 48	 mov	 QWORD PTR [r9+72], rax

; 269  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
$LN3@inflatePri:

; 261  :         state->bits = 0;
; 262  :         return Z_OK;
; 263  :     }
; 264  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  00021	83 fa 10	 cmp	 edx, 16
  00024	7f 30		 jg	 SHORT $LN5@inflatePri
  00026	45 8b 41 4c	 mov	 r8d, DWORD PTR [r9+76]
  0002a	45 8d 14 10	 lea	 r10d, DWORD PTR [r8+rdx]
  0002e	41 83 fa 20	 cmp	 r10d, 32		; 00000020H
  00032	77 22		 ja	 SHORT $LN5@inflatePri

; 265  :     value &= (1L << bits) - 1;

  00034	8b ca		 mov	 ecx, edx

; 266  :     state->hold += (unsigned)value << state->bits;
; 267  :     state->bits += (uInt)bits;

  00036	45 89 51 4c	 mov	 DWORD PTR [r9+76], r10d
  0003a	b8 01 00 00 00	 mov	 eax, 1
  0003f	d3 e0		 shl	 eax, cl
  00041	41 8b c8	 mov	 ecx, r8d
  00044	ff c8		 dec	 eax
  00046	41 23 c3	 and	 eax, r11d
  00049	d3 e0		 shl	 eax, cl
  0004b	41 01 41 48	 add	 DWORD PTR [r9+72], eax

; 268  :     return Z_OK;

  0004f	33 c0		 xor	 eax, eax

; 269  : }

  00051	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00055	c3		 ret	 0
$LN5@inflatePri:

; 261  :         state->bits = 0;
; 262  :         return Z_OK;
; 263  :     }
; 264  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  00056	b8 fe ff ff ff	 mov	 eax, -2

; 269  : }

  0005b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005f	c3		 ret	 0
inflatePrime ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 8
fixedtables PROC					; COMDAT

; 284  : #ifdef BUILDFIXED
; 285  :     static int virgin = 1;
; 286  :     static code *lenfix, *distfix;
; 287  :     static code fixed[544];
; 288  : 
; 289  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 290  :     if (virgin) {
; 291  :         unsigned sym, bits;
; 292  :         static code *next;
; 293  : 
; 294  :         /* literal/length table */
; 295  :         sym = 0;
; 296  :         while (sym < 144) state->lens[sym++] = 8;
; 297  :         while (sym < 256) state->lens[sym++] = 9;
; 298  :         while (sym < 280) state->lens[sym++] = 7;
; 299  :         while (sym < 288) state->lens[sym++] = 8;
; 300  :         next = fixed;
; 301  :         lenfix = next;
; 302  :         bits = 9;
; 303  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 304  : 
; 305  :         /* distance table */
; 306  :         sym = 0;
; 307  :         while (sym < 32) state->lens[sym++] = 5;
; 308  :         distfix = next;
; 309  :         bits = 5;
; 310  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 311  : 
; 312  :         /* do this just once */
; 313  :         virgin = 0;
; 314  :     }
; 315  : #else /* !BUILDFIXED */
; 316  : #   include "inffixed.h"
; 317  : #endif /* BUILDFIXED */
; 318  :     state->lencode = lenfix;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9

; 319  :     state->lenbits = 9;

  00007	c7 41 70 09 00
	00 00		 mov	 DWORD PTR [rcx+112], 9
  0000e	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 320  :     state->distcode = distfix;

  00012	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  00019	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 321  :     state->distbits = 5;

  0001d	c7 41 74 05 00
	00 00		 mov	 DWORD PTR [rcx+116], 5

; 322  : }

  00024	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT updatewindow
_TEXT	SEGMENT
strm$ = 64
end$ = 72
copy$ = 80
updatewindow PROC					; COMDAT

; 403  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	41 56		 push	 r14
  00009	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 404  :     struct inflate_state FAR *state;
; 405  :     unsigned dist;
; 406  : 
; 407  :     state = (struct inflate_state FAR *)strm->state;

  0000d	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]
  00011	48 8b f2	 mov	 rsi, rdx
  00014	41 8b e8	 mov	 ebp, r8d
  00017	4c 8b d1	 mov	 r10, rcx

; 408  : 
; 409  :     /* if it hasn't been done already, allocate space for the window */
; 410  :     if (state->window == Z_NULL) {

  0001a	4c 8b 4b 40	 mov	 r9, QWORD PTR [rbx+64]
  0001e	4d 85 c9	 test	 r9, r9
  00021	75 34		 jne	 SHORT $LN14@updatewind

; 411  :         state->window = (unsigned char FAR *)

  00023	8b 4b 30	 mov	 ecx, DWORD PTR [rbx+48]
  00026	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  0002a	ba 01 00 00 00	 mov	 edx, 1
  0002f	d3 e2		 shl	 edx, cl
  00031	49 8b 4a 40	 mov	 rcx, QWORD PTR [r10+64]
  00035	41 ff 52 30	 call	 QWORD PTR [r10+48]
  00039	48 89 43 40	 mov	 QWORD PTR [rbx+64], rax
  0003d	4c 8b c8	 mov	 r9, rax

; 412  :                         ZALLOC(strm, 1U << state->wbits,
; 413  :                                sizeof(unsigned char));
; 414  :         if (state->window == Z_NULL) return 1;

  00040	48 85 c0	 test	 rax, rax
  00043	75 12		 jne	 SHORT $LN14@updatewind
  00045	41 8d 41 01	 lea	 eax, QWORD PTR [r9+1]

; 447  : }

  00049	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0004e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00052	41 5e		 pop	 r14
  00054	5e		 pop	 rsi
  00055	5d		 pop	 rbp
  00056	c3		 ret	 0
$LN14@updatewind:
  00057	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi

; 415  :     }
; 416  : 
; 417  :     /* if window not in use yet, initialize */
; 418  :     if (state->wsize == 0) {

  0005c	8b 7b 34	 mov	 edi, DWORD PTR [rbx+52]
  0005f	4c 89 7c 24 48	 mov	 QWORD PTR [rsp+72], r15
  00064	45 33 ff	 xor	 r15d, r15d
  00067	85 ff		 test	 edi, edi
  00069	75 11		 jne	 SHORT $LN15@updatewind

; 419  :         state->wsize = 1U << state->wbits;

  0006b	8b 4b 30	 mov	 ecx, DWORD PTR [rbx+48]
  0006e	bf 01 00 00 00	 mov	 edi, 1
  00073	d3 e7		 shl	 edi, cl
  00075	89 7b 34	 mov	 DWORD PTR [rbx+52], edi

; 420  :         state->wnext = 0;
; 421  :         state->whave = 0;

  00078	4c 89 7b 38	 mov	 QWORD PTR [rbx+56], r15
$LN15@updatewind:

; 422  :     }
; 423  : 
; 424  :     /* copy state->wsize or less output bytes into the circular window */
; 425  :     if (copy >= state->wsize) {

  0007c	3b ef		 cmp	 ebp, edi
  0007e	72 1a		 jb	 SHORT $LN5@updatewind

; 426  :         zmemcpy(state->window, end - state->wsize, state->wsize);

  00080	44 8b c7	 mov	 r8d, edi
  00083	49 8b c9	 mov	 rcx, r9
  00086	49 2b f0	 sub	 rsi, r8
  00089	48 8b d6	 mov	 rdx, rsi
  0008c	e8 00 00 00 00	 call	 memcpy

; 427  :         state->wnext = 0;
; 428  :         state->whave = state->wsize;

  00091	8b 43 34	 mov	 eax, DWORD PTR [rbx+52]
  00094	44 89 7b 3c	 mov	 DWORD PTR [rbx+60], r15d

; 429  :     }

  00098	eb 53		 jmp	 SHORT $LN17@updatewind
$LN5@updatewind:

; 430  :     else {
; 431  :         dist = state->wsize - state->wnext;

  0009a	8b 4b 3c	 mov	 ecx, DWORD PTR [rbx+60]

; 432  :         if (dist > copy) dist = copy;
; 433  :         zmemcpy(state->window + state->wnext, end - copy, dist);

  0009d	48 8b d6	 mov	 rdx, rsi
  000a0	2b f9		 sub	 edi, ecx
  000a2	3b fd		 cmp	 edi, ebp
  000a4	0f 47 fd	 cmova	 edi, ebp
  000a7	48 2b d5	 sub	 rdx, rbp
  000aa	44 8b c7	 mov	 r8d, edi
  000ad	49 03 c9	 add	 rcx, r9
  000b0	e8 00 00 00 00	 call	 memcpy

; 434  :         copy -= dist;

  000b5	2b ef		 sub	 ebp, edi

; 435  :         if (copy) {

  000b7	74 1a		 je	 SHORT $LN8@updatewind

; 436  :             zmemcpy(state->window, end - copy, copy);

  000b9	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000bd	44 8b c5	 mov	 r8d, ebp
  000c0	49 2b f0	 sub	 rsi, r8
  000c3	48 8b d6	 mov	 rdx, rsi
  000c6	e8 00 00 00 00	 call	 memcpy

; 437  :             state->wnext = copy;
; 438  :             state->whave = state->wsize;

  000cb	8b 43 34	 mov	 eax, DWORD PTR [rbx+52]
  000ce	89 6b 3c	 mov	 DWORD PTR [rbx+60], ebp

; 439  :         }

  000d1	eb 1a		 jmp	 SHORT $LN17@updatewind
$LN8@updatewind:

; 440  :         else {
; 441  :             state->wnext += dist;

  000d3	8b 4b 3c	 mov	 ecx, DWORD PTR [rbx+60]
  000d6	03 cf		 add	 ecx, edi

; 442  :             if (state->wnext == state->wsize) state->wnext = 0;

  000d8	3b 4b 34	 cmp	 ecx, DWORD PTR [rbx+52]
  000db	41 0f 44 cf	 cmove	 ecx, r15d
  000df	89 4b 3c	 mov	 DWORD PTR [rbx+60], ecx

; 443  :             if (state->whave < state->wsize) state->whave += dist;

  000e2	8b 4b 38	 mov	 ecx, DWORD PTR [rbx+56]
  000e5	3b 4b 34	 cmp	 ecx, DWORD PTR [rbx+52]
  000e8	73 06		 jae	 SHORT $LN11@updatewind
  000ea	8d 04 39	 lea	 eax, DWORD PTR [rcx+rdi]
$LN17@updatewind:

; 444  :         }
; 445  :     }
; 446  :     return 0;

  000ed	89 43 38	 mov	 DWORD PTR [rbx+56], eax
$LN11@updatewind:
  000f0	4c 8b 7c 24 48	 mov	 r15, QWORD PTR [rsp+72]
  000f5	33 c0		 xor	 eax, eax
  000f7	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 447  : }

  000fc	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00101	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00105	41 5e		 pop	 r14
  00107	5e		 pop	 rsi
  00108	5d		 pop	 rbp
  00109	c3		 ret	 0
updatewindow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT inflateGetDictionary
_TEXT	SEGMENT
strm$ = 48
dictionary$ = 56
dictLength$ = 64
inflateGetDictionary PROC				; COMDAT

; 1322 : {

$LN7:
  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b f8	 mov	 rdi, r8
  0000d	48 8b f2	 mov	 rsi, rdx

; 1323 :     struct inflate_state FAR *state;
; 1324 : 
; 1325 :     /* check state */
; 1326 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00010	e8 00 00 00 00	 call	 inflateStateCheck
  00015	85 c0		 test	 eax, eax
  00017	74 10		 je	 SHORT $LN2@inflateGet
  00019	b8 fe ff ff ff	 mov	 eax, -2

; 1339 : }

  0001e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5f		 pop	 rdi
  00028	c3		 ret	 0
$LN2@inflateGet:
  00029	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 1327 :     state = (struct inflate_state FAR *)strm->state;

  0002e	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]

; 1328 : 
; 1329 :     /* copy dictionary */
; 1330 :     if (state->whave && dictionary != Z_NULL) {

  00032	8b 43 38	 mov	 eax, DWORD PTR [rbx+56]
  00035	85 c0		 test	 eax, eax
  00037	74 2f		 je	 SHORT $LN3@inflateGet
  00039	48 85 f6	 test	 rsi, rsi
  0003c	74 2a		 je	 SHORT $LN3@inflateGet

; 1331 :         zmemcpy(dictionary, state->window + state->wnext,

  0003e	8b 53 3c	 mov	 edx, DWORD PTR [rbx+60]
  00041	48 8b ce	 mov	 rcx, rsi
  00044	2b c2		 sub	 eax, edx
  00046	48 03 53 40	 add	 rdx, QWORD PTR [rbx+64]
  0004a	44 8b c0	 mov	 r8d, eax
  0004d	e8 00 00 00 00	 call	 memcpy

; 1332 :                 state->whave - state->wnext);
; 1333 :         zmemcpy(dictionary + state->whave - state->wnext,

  00052	44 8b 43 3c	 mov	 r8d, DWORD PTR [rbx+60]
  00056	8b 4b 38	 mov	 ecx, DWORD PTR [rbx+56]
  00059	48 8b 53 40	 mov	 rdx, QWORD PTR [rbx+64]
  0005d	49 2b c8	 sub	 rcx, r8
  00060	48 03 ce	 add	 rcx, rsi
  00063	e8 00 00 00 00	 call	 memcpy
$LN3@inflateGet:

; 1334 :                 state->window, state->wnext);
; 1335 :     }
; 1336 :     if (dictLength != Z_NULL)

  00068	48 85 ff	 test	 rdi, rdi
  0006b	74 05		 je	 SHORT $LN4@inflateGet

; 1337 :         *dictLength = state->whave;

  0006d	8b 43 38	 mov	 eax, DWORD PTR [rbx+56]
  00070	89 07		 mov	 DWORD PTR [rdi], eax
$LN4@inflateGet:

; 1338 :     return Z_OK;

  00072	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00077	33 c0		 xor	 eax, eax

; 1339 : }

  00079	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00082	5f		 pop	 rdi
  00083	c3		 ret	 0
inflateGetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT inflateSetDictionary
_TEXT	SEGMENT
strm$ = 48
dictionary$ = 56
dictLength$ = 64
inflateSetDictionary PROC				; COMDAT

; 1345 : {

$LN13:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 56		 push	 r14
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	41 8b e8	 mov	 ebp, r8d
  0001d	4c 8b f2	 mov	 r14, rdx
  00020	48 8b f1	 mov	 rsi, rcx

; 1346 :     struct inflate_state FAR *state;
; 1347 :     unsigned long dictid;
; 1348 :     int ret;
; 1349 : 
; 1350 :     /* check state */
; 1351 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00023	e8 00 00 00 00	 call	 inflateStateCheck
  00028	85 c0		 test	 eax, eax
  0002a	75 6c		 jne	 SHORT $LN10@inflateSet

; 1352 :     state = (struct inflate_state FAR *)strm->state;

  0002c	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]

; 1353 :     if (state->wrap != 0 && state->mode != DICT)

  00030	39 47 10	 cmp	 DWORD PTR [rdi+16], eax
  00033	74 09		 je	 SHORT $LN9@inflateSet
  00035	81 7f 08 3e 3f
	00 00		 cmp	 DWORD PTR [rdi+8], 16190 ; 00003f3eH
  0003c	75 5a		 jne	 SHORT $LN10@inflateSet
$LN9@inflateSet:

; 1355 : 
; 1356 :     /* check for correct dictionary identifier */
; 1357 :     if (state->mode == DICT) {

  0003e	81 7f 08 3e 3f
	00 00		 cmp	 DWORD PTR [rdi+8], 16190 ; 00003f3eH
  00045	75 25		 jne	 SHORT $LN5@inflateSet

; 1358 :         dictid = adler32(0L, Z_NULL, 0);

  00047	45 33 c0	 xor	 r8d, r8d
  0004a	33 d2		 xor	 edx, edx
  0004c	33 c9		 xor	 ecx, ecx
  0004e	e8 00 00 00 00	 call	 adler32

; 1359 :         dictid = adler32(dictid, dictionary, dictLength);

  00053	44 8b c5	 mov	 r8d, ebp
  00056	49 8b d6	 mov	 rdx, r14
  00059	8b c8		 mov	 ecx, eax
  0005b	e8 00 00 00 00	 call	 adler32

; 1360 :         if (dictid != state->check)

  00060	3b 47 20	 cmp	 eax, DWORD PTR [rdi+32]
  00063	74 07		 je	 SHORT $LN5@inflateSet

; 1361 :             return Z_DATA_ERROR;

  00065	b8 fd ff ff ff	 mov	 eax, -3
  0006a	eb 31		 jmp	 SHORT $LN1@inflateSet
$LN5@inflateSet:

; 1362 :     }
; 1363 : 
; 1364 :     /* copy dictionary to window using updatewindow(), which will amend the
; 1365 :        existing dictionary if appropriate */
; 1366 :     ret = updatewindow(strm, dictionary + dictLength, dictLength);

  0006c	49 8d 14 2e	 lea	 rdx, QWORD PTR [r14+rbp]
  00070	44 8b c5	 mov	 r8d, ebp
  00073	48 8b ce	 mov	 rcx, rsi
  00076	e8 00 00 00 00	 call	 updatewindow

; 1367 :     if (ret) {

  0007b	85 c0		 test	 eax, eax
  0007d	74 0e		 je	 SHORT $LN6@inflateSet

; 1368 :         state->mode = MEM;

  0007f	c7 47 08 52 3f
	00 00		 mov	 DWORD PTR [rdi+8], 16210 ; 00003f52H

; 1369 :         return Z_MEM_ERROR;

  00086	b8 fc ff ff ff	 mov	 eax, -4
  0008b	eb 10		 jmp	 SHORT $LN1@inflateSet
$LN6@inflateSet:

; 1370 :     }
; 1371 :     state->havedict = 1;

  0008d	c7 47 14 01 00
	00 00		 mov	 DWORD PTR [rdi+20], 1

; 1372 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1373 :     return Z_OK;

  00094	33 c0		 xor	 eax, eax
  00096	eb 05		 jmp	 SHORT $LN1@inflateSet
$LN10@inflateSet:

; 1354 :         return Z_STREAM_ERROR;

  00098	b8 fe ff ff ff	 mov	 eax, -2
$LN1@inflateSet:

; 1374 : }

  0009d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a2	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000a7	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000ac	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000b1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b5	41 5e		 pop	 r14
  000b7	c3		 ret	 0
inflateSetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT inflateGetHeader
_TEXT	SEGMENT
strm$ = 48
head$ = 56
inflateGetHeader PROC					; COMDAT

; 1379 : {

$LN8:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1380 :     struct inflate_state FAR *state;
; 1381 : 
; 1382 :     /* check state */
; 1383 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	75 1c		 jne	 SHORT $LN5@inflateGet

; 1384 :     state = (struct inflate_state FAR *)strm->state;

  0000d	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 1385 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00011	f6 40 10 02	 test	 BYTE PTR [rax+16], 2
  00015	74 12		 je	 SHORT $LN5@inflateGet

; 1386 : 
; 1387 :     /* save header structure */
; 1388 :     state->head = head;

  00017	48 89 50 28	 mov	 QWORD PTR [rax+40], rdx

; 1389 :     head->done = 0;
; 1390 :     return Z_OK;

  0001b	33 c0		 xor	 eax, eax
  0001d	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [rdx+64], 0

; 1391 : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
$LN5@inflateGet:

; 1385 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00029	b8 fe ff ff ff	 mov	 eax, -2

; 1391 : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
inflateGetHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT syncsearch
_TEXT	SEGMENT
have$ = 8
buf$ = 16
len$ = 24
syncsearch PROC						; COMDAT

; 1408 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 1409 :     unsigned got;
; 1410 :     unsigned next;
; 1411 : 
; 1412 :     got = *have;

  00005	8b 01		 mov	 eax, DWORD PTR [rcx]

; 1413 :     next = 0;

  00007	33 db		 xor	 ebx, ebx
  00009	45 8b d0	 mov	 r10d, r8d
  0000c	4c 8b d9	 mov	 r11, rcx
  0000f	44 8b cb	 mov	 r9d, ebx

; 1414 :     while (next < len && got < 4) {

  00012	45 85 c0	 test	 r8d, r8d
  00015	74 43		 je	 SHORT $LN13@syncsearch
$LL2@syncsearch:
  00017	83 f8 04	 cmp	 eax, 4
  0001a	73 32		 jae	 SHORT $LN14@syncsearch

; 1415 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  0001c	44 0f b6 02	 movzx	 r8d, BYTE PTR [rdx]
  00020	83 f8 02	 cmp	 eax, 2
  00023	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00028	0f 42 cb	 cmovb	 ecx, ebx
  0002b	44 3b c1	 cmp	 r8d, ecx
  0002e	75 04		 jne	 SHORT $LN4@syncsearch

; 1416 :             got++;

  00030	ff c0		 inc	 eax
  00032	eb 0f		 jmp	 SHORT $LN7@syncsearch
$LN4@syncsearch:

; 1417 :         else if (buf[next])
; 1418 :             got = 0;
; 1419 :         else
; 1420 :             got = 4 - got;

  00034	b9 04 00 00 00	 mov	 ecx, 4
  00039	2b c8		 sub	 ecx, eax
  0003b	45 84 c0	 test	 r8b, r8b
  0003e	8b c1		 mov	 eax, ecx
  00040	0f 45 c3	 cmovne	 eax, ebx
$LN7@syncsearch:

; 1421 :         next++;

  00043	41 ff c1	 inc	 r9d
  00046	48 ff c2	 inc	 rdx
  00049	45 3b ca	 cmp	 r9d, r10d
  0004c	72 c9		 jb	 SHORT $LL2@syncsearch
$LN14@syncsearch:

; 1422 :     }
; 1423 :     *have = got;
; 1424 :     return next;
; 1425 : }

  0004e	41 89 03	 mov	 DWORD PTR [r11], eax
  00051	41 8b c1	 mov	 eax, r9d
  00054	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00059	c3		 ret	 0
$LN13@syncsearch:
  0005a	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0005f	89 01		 mov	 DWORD PTR [rcx], eax
  00061	41 8b c1	 mov	 eax, r9d
  00064	c3		 ret	 0
syncsearch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT inflateSync
_TEXT	SEGMENT
strm$ = 64
buf$ = 72
inflateSync PROC					; COMDAT

; 1429 : {

$LN22:
  00000	41 56		 push	 r14
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	4c 8b f1	 mov	 r14, rcx

; 1430 :     unsigned len;               /* number of bytes to look at or looked at */
; 1431 :     int flags;                  /* temporary to save header status */
; 1432 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1433 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1434 :     struct inflate_state FAR *state;
; 1435 : 
; 1436 :     /* check parameters */
; 1437 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00009	e8 00 00 00 00	 call	 inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0c		 je	 SHORT $LN4@inflateSyn
  00012	b8 fe ff ff ff	 mov	 eax, -2

; 1475 : }

  00017	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0001b	41 5e		 pop	 r14
  0001d	c3		 ret	 0
$LN4@inflateSyn:

; 1438 :     state = (struct inflate_state FAR *)strm->state;
; 1439 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  0001e	83 79 08 00	 cmp	 DWORD PTR [rcx+8], 0
  00022	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi
  00027	48 8b 71 28	 mov	 rsi, QWORD PTR [rcx+40]
  0002b	75 17		 jne	 SHORT $LN17@inflateSyn
  0002d	83 7e 4c 08	 cmp	 DWORD PTR [rsi+76], 8
  00031	73 11		 jae	 SHORT $LN17@inflateSyn
  00033	48 8b 74 24 28	 mov	 rsi, QWORD PTR [rsp+40]
  00038	b8 fb ff ff ff	 mov	 eax, -5

; 1475 : }

  0003d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00041	41 5e		 pop	 r14
  00043	c3		 ret	 0
$LN17@inflateSyn:
  00044	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00049	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi

; 1440 : 
; 1441 :     /* if first time, start search in bit buffer */
; 1442 :     if (state->mode != SYNC) {

  0004e	33 ff		 xor	 edi, edi
  00050	81 7e 08 53 3f
	00 00		 cmp	 DWORD PTR [rsi+8], 16211 ; 00003f53H
  00057	74 65		 je	 SHORT $LN15@inflateSyn

; 1443 :         state->mode = SYNC;
; 1444 :         state->hold <<= state->bits & 7;

  00059	8b 56 4c	 mov	 edx, DWORD PTR [rsi+76]

; 1445 :         state->bits -= state->bits & 7;
; 1446 :         len = 0;

  0005c	44 8b cf	 mov	 r9d, edi
  0005f	44 8b 56 48	 mov	 r10d, DWORD PTR [rsi+72]
  00063	8b ca		 mov	 ecx, edx
  00065	83 e1 07	 and	 ecx, 7
  00068	c7 46 08 53 3f
	00 00		 mov	 DWORD PTR [rsi+8], 16211 ; 00003f53H
  0006f	41 d3 e2	 shl	 r10d, cl
  00072	2b d1		 sub	 edx, ecx
  00074	44 89 56 48	 mov	 DWORD PTR [rsi+72], r10d
  00078	89 56 4c	 mov	 DWORD PTR [rsi+76], edx

; 1447 :         while (state->bits >= 8) {

  0007b	83 fa 08	 cmp	 edx, 8
  0007e	72 23		 jb	 SHORT $LN3@inflateSyn
  00080	41 8b ca	 mov	 ecx, r10d
$LL2@inflateSyn:

; 1448 :             buf[len++] = (unsigned char)(state->hold);

  00083	41 8b c1	 mov	 eax, r9d

; 1449 :             state->hold >>= 8;
; 1450 :             state->bits -= 8;

  00086	83 c2 f8	 add	 edx, -8			; fffffff8H
  00089	c1 e9 08	 shr	 ecx, 8
  0008c	41 ff c1	 inc	 r9d
  0008f	44 88 54 04 48	 mov	 BYTE PTR buf$[rsp+rax], r10b
  00094	44 0f b6 d1	 movzx	 r10d, cl
  00098	83 fa 08	 cmp	 edx, 8
  0009b	73 e6		 jae	 SHORT $LL2@inflateSyn
  0009d	89 56 4c	 mov	 DWORD PTR [rsi+76], edx
  000a0	89 4e 48	 mov	 DWORD PTR [rsi+72], ecx
$LN3@inflateSyn:

; 1451 :         }
; 1452 :         state->have = 0;

  000a3	48 8d 9e 84 00
	00 00		 lea	 rbx, QWORD PTR [rsi+132]

; 1453 :         syncsearch(&(state->have), buf, len);

  000aa	45 8b c1	 mov	 r8d, r9d
  000ad	48 8b cb	 mov	 rcx, rbx
  000b0	89 3b		 mov	 DWORD PTR [rbx], edi
  000b2	48 8d 54 24 48	 lea	 rdx, QWORD PTR buf$[rsp]
  000b7	e8 00 00 00 00	 call	 syncsearch
  000bc	eb 07		 jmp	 SHORT $LN6@inflateSyn
$LN15@inflateSyn:
  000be	48 8d 9e 84 00
	00 00		 lea	 rbx, QWORD PTR [rsi+132]
$LN6@inflateSyn:

; 1454 :     }
; 1455 : 
; 1456 :     /* search available input */
; 1457 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  000c5	45 8b 46 08	 mov	 r8d, DWORD PTR [r14+8]
  000c9	48 8b cb	 mov	 rcx, rbx
  000cc	49 8b 16	 mov	 rdx, QWORD PTR [r14]
  000cf	e8 00 00 00 00	 call	 syncsearch

; 1458 :     strm->avail_in -= len;

  000d4	41 29 46 08	 sub	 DWORD PTR [r14+8], eax

; 1459 :     strm->next_in += len;
; 1460 :     strm->total_in += len;

  000d8	41 01 46 0c	 add	 DWORD PTR [r14+12], eax
  000dc	8b c8		 mov	 ecx, eax
  000de	49 01 0e	 add	 QWORD PTR [r14], rcx

; 1461 : 
; 1462 :     /* return no joy or set up to restart inflate() on a new block */
; 1463 :     if (state->have != 4) return Z_DATA_ERROR;

  000e1	83 3b 04	 cmp	 DWORD PTR [rbx], 4
  000e4	74 07		 je	 SHORT $LN7@inflateSyn
  000e6	b8 fd ff ff ff	 mov	 eax, -3
  000eb	eb 3f		 jmp	 SHORT $LN20@inflateSyn
$LN7@inflateSyn:
  000ed	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp

; 1464 :     if (state->flags == -1)

  000f2	8b 6e 18	 mov	 ebp, DWORD PTR [rsi+24]
  000f5	83 fd ff	 cmp	 ebp, -1
  000f8	75 05		 jne	 SHORT $LN8@inflateSyn

; 1465 :         state->wrap = 0;    /* if no header yet, treat as raw */

  000fa	89 7e 10	 mov	 DWORD PTR [rsi+16], edi
  000fd	eb 04		 jmp	 SHORT $LN9@inflateSyn
$LN8@inflateSyn:

; 1466 :     else
; 1467 :         state->wrap &= ~4;  /* no point in computing a check value now */

  000ff	83 66 10 fb	 and	 DWORD PTR [rsi+16], -5
$LN9@inflateSyn:

; 1468 :     flags = state->flags;
; 1469 :     in = strm->total_in;  out = strm->total_out;

  00103	41 8b 7e 0c	 mov	 edi, DWORD PTR [r14+12]

; 1470 :     inflateReset(strm);

  00107	49 8b ce	 mov	 rcx, r14
  0010a	41 8b 5e 1c	 mov	 ebx, DWORD PTR [r14+28]
  0010e	e8 00 00 00 00	 call	 inflateReset

; 1471 :     strm->total_in = in;  strm->total_out = out;

  00113	41 89 7e 0c	 mov	 DWORD PTR [r14+12], edi

; 1472 :     state->flags = flags;
; 1473 :     state->mode = TYPE;
; 1474 :     return Z_OK;

  00117	33 c0		 xor	 eax, eax
  00119	41 89 5e 1c	 mov	 DWORD PTR [r14+28], ebx
  0011d	89 6e 18	 mov	 DWORD PTR [rsi+24], ebp
  00120	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00125	c7 46 08 3f 3f
	00 00		 mov	 DWORD PTR [rsi+8], 16191 ; 00003f3fH
$LN20@inflateSyn:
  0012c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00131	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  00136	48 8b 74 24 28	 mov	 rsi, QWORD PTR [rsp+40]

; 1475 : }

  0013b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0013f	41 5e		 pop	 r14
  00141	c3		 ret	 0
inflateSync ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT inflateSyncPoint
_TEXT	SEGMENT
strm$ = 48
inflateSyncPoint PROC					; COMDAT

; 1487 : {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1488 :     struct inflate_state FAR *state;
; 1489 : 
; 1490 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateSyn
  0000d	b8 fe ff ff ff	 mov	 eax, -2

; 1493 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateSyn:

; 1491 :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 1492 :     return state->mode == STORED && state->bits == 0;

  0001b	81 78 08 41 3f
	00 00		 cmp	 DWORD PTR [rax+8], 16193 ; 00003f41H
  00022	75 10		 jne	 SHORT $LN4@inflateSyn
  00024	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  00028	75 0a		 jne	 SHORT $LN4@inflateSyn
  0002a	b8 01 00 00 00	 mov	 eax, 1

; 1493 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
$LN4@inflateSyn:

; 1492 :     return state->mode == STORED && state->bits == 0;

  00034	33 c0		 xor	 eax, eax

; 1493 : }

  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
inflateSyncPoint ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT inflateCopy
_TEXT	SEGMENT
dest$ = 64
source$ = 72
inflateCopy PROC					; COMDAT

; 1498 : {

$LN19:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00007	48 8b e9	 mov	 rbp, rcx
  0000a	48 8b fa	 mov	 rdi, rdx

; 1499 :     struct inflate_state FAR *state;
; 1500 :     struct inflate_state FAR *copy;
; 1501 :     unsigned char FAR *window;
; 1502 :     unsigned wsize;
; 1503 : 
; 1504 :     /* check input */
; 1505 :     if (inflateStateCheck(source) || dest == Z_NULL)

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	e8 00 00 00 00	 call	 inflateStateCheck
  00015	85 c0		 test	 eax, eax
  00017	0f 85 84 01 00
	00		 jne	 $LN3@inflateCop
  0001d	48 85 ed	 test	 rbp, rbp
  00020	0f 84 7b 01 00
	00		 je	 $LN3@inflateCop

; 1507 :     state = (struct inflate_state FAR *)source->state;
; 1508 : 
; 1509 :     /* allocate space */
; 1510 :     copy = (struct inflate_state FAR *)

  00026	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0002a	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  00030	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00035	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  0003a	48 8b 72 28	 mov	 rsi, QWORD PTR [rdx+40]
  0003e	4c 89 74 24 58	 mov	 QWORD PTR [rsp+88], r14
  00043	41 be 01 00 00
	00		 mov	 r14d, 1
  00049	41 8b d6	 mov	 edx, r14d
  0004c	ff 57 30	 call	 QWORD PTR [rdi+48]
  0004f	48 8b d8	 mov	 rbx, rax

; 1511 :            ZALLOC(source, 1, sizeof(struct inflate_state));
; 1512 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  00052	48 85 c0	 test	 rax, rax
  00055	75 05		 jne	 SHORT $LN4@inflateCop
  00057	8d 43 fc	 lea	 eax, QWORD PTR [rbx-4]
  0005a	eb 45		 jmp	 SHORT $LN15@inflateCop
$LN4@inflateCop:
  0005c	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  00061	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15

; 1513 :     window = Z_NULL;

  00066	45 33 ff	 xor	 r15d, r15d

; 1514 :     if (state->window != Z_NULL) {

  00069	4c 39 7e 40	 cmp	 QWORD PTR [rsi+64], r15
  0006d	74 48		 je	 SHORT $LN11@inflateCop

; 1515 :         window = (unsigned char FAR *)

  0006f	8b 4e 30	 mov	 ecx, DWORD PTR [rsi+48]
  00072	41 8b d6	 mov	 edx, r14d
  00075	d3 e2		 shl	 edx, cl
  00077	45 8b c6	 mov	 r8d, r14d
  0007a	48 8b 4f 40	 mov	 rcx, QWORD PTR [rdi+64]
  0007e	ff 57 30	 call	 QWORD PTR [rdi+48]
  00081	4c 8b f8	 mov	 r15, rax

; 1516 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
; 1517 :         if (window == Z_NULL) {

  00084	48 85 c0	 test	 rax, rax
  00087	75 2e		 jne	 SHORT $LN11@inflateCop

; 1518 :             ZFREE(source, copy);

  00089	48 8b 4f 40	 mov	 rcx, QWORD PTR [rdi+64]
  0008d	48 8b d3	 mov	 rdx, rbx
  00090	ff 57 38	 call	 QWORD PTR [rdi+56]

; 1519 :             return Z_MEM_ERROR;

  00093	41 8d 47 fc	 lea	 eax, QWORD PTR [r15-4]
$LN17@inflateCop:
  00097	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
  0009c	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
$LN15@inflateCop:
  000a1	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000a6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ab	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]

; 1540 : }

  000b0	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b4	5f		 pop	 rdi
  000b5	5d		 pop	 rbp
  000b6	c3		 ret	 0
$LN11@inflateCop:

; 1520 :         }
; 1521 :     }
; 1522 : 
; 1523 :     /* copy state */
; 1524 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  000b7	0f 10 07	 movups	 xmm0, XMMWORD PTR [rdi]

; 1525 :     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));

  000ba	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  000c0	48 8b d6	 mov	 rdx, rsi
  000c3	48 8b cb	 mov	 rcx, rbx
  000c6	0f 11 45 00	 movups	 XMMWORD PTR [rbp], xmm0
  000ca	0f 10 4f 10	 movups	 xmm1, XMMWORD PTR [rdi+16]
  000ce	0f 11 4d 10	 movups	 XMMWORD PTR [rbp+16], xmm1
  000d2	0f 10 47 20	 movups	 xmm0, XMMWORD PTR [rdi+32]
  000d6	0f 11 45 20	 movups	 XMMWORD PTR [rbp+32], xmm0
  000da	0f 10 4f 30	 movups	 xmm1, XMMWORD PTR [rdi+48]
  000de	0f 11 4d 30	 movups	 XMMWORD PTR [rbp+48], xmm1
  000e2	0f 10 47 40	 movups	 xmm0, XMMWORD PTR [rdi+64]
  000e6	0f 11 45 40	 movups	 XMMWORD PTR [rbp+64], xmm0
  000ea	f2 0f 10 4f 50	 movsd	 xmm1, QWORD PTR [rdi+80]
  000ef	f2 0f 11 4d 50	 movsd	 QWORD PTR [rbp+80], xmm1
  000f4	e8 00 00 00 00	 call	 memcpy

; 1526 :     copy->strm = dest;

  000f9	48 89 2b	 mov	 QWORD PTR [rbx], rbp

; 1527 :     if (state->lencode >= state->codes &&

  000fc	48 8d 86 50 05
	00 00		 lea	 rax, QWORD PTR [rsi+1360]
  00103	48 8b 4e 60	 mov	 rcx, QWORD PTR [rsi+96]
  00107	48 3b c8	 cmp	 rcx, rax
  0010a	72 47		 jb	 SHORT $LN7@inflateCop
  0010c	48 8d 86 dc 1b
	00 00		 lea	 rax, QWORD PTR [rsi+7132]
  00113	48 3b c8	 cmp	 rcx, rax
  00116	77 3b		 ja	 SHORT $LN7@inflateCop

; 1528 :         state->lencode <= state->codes + ENOUGH - 1) {
; 1529 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  00118	48 2b ce	 sub	 rcx, rsi
  0011b	48 8d 81 b0 fa
	ff ff		 lea	 rax, QWORD PTR [rcx-1360]
  00122	48 c1 f8 02	 sar	 rax, 2
  00126	48 05 54 01 00
	00		 add	 rax, 340		; 00000154H
  0012c	48 8d 04 83	 lea	 rax, QWORD PTR [rbx+rax*4]
  00130	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax

; 1530 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  00134	48 8b 46 68	 mov	 rax, QWORD PTR [rsi+104]
  00138	48 2b c6	 sub	 rax, rsi
  0013b	48 2d 50 05 00
	00		 sub	 rax, 1360		; 00000550H
  00141	48 c1 f8 02	 sar	 rax, 2
  00145	48 05 54 01 00
	00		 add	 rax, 340		; 00000154H
  0014b	48 8d 04 83	 lea	 rax, QWORD PTR [rbx+rax*4]
  0014f	48 89 43 68	 mov	 QWORD PTR [rbx+104], rax
$LN7@inflateCop:

; 1531 :     }
; 1532 :     copy->next = copy->codes + (state->next - state->codes);

  00153	48 8b 86 88 00
	00 00		 mov	 rax, QWORD PTR [rsi+136]
  0015a	48 2b c6	 sub	 rax, rsi
  0015d	48 2d 50 05 00
	00		 sub	 rax, 1360		; 00000550H
  00163	48 c1 f8 02	 sar	 rax, 2
  00167	48 05 54 01 00
	00		 add	 rax, 340		; 00000154H
  0016d	48 8d 04 83	 lea	 rax, QWORD PTR [rbx+rax*4]
  00171	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax

; 1533 :     if (window != Z_NULL) {

  00178	4d 85 ff	 test	 r15, r15
  0017b	74 15		 je	 SHORT $LN8@inflateCop

; 1534 :         wsize = 1U << state->wbits;

  0017d	8b 4e 30	 mov	 ecx, DWORD PTR [rsi+48]

; 1535 :         zmemcpy(window, state->window, wsize);

  00180	48 8b 56 40	 mov	 rdx, QWORD PTR [rsi+64]
  00184	41 d3 e6	 shl	 r14d, cl
  00187	49 8b cf	 mov	 rcx, r15
  0018a	45 8b c6	 mov	 r8d, r14d
  0018d	e8 00 00 00 00	 call	 memcpy
$LN8@inflateCop:

; 1536 :     }
; 1537 :     copy->window = window;

  00192	4c 89 7b 40	 mov	 QWORD PTR [rbx+64], r15

; 1538 :     dest->state = (struct internal_state FAR *)copy;
; 1539 :     return Z_OK;

  00196	33 c0		 xor	 eax, eax
  00198	48 89 5d 28	 mov	 QWORD PTR [rbp+40], rbx
  0019c	e9 f6 fe ff ff	 jmp	 $LN17@inflateCop
$LN3@inflateCop:

; 1506 :         return Z_STREAM_ERROR;

  001a1	b8 fe ff ff ff	 mov	 eax, -2

; 1540 : }

  001a6	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001aa	5f		 pop	 rdi
  001ab	5d		 pop	 rbp
  001ac	c3		 ret	 0
inflateCopy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT inflateUndermine
_TEXT	SEGMENT
strm$ = 48
subvert$ = 56
inflateUndermine PROC					; COMDAT

; 1545 : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1546 :     struct inflate_state FAR *state;
; 1547 : 
; 1548 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateUnd
  0000d	b8 fe ff ff ff	 mov	 eax, -2

; 1557 : #endif
; 1558 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateUnd:

; 1549 :     state = (struct inflate_state FAR *)strm->state;
; 1550 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1551 :     state->sane = !subvert;
; 1552 :     return Z_OK;
; 1553 : #else
; 1554 :     (void)subvert;
; 1555 :     state->sane = 1;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  0001b	c7 80 e0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+7136], 1

; 1556 :     return Z_DATA_ERROR;

  00025	b8 fd ff ff ff	 mov	 eax, -3

; 1557 : #endif
; 1558 : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
inflateUndermine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT inflateValidate
_TEXT	SEGMENT
strm$ = 48
check$ = 56
inflateValidate PROC					; COMDAT

; 1563 : {

$LN9:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1564 :     struct inflate_state FAR *state;
; 1565 : 
; 1566 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateVal
  0000d	b8 fe ff ff ff	 mov	 eax, -2

; 1573 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateVal:

; 1567 :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 1568 :     if (check && state->wrap)

  0001b	85 d2		 test	 edx, edx
  0001d	74 14		 je	 SHORT $LN6@inflateVal
  0001f	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  00022	85 c9		 test	 ecx, ecx
  00024	74 0d		 je	 SHORT $LN6@inflateVal

; 1569 :         state->wrap |= 4;

  00026	83 c9 04	 or	 ecx, 4
  00029	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 1572 :     return Z_OK;

  0002c	33 c0		 xor	 eax, eax

; 1573 : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
$LN6@inflateVal:

; 1570 :     else
; 1571 :         state->wrap &= ~4;

  00033	83 60 10 fb	 and	 DWORD PTR [rax+16], -5

; 1572 :     return Z_OK;

  00037	33 c0		 xor	 eax, eax

; 1573 : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
inflateValidate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT inflateMark
_TEXT	SEGMENT
strm$ = 48
inflateMark PROC					; COMDAT

; 1577 : {

$LN9:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1578 :     struct inflate_state FAR *state;
; 1579 : 
; 1580 :     if (inflateStateCheck(strm))

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateMar

; 1581 :         return -(1L << 16);

  0000d	b8 00 00 ff ff	 mov	 eax, -65536		; ffffffffffff0000H

; 1584 :         (state->mode == COPY ? state->length :
; 1585 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1586 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateMar:

; 1582 :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 1583 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  0001b	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  0001e	81 f9 43 3f 00
	00		 cmp	 ecx, 16195		; 00003f43H
  00024	75 13		 jne	 SHORT $LN6@inflateMar
  00026	8b 48 50	 mov	 ecx, DWORD PTR [rax+80]
  00029	8b 80 e4 1b 00
	00		 mov	 eax, DWORD PTR [rax+7140]
  0002f	c1 e0 10	 shl	 eax, 16
  00032	03 c1		 add	 eax, ecx

; 1584 :         (state->mode == COPY ? state->length :
; 1585 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1586 : }

  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
$LN6@inflateMar:

; 1583 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  00039	81 f9 4c 3f 00
	00		 cmp	 ecx, 16204		; 00003f4cH
  0003f	75 19		 jne	 SHORT $LN4@inflateMar
  00041	8b 88 e8 1b 00
	00		 mov	 ecx, DWORD PTR [rax+7144]
  00047	2b 48 50	 sub	 ecx, DWORD PTR [rax+80]
  0004a	8b 80 e4 1b 00
	00		 mov	 eax, DWORD PTR [rax+7140]
  00050	c1 e0 10	 shl	 eax, 16
  00053	03 c1		 add	 eax, ecx

; 1584 :         (state->mode == COPY ? state->length :
; 1585 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1586 : }

  00055	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00059	c3		 ret	 0
$LN4@inflateMar:

; 1583 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  0005a	8b 80 e4 1b 00
	00		 mov	 eax, DWORD PTR [rax+7140]
  00060	33 c9		 xor	 ecx, ecx
  00062	c1 e0 10	 shl	 eax, 16
  00065	03 c1		 add	 eax, ecx

; 1584 :         (state->mode == COPY ? state->length :
; 1585 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1586 : }

  00067	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006b	c3		 ret	 0
inflateMark ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT inflateCodesUsed
_TEXT	SEGMENT
strm$ = 48
inflateCodesUsed PROC					; COMDAT

; 1590 : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1591 :     struct inflate_state FAR *state;
; 1592 :     if (inflateStateCheck(strm)) return (unsigned long)-1;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateCod
  0000d	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH

; 1595 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateCod:

; 1593 :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]

; 1594 :     return (unsigned long)(state->next - state->codes);

  0001b	48 8b 81 88 00
	00 00		 mov	 rax, QWORD PTR [rcx+136]
  00022	48 2b c1	 sub	 rax, rcx
  00025	48 2d 50 05 00
	00		 sub	 rax, 1360		; 00000550H
  0002b	48 c1 f8 02	 sar	 rax, 2

; 1595 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
inflateCodesUsed ENDP
_TEXT	ENDS
END
