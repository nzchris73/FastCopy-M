; Listing generated by Microsoft (R) Optimizing Compiler Version 19.36.32537.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	inflate_fast
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate_fast DD imagerel $LN145
	DD	imagerel $LN145+1270
	DD	imagerel $unwind$inflate_fast
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate_fast DD 091501H
	DD	0f0116215H
	DD	0d00de00fH
	DD	07009c00bH
	DD	050076008H
	DD	03006H
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\inffast.c
;	COMDAT inflate_fast
_TEXT	SEGMENT
tv901 = 0
end$1$ = 8
state$1$ = 16
last$1$ = 24
beg$1$ = 32
strm$ = 128
tv900 = 136
start$ = 136
wsize$1$ = 144
whave$1$ = 152
inflate_fast PROC					; COMDAT

; 50   : void ZLIB_INTERNAL inflate_fast(z_streamp strm, unsigned start) {

$LN145:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	41 57		 push	 r15
  00011	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 51   :     struct inflate_state FAR *state;
; 52   :     z_const unsigned char FAR *in;      /* local strm->next_in */
; 53   :     z_const unsigned char FAR *last;    /* have enough input while in < last */
; 54   :     unsigned char FAR *out;     /* local strm->next_out */
; 55   :     unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
; 56   :     unsigned char FAR *end;     /* while out < end, enough space available */
; 57   : #ifdef INFLATE_STRICT
; 58   :     unsigned dmax;              /* maximum distance from zlib header */
; 59   : #endif
; 60   :     unsigned wsize;             /* window size or zero if not using window */
; 61   :     unsigned whave;             /* valid bytes in the window */
; 62   :     unsigned wnext;             /* window write index */
; 63   :     unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
; 64   :     unsigned long hold;         /* local strm->hold */
; 65   :     unsigned bits;              /* local strm->bits */
; 66   :     code const FAR *lcode;      /* local strm->lencode */
; 67   :     code const FAR *dcode;      /* local strm->distcode */
; 68   :     unsigned lmask;             /* mask for first level of length codes */
; 69   :     unsigned dmask;             /* mask for first level of distance codes */
; 70   :     code const *here;           /* retrieved table entry */
; 71   :     unsigned op;                /* code bits, operation, extra bits, or */
; 72   :                                 /*  window position, window bytes to copy */
; 73   :     unsigned len;               /* match length, unused bytes */
; 74   :     unsigned dist;              /* match distance */
; 75   :     unsigned char FAR *from;    /* where to copy match from */
; 76   : 
; 77   :     /* copy state to local variables */
; 78   :     state = (struct inflate_state FAR *)strm->state;

  00015	48 8b 71 28	 mov	 rsi, QWORD PTR [rcx+40]

; 79   :     in = strm->next_in;
; 80   :     last = in + (strm->avail_in - 5);
; 81   :     out = strm->next_out;
; 82   :     beg = out - (start - strm->avail_out);
; 83   :     end = out + (strm->avail_out - 257);
; 84   : #ifdef INFLATE_STRICT
; 85   :     dmax = state->dmax;
; 86   : #endif
; 87   :     wsize = state->wsize;
; 88   :     whave = state->whave;
; 89   :     wnext = state->wnext;
; 90   :     window = state->window;
; 91   :     hold = state->hold;
; 92   :     bits = state->bits;
; 93   :     lcode = state->lencode;
; 94   :     dcode = state->distcode;
; 95   :     lmask = (1U << state->lenbits) - 1;

  00019	bd 01 00 00 00	 mov	 ebp, 1
  0001e	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]
  00021	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  00025	83 e8 05	 sub	 eax, 5
  00028	48 8b 39	 mov	 rdi, QWORD PTR [rcx]
  0002b	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  0002e	48 03 c7	 add	 rax, rdi
  00031	44 8b 76 3c	 mov	 r14d, DWORD PTR [rsi+60]
  00035	2b d1		 sub	 edx, ecx
  00037	4c 8b 7e 40	 mov	 r15, QWORD PTR [rsi+64]
  0003b	8b 5e 48	 mov	 ebx, DWORD PTR [rsi+72]
  0003e	44 8b 56 4c	 mov	 r10d, DWORD PTR [rsi+76]
  00042	44 8d 99 ff fe
	ff ff		 lea	 r11d, DWORD PTR [rcx-257]
  00049	8b 4e 70	 mov	 ecx, DWORD PTR [rsi+112]
  0004c	4d 03 d8	 add	 r11, r8
  0004f	4c 8b 66 60	 mov	 r12, QWORD PTR [rsi+96]
  00053	4c 8b 6e 68	 mov	 r13, QWORD PTR [rsi+104]
  00057	48 89 44 24 18	 mov	 QWORD PTR last$1$[rsp], rax
  0005c	8b c2		 mov	 eax, edx
  0005e	49 8b d0	 mov	 rdx, r8
  00061	48 2b d0	 sub	 rdx, rax
  00064	48 89 74 24 10	 mov	 QWORD PTR state$1$[rsp], rsi
  00069	8b 46 34	 mov	 eax, DWORD PTR [rsi+52]
  0006c	48 89 54 24 20	 mov	 QWORD PTR beg$1$[rsp], rdx
  00071	8b d5		 mov	 edx, ebp
  00073	d3 e2		 shl	 edx, cl

; 96   :     dmask = (1U << state->distbits) - 1;

  00075	8b 4e 74	 mov	 ecx, DWORD PTR [rsi+116]
  00078	ff ca		 dec	 edx
  0007a	89 84 24 90 00
	00 00		 mov	 DWORD PTR wsize$1$[rsp], eax
  00081	8b 46 38	 mov	 eax, DWORD PTR [rsi+56]
  00084	8b f5		 mov	 esi, ebp
  00086	d3 e6		 shl	 esi, cl
  00088	ff ce		 dec	 esi
  0008a	4c 89 5c 24 08	 mov	 QWORD PTR end$1$[rsp], r11
  0008f	89 b4 24 88 00
	00 00		 mov	 DWORD PTR tv900[rsp], esi
  00096	89 84 24 98 00
	00 00		 mov	 DWORD PTR whave$1$[rsp], eax
  0009d	89 14 24	 mov	 DWORD PTR tv901[rsp], edx
$LL4@inflate_fa:

; 97   : 
; 98   :     /* decode literals and length/distances until end-of-block or not enough
; 99   :        input data or output space */
; 100  :     do {
; 101  :         if (bits < 15) {

  000a0	41 83 fa 0f	 cmp	 r10d, 15
  000a4	73 1e		 jae	 SHORT $LN22@inflate_fa

; 102  :             hold += (unsigned long)(*in++) << bits;

  000a6	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  000a9	41 8b ca	 mov	 ecx, r10d
  000ac	d3 e0		 shl	 eax, cl

; 103  :             bits += 8;
; 104  :             hold += (unsigned long)(*in++) << bits;

  000ae	41 8d 4a 08	 lea	 ecx, DWORD PTR [r10+8]
  000b2	03 d8		 add	 ebx, eax
  000b4	0f b6 47 01	 movzx	 eax, BYTE PTR [rdi+1]
  000b8	d3 e0		 shl	 eax, cl
  000ba	03 d8		 add	 ebx, eax
  000bc	48 83 c7 02	 add	 rdi, 2

; 105  :             bits += 8;

  000c0	41 83 c2 10	 add	 r10d, 16
$LN22@inflate_fa:

; 106  :         }
; 107  :         here = lcode + (hold & lmask);

  000c4	8b ca		 mov	 ecx, edx
  000c6	8b c3		 mov	 eax, ebx
  000c8	48 23 c8	 and	 rcx, rax

; 108  :       dolen:
; 109  :         op = (unsigned)(here->bits);
; 110  :         hold >>= op;
; 111  :         bits -= op;
; 112  :         op = (unsigned)(here->op);

  000cb	41 0f b6 14 8c	 movzx	 edx, BYTE PTR [r12+rcx*4]
  000d0	4d 8d 0c 8c	 lea	 r9, QWORD PTR [r12+rcx*4]
  000d4	41 0f b6 4c 8c
	01		 movzx	 ecx, BYTE PTR [r12+rcx*4+1]
  000da	d3 eb		 shr	 ebx, cl
  000dc	44 2b d1	 sub	 r10d, ecx

; 113  :         if (op == 0) {                          /* literal */

  000df	85 d2		 test	 edx, edx
  000e1	74 3c		 je	 SHORT $LN72@inflate_fa
$dolen$146:

; 118  :         }
; 119  :         else if (op & 16) {                     /* length base */

  000e3	f6 c2 10	 test	 dl, 16
  000e6	75 47		 jne	 SHORT $LN73@inflate_fa

; 271  :             }
; 272  :         }
; 273  :         else if ((op & 64) == 0) {              /* 2nd level length code */

  000e8	f6 c2 40	 test	 dl, 64			; 00000040H
  000eb	0f 85 42 03 00
	00		 jne	 $LN52@inflate_fa

; 274  :             here = lcode + here->val + (hold & ((1U << op) - 1));

  000f1	8b ca		 mov	 ecx, edx
  000f3	8b c5		 mov	 eax, ebp
  000f5	d3 e0		 shl	 eax, cl
  000f7	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  000fa	8b c3		 mov	 eax, ebx
  000fc	48 23 c8	 and	 rcx, rax
  000ff	41 0f b7 41 02	 movzx	 eax, WORD PTR [r9+2]
  00104	48 03 c8	 add	 rcx, rax
  00107	41 0f b6 14 8c	 movzx	 edx, BYTE PTR [r12+rcx*4]
  0010c	4d 8d 0c 8c	 lea	 r9, QWORD PTR [r12+rcx*4]
  00110	41 0f b6 4c 8c
	01		 movzx	 ecx, BYTE PTR [r12+rcx*4+1]
  00116	d3 eb		 shr	 ebx, cl
  00118	44 2b d1	 sub	 r10d, ecx
  0011b	85 d2		 test	 edx, edx
  0011d	75 c4		 jne	 SHORT $dolen$146
$LN72@inflate_fa:

; 114  :             Tracevv((stderr, here->val >= 0x20 && here->val < 0x7f ?
; 115  :                     "inflate:         literal '%c'\n" :
; 116  :                     "inflate:         literal 0x%02x\n", here->val));
; 117  :             *out++ = (unsigned char)(here->val);

  0011f	41 0f b6 41 02	 movzx	 eax, BYTE PTR [r9+2]
  00124	41 88 00	 mov	 BYTE PTR [r8], al
  00127	49 ff c0	 inc	 r8

; 285  :             break;
; 286  :         }
; 287  :     } while (in < last && out < end);

  0012a	e9 f0 02 00 00	 jmp	 $LN2@inflate_fa
$LN73@inflate_fa:

; 120  :             len = (unsigned)(here->val);

  0012f	45 0f b7 59 02	 movzx	 r11d, WORD PTR [r9+2]

; 121  :             op &= 15;                           /* number of extra bits */

  00134	83 e2 0f	 and	 edx, 15

; 122  :             if (op) {

  00137	74 28		 je	 SHORT $LN27@inflate_fa

; 123  :                 if (bits < op) {

  00139	44 3b d2	 cmp	 r10d, edx
  0013c	73 11		 jae	 SHORT $LN28@inflate_fa

; 124  :                     hold += (unsigned long)(*in++) << bits;

  0013e	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  00141	41 8b ca	 mov	 ecx, r10d
  00144	d3 e0		 shl	 eax, cl
  00146	48 ff c7	 inc	 rdi
  00149	03 d8		 add	 ebx, eax

; 125  :                     bits += 8;

  0014b	41 83 c2 08	 add	 r10d, 8
$LN28@inflate_fa:

; 126  :                 }
; 127  :                 len += (unsigned)hold & ((1U << op) - 1);

  0014f	8b ca		 mov	 ecx, edx
  00151	8b c5		 mov	 eax, ebp
  00153	d3 e0		 shl	 eax, cl
  00155	ff c8		 dec	 eax
  00157	23 c3		 and	 eax, ebx

; 128  :                 hold >>= op;

  00159	d3 eb		 shr	 ebx, cl
  0015b	44 03 d8	 add	 r11d, eax

; 129  :                 bits -= op;

  0015e	44 2b d2	 sub	 r10d, edx
$LN27@inflate_fa:

; 130  :             }
; 131  :             Tracevv((stderr, "inflate:         length %u\n", len));
; 132  :             if (bits < 15) {

  00161	41 83 fa 0f	 cmp	 r10d, 15
  00165	73 1e		 jae	 SHORT $LN29@inflate_fa

; 133  :                 hold += (unsigned long)(*in++) << bits;

  00167	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  0016a	41 8b ca	 mov	 ecx, r10d
  0016d	d3 e0		 shl	 eax, cl

; 134  :                 bits += 8;
; 135  :                 hold += (unsigned long)(*in++) << bits;

  0016f	41 8d 4a 08	 lea	 ecx, DWORD PTR [r10+8]
  00173	03 d8		 add	 ebx, eax
  00175	0f b6 47 01	 movzx	 eax, BYTE PTR [rdi+1]
  00179	d3 e0		 shl	 eax, cl
  0017b	03 d8		 add	 ebx, eax
  0017d	48 83 c7 02	 add	 rdi, 2

; 136  :                 bits += 8;

  00181	41 83 c2 10	 add	 r10d, 16
$LN29@inflate_fa:

; 137  :             }
; 138  :             here = dcode + (hold & dmask);

  00185	8b c3		 mov	 eax, ebx
  00187	8b ce		 mov	 ecx, esi
  00189	48 23 c8	 and	 rcx, rax
  0018c	4c 8d 0c 8d 00
	00 00 00	 lea	 r9, QWORD PTR [rcx*4]
  00194	4d 03 cd	 add	 r9, r13

; 139  :           dodist:
; 140  :             op = (unsigned)(here->bits);

  00197	41 0f b6 49 01	 movzx	 ecx, BYTE PTR [r9+1]

; 141  :             hold >>= op;
; 142  :             bits -= op;
; 143  :             op = (unsigned)(here->op);

  0019c	41 0f b6 11	 movzx	 edx, BYTE PTR [r9]
  001a0	44 2b d1	 sub	 r10d, ecx
  001a3	d3 eb		 shr	 ebx, cl

; 144  :             if (op & 16) {                      /* distance base */

  001a5	f6 c2 10	 test	 dl, 16
  001a8	75 43		 jne	 SHORT $LN74@inflate_fa
  001aa	66 0f 1f 44 00
	00		 npad	 6
$dodist$147:

; 260  :                     }
; 261  :                 }
; 262  :             }
; 263  :             else if ((op & 64) == 0) {          /* 2nd level distance code */

  001b0	f6 c2 40	 test	 dl, 64			; 00000040H
  001b3	0f 85 a9 02 00
	00		 jne	 $LN50@inflate_fa

; 264  :                 here = dcode + here->val + (hold & ((1U << op) - 1));

  001b9	8b ca		 mov	 ecx, edx
  001bb	8b c5		 mov	 eax, ebp
  001bd	d3 e0		 shl	 eax, cl
  001bf	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  001c2	8b c3		 mov	 eax, ebx
  001c4	48 23 c8	 and	 rcx, rax
  001c7	41 0f b7 41 02	 movzx	 eax, WORD PTR [r9+2]
  001cc	48 03 c8	 add	 rcx, rax
  001cf	4c 8d 0c 8d 00
	00 00 00	 lea	 r9, QWORD PTR [rcx*4]
  001d7	4d 03 cd	 add	 r9, r13
  001da	41 0f b6 49 01	 movzx	 ecx, BYTE PTR [r9+1]
  001df	41 0f b6 11	 movzx	 edx, BYTE PTR [r9]
  001e3	44 2b d1	 sub	 r10d, ecx
  001e6	d3 eb		 shr	 ebx, cl
  001e8	f6 c2 10	 test	 dl, 16
  001eb	74 c3		 je	 SHORT $dodist$147
$LN74@inflate_fa:

; 145  :                 dist = (unsigned)(here->val);

  001ed	41 0f b7 71 02	 movzx	 esi, WORD PTR [r9+2]

; 146  :                 op &= 15;                       /* number of extra bits */

  001f2	83 e2 0f	 and	 edx, 15

; 147  :                 if (bits < op) {

  001f5	44 3b d2	 cmp	 r10d, edx
  001f8	73 27		 jae	 SHORT $LN33@inflate_fa

; 148  :                     hold += (unsigned long)(*in++) << bits;

  001fa	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  001fd	41 8b ca	 mov	 ecx, r10d
  00200	d3 e0		 shl	 eax, cl

; 149  :                     bits += 8;

  00202	41 83 c2 08	 add	 r10d, 8
  00206	03 d8		 add	 ebx, eax
  00208	48 ff c7	 inc	 rdi

; 150  :                     if (bits < op) {

  0020b	44 3b d2	 cmp	 r10d, edx
  0020e	73 11		 jae	 SHORT $LN33@inflate_fa

; 151  :                         hold += (unsigned long)(*in++) << bits;

  00210	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  00213	41 8b ca	 mov	 ecx, r10d
  00216	d3 e0		 shl	 eax, cl
  00218	03 d8		 add	 ebx, eax
  0021a	48 ff c7	 inc	 rdi

; 152  :                         bits += 8;

  0021d	41 83 c2 08	 add	 r10d, 8
$LN33@inflate_fa:

; 153  :                     }
; 154  :                 }
; 155  :                 dist += (unsigned)hold & ((1U << op) - 1);

  00221	8b ca		 mov	 ecx, edx
  00223	8b c5		 mov	 eax, ebp
  00225	d3 e0		 shl	 eax, cl

; 156  : #ifdef INFLATE_STRICT
; 157  :                 if (dist > dmax) {
; 158  :                     strm->msg = (char *)"invalid distance too far back";
; 159  :                     state->mode = BAD;
; 160  :                     break;
; 161  :                 }
; 162  : #endif
; 163  :                 hold >>= op;
; 164  :                 bits -= op;

  00227	44 2b d2	 sub	 r10d, edx
  0022a	ff c8		 dec	 eax
  0022c	23 c3		 and	 eax, ebx
  0022e	d3 eb		 shr	 ebx, cl
  00230	03 f0		 add	 esi, eax

; 165  :                 Tracevv((stderr, "inflate:         distance %u\n", dist));
; 166  :                 op = (unsigned)(out - beg);     /* max distance in output */

  00232	41 8b c0	 mov	 eax, r8d
  00235	2b 44 24 20	 sub	 eax, DWORD PTR beg$1$[rsp]

; 167  :                 if (dist > op) {                /* see if copy from window */

  00239	3b f0		 cmp	 esi, eax
  0023b	0f 86 6e 01 00
	00		 jbe	 $LN34@inflate_fa

; 168  :                     op = dist - op;             /* distance back in window */

  00241	8b ce		 mov	 ecx, esi
  00243	2b c8		 sub	 ecx, eax

; 169  :                     if (op > whave) {

  00245	3b 8c 24 98 00
	00 00		 cmp	 ecx, DWORD PTR whave$1$[rsp]
  0024c	76 12		 jbe	 SHORT $LN37@inflate_fa

; 170  :                         if (state->sane) {

  0024e	48 8b 44 24 10	 mov	 rax, QWORD PTR state$1$[rsp]
  00253	83 b8 e0 1b 00
	00 00		 cmp	 DWORD PTR [rax+7136], 0
  0025a	0f 85 0b 02 00
	00		 jne	 $LN75@inflate_fa
$LN37@inflate_fa:

; 172  :                                 (char *)"invalid distance too far back";
; 173  :                             state->mode = BAD;
; 174  :                             break;
; 175  :                         }
; 176  : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 177  :                         if (len <= op - whave) {
; 178  :                             do {
; 179  :                                 *out++ = 0;
; 180  :                             } while (--len);
; 181  :                             continue;
; 182  :                         }
; 183  :                         len -= op - whave;
; 184  :                         do {
; 185  :                             *out++ = 0;
; 186  :                         } while (--op > whave);
; 187  :                         if (op == 0) {
; 188  :                             from = out - dist;
; 189  :                             do {
; 190  :                                 *out++ = *from++;
; 191  :                             } while (--len);
; 192  :                             continue;
; 193  :                         }
; 194  : #endif
; 195  :                     }
; 196  :                     from = window;
; 197  :                     if (wnext == 0) {           /* very common case */

  00260	45 85 f6	 test	 r14d, r14d
  00263	75 33		 jne	 SHORT $LN38@inflate_fa

; 198  :                         from += wsize - op;

  00265	44 8b 8c 24 90
	00 00 00	 mov	 r9d, DWORD PTR wsize$1$[rsp]
  0026d	44 2b c9	 sub	 r9d, ecx
  00270	4d 03 cf	 add	 r9, r15

; 199  :                         if (op < len) {         /* some from window */

  00273	41 3b cb	 cmp	 ecx, r11d
  00276	0f 83 af 00 00
	00		 jae	 $LN69@inflate_fa

; 200  :                             len -= op;

  0027c	44 2b d9	 sub	 r11d, ecx
  0027f	90		 npad	 1
$LL7@inflate_fa:

; 201  :                             do {
; 202  :                                 *out++ = *from++;

  00280	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00284	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]
  00288	41 88 00	 mov	 BYTE PTR [r8], al
  0028b	49 ff c0	 inc	 r8

; 203  :                             } while (--op);

  0028e	83 c1 ff	 add	 ecx, -1			; ffffffffH
  00291	75 ed		 jne	 SHORT $LL7@inflate_fa

; 204  :                             from = out - dist;  /* rest from output */
; 205  :                         }
; 206  :                     }

  00293	e9 8b 00 00 00	 jmp	 $LN142@inflate_fa
$LN38@inflate_fa:

; 207  :                     else if (wnext < op) {      /* wrap around window */

  00298	41 8b c6	 mov	 eax, r14d
  0029b	2b c1		 sub	 eax, ecx
  0029d	44 3b f1	 cmp	 r14d, ecx
  002a0	73 53		 jae	 SHORT $LN41@inflate_fa

; 208  :                         from += wsize + wnext - op;

  002a2	44 8b 8c 24 90
	00 00 00	 mov	 r9d, DWORD PTR wsize$1$[rsp]

; 209  :                         op -= wnext;

  002aa	41 2b ce	 sub	 ecx, r14d
  002ad	44 03 c8	 add	 r9d, eax
  002b0	4d 03 cf	 add	 r9, r15

; 210  :                         if (op < len) {         /* some from end of window */

  002b3	41 3b cb	 cmp	 ecx, r11d
  002b6	73 73		 jae	 SHORT $LN69@inflate_fa

; 211  :                             len -= op;

  002b8	44 2b d9	 sub	 r11d, ecx
  002bb	4d 2b c8	 sub	 r9, r8
  002be	66 90		 npad	 2
$LL10@inflate_fa:

; 212  :                             do {
; 213  :                                 *out++ = *from++;

  002c0	43 0f b6 04 01	 movzx	 eax, BYTE PTR [r9+r8]
  002c5	41 88 00	 mov	 BYTE PTR [r8], al
  002c8	49 ff c0	 inc	 r8

; 214  :                             } while (--op);

  002cb	83 c1 ff	 add	 ecx, -1			; ffffffffH
  002ce	75 f0		 jne	 SHORT $LL10@inflate_fa

; 215  :                             from = window;

  002d0	4d 8b cf	 mov	 r9, r15

; 216  :                             if (wnext < len) {  /* some from start of window */

  002d3	45 3b f3	 cmp	 r14d, r11d
  002d6	73 53		 jae	 SHORT $LN69@inflate_fa

; 217  :                                 op = wnext;

  002d8	41 8b ce	 mov	 ecx, r14d

; 218  :                                 len -= op;

  002db	45 2b de	 sub	 r11d, r14d
  002de	66 90		 npad	 2
$LL13@inflate_fa:

; 219  :                                 do {
; 220  :                                     *out++ = *from++;

  002e0	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  002e4	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]
  002e8	41 88 00	 mov	 BYTE PTR [r8], al
  002eb	49 ff c0	 inc	 r8

; 221  :                                 } while (--op);

  002ee	83 c1 ff	 add	 ecx, -1			; ffffffffH
  002f1	75 ed		 jne	 SHORT $LL13@inflate_fa

; 222  :                                 from = out - dist;      /* rest from output */
; 223  :                             }
; 224  :                         }
; 225  :                     }

  002f3	eb 2e		 jmp	 SHORT $LN142@inflate_fa
$LN41@inflate_fa:

; 226  :                     else {                      /* contiguous in window */
; 227  :                         from += wnext - op;

  002f5	44 8b c8	 mov	 r9d, eax
  002f8	4d 03 cf	 add	 r9, r15

; 228  :                         if (op < len) {         /* some from window */

  002fb	41 3b cb	 cmp	 ecx, r11d
  002fe	73 2b		 jae	 SHORT $LN69@inflate_fa

; 229  :                             len -= op;

  00300	44 2b d9	 sub	 r11d, ecx
  00303	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL16@inflate_fa:

; 230  :                             do {
; 231  :                                 *out++ = *from++;

  00310	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00314	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]
  00318	41 88 00	 mov	 BYTE PTR [r8], al
  0031b	49 ff c0	 inc	 r8

; 232  :                             } while (--op);

  0031e	83 c1 ff	 add	 ecx, -1			; ffffffffH
  00321	75 ed		 jne	 SHORT $LL16@inflate_fa
$LN142@inflate_fa:

; 233  :                             from = out - dist;  /* rest from output */
; 234  :                         }
; 235  :                     }
; 236  :                     while (len > 2) {

  00323	8b c6		 mov	 eax, esi
  00325	4d 8b c8	 mov	 r9, r8
  00328	4c 2b c8	 sub	 r9, rax
$LN69@inflate_fa:
  0032b	41 83 fb 02	 cmp	 r11d, 2
  0032f	76 49		 jbe	 SHORT $LN18@inflate_fa
  00331	41 8d 4b fd	 lea	 ecx, DWORD PTR [r11-3]
  00335	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0033a	f7 e1		 mul	 ecx
  0033c	d1 ea		 shr	 edx, 1
  0033e	8d 4a 01	 lea	 ecx, DWORD PTR [rdx+1]
  00341	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL17@inflate_fa:

; 237  :                         *out++ = *from++;

  00350	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]

; 238  :                         *out++ = *from++;
; 239  :                         *out++ = *from++;
; 240  :                         len -= 3;

  00354	41 83 c3 fd	 add	 r11d, -3		; fffffffdH
  00358	41 88 00	 mov	 BYTE PTR [r8], al
  0035b	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]
  00360	41 88 40 01	 mov	 BYTE PTR [r8+1], al
  00364	41 0f b6 41 02	 movzx	 eax, BYTE PTR [r9+2]
  00369	49 83 c1 03	 add	 r9, 3
  0036d	41 88 40 02	 mov	 BYTE PTR [r8+2], al
  00371	49 83 c0 03	 add	 r8, 3
  00375	48 2b cd	 sub	 rcx, rbp
  00378	75 d6		 jne	 SHORT $LL17@inflate_fa
$LN18@inflate_fa:

; 241  :                     }
; 242  :                     if (len) {

  0037a	45 85 db	 test	 r11d, r11d
  0037d	0f 84 90 00 00
	00		 je	 $LN103@inflate_fa

; 243  :                         *out++ = *from++;

  00383	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]

; 244  :                         if (len > 1)

  00387	8b b4 24 88 00
	00 00		 mov	 esi, DWORD PTR tv900[rsp]
  0038e	41 88 00	 mov	 BYTE PTR [r8], al
  00391	49 ff c0	 inc	 r8
  00394	44 3b dd	 cmp	 r11d, ebp
  00397	4c 8b 5c 24 08	 mov	 r11, QWORD PTR end$1$[rsp]
  0039c	0f 86 7d 00 00
	00		 jbe	 $LN2@inflate_fa

; 245  :                             *out++ = *from++;

  003a2	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]
  003a7	41 88 00	 mov	 BYTE PTR [r8], al
  003aa	49 ff c0	 inc	 r8

; 246  :                     }
; 247  :                 }

  003ad	eb 70		 jmp	 SHORT $LN2@inflate_fa
$LN34@inflate_fa:

; 248  :                 else {
; 249  :                     from = out - dist;          /* copy direct from output */

  003af	8b c6		 mov	 eax, esi
  003b1	49 8b c8	 mov	 rcx, r8
  003b4	48 2b c8	 sub	 rcx, rax
  003b7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL21@inflate_fa:

; 250  :                     do {                        /* minimum length is three */
; 251  :                         *out++ = *from++;

  003c0	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 252  :                         *out++ = *from++;
; 253  :                         *out++ = *from++;

  003c3	48 8d 49 03	 lea	 rcx, QWORD PTR [rcx+3]
  003c7	41 88 00	 mov	 BYTE PTR [r8], al

; 254  :                         len -= 3;

  003ca	41 83 c3 fd	 add	 r11d, -3		; fffffffdH
  003ce	0f b6 41 fe	 movzx	 eax, BYTE PTR [rcx-2]
  003d2	41 88 40 01	 mov	 BYTE PTR [r8+1], al
  003d6	0f b6 41 ff	 movzx	 eax, BYTE PTR [rcx-1]
  003da	41 88 40 02	 mov	 BYTE PTR [r8+2], al
  003de	49 83 c0 03	 add	 r8, 3

; 255  :                     } while (len > 2);

  003e2	41 83 fb 02	 cmp	 r11d, 2
  003e6	77 d8		 ja	 SHORT $LL21@inflate_fa

; 256  :                     if (len) {

  003e8	45 85 db	 test	 r11d, r11d
  003eb	74 26		 je	 SHORT $LN103@inflate_fa

; 257  :                         *out++ = *from++;

  003ed	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 258  :                         if (len > 1)

  003f0	8b b4 24 88 00
	00 00		 mov	 esi, DWORD PTR tv900[rsp]
  003f7	41 88 00	 mov	 BYTE PTR [r8], al
  003fa	49 ff c0	 inc	 r8
  003fd	44 3b dd	 cmp	 r11d, ebp
  00400	4c 8b 5c 24 08	 mov	 r11, QWORD PTR end$1$[rsp]
  00405	76 18		 jbe	 SHORT $LN2@inflate_fa

; 259  :                             *out++ = *from++;

  00407	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0040b	41 88 00	 mov	 BYTE PTR [r8], al
  0040e	49 ff c0	 inc	 r8
  00411	eb 0c		 jmp	 SHORT $LN2@inflate_fa
$LN103@inflate_fa:

; 285  :             break;
; 286  :         }
; 287  :     } while (in < last && out < end);

  00413	8b b4 24 88 00
	00 00		 mov	 esi, DWORD PTR tv900[rsp]
  0041a	4c 8b 5c 24 08	 mov	 r11, QWORD PTR end$1$[rsp]
$LN2@inflate_fa:
  0041f	48 3b 7c 24 18	 cmp	 rdi, QWORD PTR last$1$[rsp]
  00424	73 66		 jae	 SHORT $LN99@inflate_fa
  00426	4d 3b c3	 cmp	 r8, r11
  00429	73 61		 jae	 SHORT $LN99@inflate_fa
  0042b	8b 14 24	 mov	 edx, DWORD PTR tv901[rsp]
  0042e	e9 6d fc ff ff	 jmp	 $LL4@inflate_fa
$LN52@inflate_fa:

; 275  :             goto dolen;
; 276  :         }
; 277  :         else if (op & 32) {                     /* end-of-block */

  00433	48 8b 74 24 10	 mov	 rsi, QWORD PTR state$1$[rsp]
  00438	f6 c2 20	 test	 dl, 32			; 00000020H
  0043b	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
  00443	74 09		 je	 SHORT $LN54@inflate_fa

; 278  :             Tracevv((stderr, "inflate:         end of block\n"));
; 279  :             state->mode = TYPE;

  00445	c7 46 08 3f 3f
	00 00		 mov	 DWORD PTR [rsi+8], 16191 ; 00003f3fH

; 280  :             break;

  0044c	eb 50		 jmp	 SHORT $LN3@inflate_fa
$LN54@inflate_fa:

; 281  :         }
; 282  :         else {
; 283  :             strm->msg = (char *)"invalid literal/length code";

  0044e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
  00455	48 89 42 20	 mov	 QWORD PTR [rdx+32], rax

; 284  :             state->mode = BAD;

  00459	c7 46 08 51 3f
	00 00		 mov	 DWORD PTR [rsi+8], 16209 ; 00003f51H
  00460	eb 3c		 jmp	 SHORT $LN3@inflate_fa
$LN50@inflate_fa:

; 265  :                 goto dodist;
; 266  :             }
; 267  :             else {
; 268  :                 strm->msg = (char *)"invalid distance code";

  00462	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code@

; 269  :                 state->mode = BAD;
; 270  :                 break;

  00469	eb 07		 jmp	 SHORT $LN143@inflate_fa
$LN75@inflate_fa:

; 171  :                             strm->msg =

  0046b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@
$LN143@inflate_fa:

; 288  : 
; 289  :     /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
; 290  :     len = bits >> 3;

  00472	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
  0047a	48 8b 74 24 10	 mov	 rsi, QWORD PTR state$1$[rsp]
  0047f	48 89 42 20	 mov	 QWORD PTR [rdx+32], rax
  00483	c7 46 08 51 3f
	00 00		 mov	 DWORD PTR [rsi+8], 16209 ; 00003f51H
  0048a	eb 0d		 jmp	 SHORT $LN56@inflate_fa
$LN99@inflate_fa:
  0048c	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
  00494	48 8b 74 24 10	 mov	 rsi, QWORD PTR state$1$[rsp]
$LN56@inflate_fa:
  00499	4c 8b 5c 24 08	 mov	 r11, QWORD PTR end$1$[rsp]
$LN3@inflate_fa:
  0049e	41 8b ca	 mov	 ecx, r10d

; 291  :     in -= len;
; 292  :     bits -= len << 3;
; 293  :     hold &= (1U << bits) - 1;
; 294  : 
; 295  :     /* update state and return */
; 296  :     strm->next_in = in;
; 297  :     strm->next_out = out;

  004a1	4c 89 42 10	 mov	 QWORD PTR [rdx+16], r8
  004a5	c1 e9 03	 shr	 ecx, 3

; 298  :     strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
; 299  :     strm->avail_out = (unsigned)(out < end ?

  004a8	45 2b d8	 sub	 r11d, r8d
  004ab	8b c1		 mov	 eax, ecx
  004ad	41 81 c3 01 01
	00 00		 add	 r11d, 257		; 00000101H
  004b4	48 2b f8	 sub	 rdi, rax
  004b7	44 89 5a 18	 mov	 DWORD PTR [rdx+24], r11d
  004bb	48 89 3a	 mov	 QWORD PTR [rdx], rdi
  004be	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [rcx*8]
  004c5	44 2b d0	 sub	 r10d, eax
  004c8	48 8b 44 24 18	 mov	 rax, QWORD PTR last$1$[rsp]
  004cd	2b c7		 sub	 eax, edi
  004cf	41 8b ca	 mov	 ecx, r10d
  004d2	d3 e5		 shl	 ebp, cl
  004d4	83 c0 05	 add	 eax, 5
  004d7	89 42 08	 mov	 DWORD PTR [rdx+8], eax
  004da	ff cd		 dec	 ebp
  004dc	23 eb		 and	 ebp, ebx

; 300  :                                  257 + (end - out) : 257 - (out - end));
; 301  :     state->hold = hold;
; 302  :     state->bits = bits;

  004de	44 89 56 4c	 mov	 DWORD PTR [rsi+76], r10d
  004e2	89 6e 48	 mov	 DWORD PTR [rsi+72], ebp

; 303  :     return;
; 304  : }

  004e5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  004e9	41 5f		 pop	 r15
  004eb	41 5e		 pop	 r14
  004ed	41 5d		 pop	 r13
  004ef	41 5c		 pop	 r12
  004f1	5f		 pop	 rdi
  004f2	5e		 pop	 rsi
  004f3	5d		 pop	 rbp
  004f4	5b		 pop	 rbx
  004f5	c3		 ret	 0
inflate_fast ENDP
_TEXT	ENDS
END
