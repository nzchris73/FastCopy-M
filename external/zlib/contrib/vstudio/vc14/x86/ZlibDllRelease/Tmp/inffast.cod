; Listing generated by Microsoft (R) Optimizing Compiler Version 19.36.32537.0 

	TITLE	c:\users\chris\documents\github\fastcopy-m\external\zlib\contrib\vstudio\vc14\x86\zlibdllrelease\tmp\inffast.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_inflate_fast
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\inffast.c
;	COMDAT _inflate_fast
_TEXT	SEGMENT
_whave$1$ = -68						; size = 4
_beg$1$ = -64						; size = 4
_end$1$ = -60						; size = 4
_last$1$ = -56						; size = 4
_window$1$ = -52					; size = 4
_wsize$1$ = -48						; size = 4
_dcode$1$ = -44						; size = 4
_lcode$1$ = -40						; size = 4
_op$6$ = -36						; size = 4
_op$3$ = -36						; size = 4
_bits$1$ = -36						; size = 4
_wnext$1$ = -32						; size = 4
_dmask$1$ = -28						; size = 4
_lmask$1$ = -24						; size = 4
_state$1$ = -20						; size = 4
_strm$1$ = -16						; size = 4
_dist$1$ = -12						; size = 4
_hold$1$ = -8						; size = 4
_in$1$ = -4						; size = 4
_inflate_fast PROC					; COMDAT
; _strm$ = ecx
; _start$ = edx

; 50   : void ZLIB_INTERNAL inflate_fast(z_streamp strm, unsigned start) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	89 7d f0	 mov	 DWORD PTR _strm$1$[ebp], edi

; 51   :     struct inflate_state FAR *state;
; 52   :     z_const unsigned char FAR *in;      /* local strm->next_in */
; 53   :     z_const unsigned char FAR *last;    /* have enough input while in < last */
; 54   :     unsigned char FAR *out;     /* local strm->next_out */
; 55   :     unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
; 56   :     unsigned char FAR *end;     /* while out < end, enough space available */
; 57   : #ifdef INFLATE_STRICT
; 58   :     unsigned dmax;              /* maximum distance from zlib header */
; 59   : #endif
; 60   :     unsigned wsize;             /* window size or zero if not using window */
; 61   :     unsigned whave;             /* valid bytes in the window */
; 62   :     unsigned wnext;             /* window write index */
; 63   :     unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
; 64   :     unsigned long hold;         /* local strm->hold */
; 65   :     unsigned bits;              /* local strm->bits */
; 66   :     code const FAR *lcode;      /* local strm->lencode */
; 67   :     code const FAR *dcode;      /* local strm->distcode */
; 68   :     unsigned lmask;             /* mask for first level of length codes */
; 69   :     unsigned dmask;             /* mask for first level of distance codes */
; 70   :     code const *here;           /* retrieved table entry */
; 71   :     unsigned op;                /* code bits, operation, extra bits, or */
; 72   :                                 /*  window position, window bytes to copy */
; 73   :     unsigned len;               /* match length, unused bytes */
; 74   :     unsigned dist;              /* match distance */
; 75   :     unsigned char FAR *from;    /* where to copy match from */
; 76   : 
; 77   :     /* copy state to local variables */
; 78   :     state = (struct inflate_state FAR *)strm->state;

  0000e	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]

; 79   :     in = strm->next_in;
; 80   :     last = in + (strm->avail_in - 5);

  00011	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00014	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00016	83 c0 fb	 add	 eax, -5			; fffffffbH

; 81   :     out = strm->next_out;

  00019	8b 77 0c	 mov	 esi, DWORD PTR [edi+12]
  0001c	03 c3		 add	 eax, ebx
  0001e	89 45 c8	 mov	 DWORD PTR _last$1$[ebp], eax

; 82   :     beg = out - (start - strm->avail_out);

  00021	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00024	8b f8		 mov	 edi, eax

; 83   :     end = out + (strm->avail_out - 257);

  00026	05 ff fe ff ff	 add	 eax, -257		; fffffeffH
  0002b	89 4d ec	 mov	 DWORD PTR _state$1$[ebp], ecx
  0002e	03 c6		 add	 eax, esi
  00030	89 5d fc	 mov	 DWORD PTR _in$1$[ebp], ebx
  00033	89 45 c4	 mov	 DWORD PTR _end$1$[ebp], eax
  00036	2b fa		 sub	 edi, edx

; 84   : #ifdef INFLATE_STRICT
; 85   :     dmax = state->dmax;
; 86   : #endif
; 87   :     wsize = state->wsize;

  00038	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0003b	03 fe		 add	 edi, esi

; 88   :     whave = state->whave;
; 89   :     wnext = state->wnext;
; 90   :     window = state->window;
; 91   :     hold = state->hold;

  0003d	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00040	89 45 d0	 mov	 DWORD PTR _wsize$1$[ebp], eax
  00043	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00046	89 45 bc	 mov	 DWORD PTR _whave$1$[ebp], eax
  00049	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  0004c	89 45 e0	 mov	 DWORD PTR _wnext$1$[ebp], eax
  0004f	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00052	89 45 cc	 mov	 DWORD PTR _window$1$[ebp], eax

; 92   :     bits = state->bits;
; 93   :     lcode = state->lencode;

  00055	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  00058	89 45 d8	 mov	 DWORD PTR _lcode$1$[ebp], eax

; 94   :     dcode = state->distcode;

  0005b	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  0005e	89 45 d4	 mov	 DWORD PTR _dcode$1$[ebp], eax

; 95   :     lmask = (1U << state->lenbits) - 1;

  00061	b8 01 00 00 00	 mov	 eax, 1
  00066	89 45 e8	 mov	 DWORD PTR _lmask$1$[ebp], eax

; 96   :     dmask = (1U << state->distbits) - 1;

  00069	89 45 e4	 mov	 DWORD PTR _dmask$1$[ebp], eax
  0006c	8b 45 ec	 mov	 eax, DWORD PTR _state$1$[ebp]
  0006f	89 7d c0	 mov	 DWORD PTR _beg$1$[ebp], edi
  00072	8b 79 40	 mov	 edi, DWORD PTR [ecx+64]
  00075	8b 49 58	 mov	 ecx, DWORD PTR [ecx+88]
  00078	d3 65 e8	 shl	 DWORD PTR _lmask$1$[ebp], cl
  0007b	8b 48 5c	 mov	 ecx, DWORD PTR [eax+92]
  0007e	8b 45 e4	 mov	 eax, DWORD PTR _dmask$1$[ebp]
  00081	ff 4d e8	 dec	 DWORD PTR _lmask$1$[ebp]
  00084	d3 e0		 shl	 eax, cl
  00086	48		 dec	 eax
  00087	89 45 e4	 mov	 DWORD PTR _dmask$1$[ebp], eax
  0008a	66 0f 1f 44 00
	00		 npad	 6
$LL4@inflate_fa:

; 97   : 
; 98   :     /* decode literals and length/distances until end-of-block or not enough
; 99   :        input data or output space */
; 100  :     do {
; 101  :         if (bits < 15) {

  00090	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  00093	73 24		 jae	 SHORT $LN22@inflate_fa

; 102  :             hold += (unsigned long)(*in++) << bits;

  00095	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00098	8b cf		 mov	 ecx, edi
  0009a	d3 e0		 shl	 eax, cl

; 103  :             bits += 8;
; 104  :             hold += (unsigned long)(*in++) << bits;

  0009c	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  0009f	03 d0		 add	 edx, eax
  000a1	8b 45 fc	 mov	 eax, DWORD PTR _in$1$[ebp]
  000a4	40		 inc	 eax
  000a5	89 45 fc	 mov	 DWORD PTR _in$1$[ebp], eax
  000a8	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
  000ab	43		 inc	 ebx
  000ac	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  000af	d3 e0		 shl	 eax, cl
  000b1	03 d0		 add	 edx, eax
  000b3	89 5d fc	 mov	 DWORD PTR _in$1$[ebp], ebx

; 105  :             bits += 8;

  000b6	83 c7 10	 add	 edi, 16			; 00000010H
$LN22@inflate_fa:

; 106  :         }
; 107  :         here = lcode + (hold & lmask);

  000b9	8b 45 e8	 mov	 eax, DWORD PTR _lmask$1$[ebp]
  000bc	8b 4d d8	 mov	 ecx, DWORD PTR _lcode$1$[ebp]
  000bf	23 c2		 and	 eax, edx
  000c1	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 108  :       dolen:
; 109  :         op = (unsigned)(here->bits);

  000c4	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]

; 110  :         hold >>= op;

  000c8	d3 ea		 shr	 edx, cl

; 111  :         bits -= op;

  000ca	2b f9		 sub	 edi, ecx

; 112  :         op = (unsigned)(here->op);

  000cc	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000cf	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx

; 113  :         if (op == 0) {                          /* literal */

  000d2	85 c9		 test	 ecx, ecx
  000d4	74 3b		 je	 SHORT $LN72@inflate_fa
$dolen$144:

; 118  :         }
; 119  :         else if (op & 16) {                     /* length base */

  000d6	f6 c1 10	 test	 cl, 16			; 00000010H
  000d9	75 41		 jne	 SHORT $LN73@inflate_fa

; 271  :             }
; 272  :         }
; 273  :         else if ((op & 64) == 0) {              /* 2nd level length code */

  000db	f6 c1 40	 test	 cl, 64			; 00000040H
  000de	0f 85 ea 02 00
	00		 jne	 $LN52@inflate_fa

; 274  :             here = lcode + here->val + (hold & ((1U << op) - 1));

  000e4	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  000e8	ba 01 00 00 00	 mov	 edx, 1
  000ed	d3 e2		 shl	 edx, cl
  000ef	4a		 dec	 edx
  000f0	23 55 f8	 and	 edx, DWORD PTR _hold$1$[ebp]
  000f3	03 d0		 add	 edx, eax
  000f5	8b 45 d8	 mov	 eax, DWORD PTR _lcode$1$[ebp]
  000f8	0f b6 4c 90 01	 movzx	 ecx, BYTE PTR [eax+edx*4+1]
  000fd	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  00100	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00103	2b f9		 sub	 edi, ecx
  00105	d3 ea		 shr	 edx, cl
  00107	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0010a	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0010d	85 c9		 test	 ecx, ecx
  0010f	75 c5		 jne	 SHORT $dolen$144
$LN72@inflate_fa:

; 114  :             Tracevv((stderr, here->val >= 0x20 && here->val < 0x7f ?
; 115  :                     "inflate:         literal '%c'\n" :
; 116  :                     "inflate:         literal 0x%02x\n", here->val));
; 117  :             *out++ = (unsigned char)(here->val);

  00111	8a 40 02	 mov	 al, BYTE PTR [eax+2]
  00114	88 06		 mov	 BYTE PTR [esi], al
  00116	46		 inc	 esi

; 241  :                     }
; 242  :                     if (len) {

  00117	e9 59 02 00 00	 jmp	 $LN2@inflate_fa
$LN73@inflate_fa:

; 120  :             len = (unsigned)(here->val);

  0011c	0f b7 58 02	 movzx	 ebx, WORD PTR [eax+2]

; 121  :             op &= 15;                           /* number of extra bits */

  00120	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00123	89 4d dc	 mov	 DWORD PTR _op$3$[ebp], ecx

; 122  :             if (op) {

  00126	74 29		 je	 SHORT $LN27@inflate_fa

; 123  :                 if (bits < op) {

  00128	3b f9		 cmp	 edi, ecx
  0012a	73 15		 jae	 SHORT $LN28@inflate_fa

; 124  :                     hold += (unsigned long)(*in++) << bits;

  0012c	8b 4d fc	 mov	 ecx, DWORD PTR _in$1$[ebp]
  0012f	ff 45 fc	 inc	 DWORD PTR _in$1$[ebp]
  00132	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00135	8b cf		 mov	 ecx, edi
  00137	d3 e0		 shl	 eax, cl
  00139	8b 4d dc	 mov	 ecx, DWORD PTR _op$3$[ebp]
  0013c	03 d0		 add	 edx, eax

; 125  :                     bits += 8;

  0013e	83 c7 08	 add	 edi, 8
$LN28@inflate_fa:

; 126  :                 }
; 127  :                 len += (unsigned)hold & ((1U << op) - 1);

  00141	b8 01 00 00 00	 mov	 eax, 1
  00146	d3 e0		 shl	 eax, cl
  00148	48		 dec	 eax
  00149	23 c2		 and	 eax, edx

; 128  :                 hold >>= op;

  0014b	d3 ea		 shr	 edx, cl
  0014d	03 d8		 add	 ebx, eax

; 129  :                 bits -= op;

  0014f	2b f9		 sub	 edi, ecx
$LN27@inflate_fa:

; 130  :             }
; 131  :             Tracevv((stderr, "inflate:         length %u\n", len));
; 132  :             if (bits < 15) {

  00151	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  00154	73 23		 jae	 SHORT $LN29@inflate_fa

; 133  :                 hold += (unsigned long)(*in++) << bits;

  00156	8b 4d fc	 mov	 ecx, DWORD PTR _in$1$[ebp]
  00159	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  0015c	8b cf		 mov	 ecx, edi
  0015e	d3 e0		 shl	 eax, cl

; 134  :                 bits += 8;
; 135  :                 hold += (unsigned long)(*in++) << bits;

  00160	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00163	03 d0		 add	 edx, eax
  00165	8b 45 fc	 mov	 eax, DWORD PTR _in$1$[ebp]
  00168	40		 inc	 eax
  00169	89 45 fc	 mov	 DWORD PTR _in$1$[ebp], eax
  0016c	ff 45 fc	 inc	 DWORD PTR _in$1$[ebp]
  0016f	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00172	d3 e0		 shl	 eax, cl
  00174	03 d0		 add	 edx, eax

; 136  :                 bits += 8;

  00176	83 c7 10	 add	 edi, 16			; 00000010H
$LN29@inflate_fa:

; 137  :             }
; 138  :             here = dcode + (hold & dmask);

  00179	8b 45 e4	 mov	 eax, DWORD PTR _dmask$1$[ebp]
  0017c	8b 4d d4	 mov	 ecx, DWORD PTR _dcode$1$[ebp]
  0017f	23 c2		 and	 eax, edx
  00181	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 139  :           dodist:
; 140  :             op = (unsigned)(here->bits);

  00184	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]

; 141  :             hold >>= op;

  00188	d3 ea		 shr	 edx, cl

; 142  :             bits -= op;

  0018a	2b f9		 sub	 edi, ecx

; 143  :             op = (unsigned)(here->op);

  0018c	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0018f	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx

; 144  :             if (op & 16) {                      /* distance base */

  00192	f6 c1 10	 test	 cl, 16			; 00000010H
  00195	75 37		 jne	 SHORT $LN74@inflate_fa
$dodist$145:

; 260  :                     }
; 261  :                 }
; 262  :             }
; 263  :             else if ((op & 64) == 0) {          /* 2nd level distance code */

  00197	f6 c1 40	 test	 cl, 64			; 00000040H
  0019a	0f 85 52 02 00
	00		 jne	 $LN50@inflate_fa

; 264  :                 here = dcode + here->val + (hold & ((1U << op) - 1));

  001a0	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  001a4	ba 01 00 00 00	 mov	 edx, 1
  001a9	d3 e2		 shl	 edx, cl
  001ab	4a		 dec	 edx
  001ac	23 55 f8	 and	 edx, DWORD PTR _hold$1$[ebp]
  001af	03 d0		 add	 edx, eax
  001b1	8b 45 d4	 mov	 eax, DWORD PTR _dcode$1$[ebp]
  001b4	0f b6 4c 90 01	 movzx	 ecx, BYTE PTR [eax+edx*4+1]
  001b9	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  001bc	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  001bf	2b f9		 sub	 edi, ecx
  001c1	d3 ea		 shr	 edx, cl
  001c3	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001c6	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  001c9	f6 c1 10	 test	 cl, 16			; 00000010H
  001cc	74 c9		 je	 SHORT $dodist$145
$LN74@inflate_fa:

; 145  :                 dist = (unsigned)(here->val);

  001ce	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]

; 146  :                 op &= 15;                       /* number of extra bits */

  001d2	83 e1 0f	 and	 ecx, 15			; 0000000fH
  001d5	89 45 f4	 mov	 DWORD PTR _dist$1$[ebp], eax
  001d8	89 4d dc	 mov	 DWORD PTR _op$6$[ebp], ecx

; 147  :                 if (bits < op) {

  001db	3b f9		 cmp	 edi, ecx
  001dd	73 2f		 jae	 SHORT $LN33@inflate_fa

; 148  :                     hold += (unsigned long)(*in++) << bits;

  001df	8b 4d fc	 mov	 ecx, DWORD PTR _in$1$[ebp]
  001e2	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  001e5	8b cf		 mov	 ecx, edi
  001e7	d3 e0		 shl	 eax, cl

; 149  :                     bits += 8;

  001e9	83 c7 08	 add	 edi, 8

; 150  :                     if (bits < op) {

  001ec	8b 4d dc	 mov	 ecx, DWORD PTR _op$6$[ebp]
  001ef	03 d0		 add	 edx, eax
  001f1	8b 45 fc	 mov	 eax, DWORD PTR _in$1$[ebp]
  001f4	40		 inc	 eax
  001f5	89 45 fc	 mov	 DWORD PTR _in$1$[ebp], eax
  001f8	3b f9		 cmp	 edi, ecx
  001fa	73 12		 jae	 SHORT $LN33@inflate_fa

; 151  :                         hold += (unsigned long)(*in++) << bits;

  001fc	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  001ff	8b cf		 mov	 ecx, edi
  00201	ff 45 fc	 inc	 DWORD PTR _in$1$[ebp]
  00204	d3 e0		 shl	 eax, cl
  00206	8b 4d dc	 mov	 ecx, DWORD PTR _op$6$[ebp]
  00209	03 d0		 add	 edx, eax

; 152  :                         bits += 8;

  0020b	83 c7 08	 add	 edi, 8
$LN33@inflate_fa:

; 153  :                     }
; 154  :                 }
; 155  :                 dist += (unsigned)hold & ((1U << op) - 1);

  0020e	b8 01 00 00 00	 mov	 eax, 1

; 156  : #ifdef INFLATE_STRICT
; 157  :                 if (dist > dmax) {
; 158  :                     strm->msg = (char *)"invalid distance too far back";
; 159  :                     state->mode = BAD;
; 160  :                     break;
; 161  :                 }
; 162  : #endif
; 163  :                 hold >>= op;
; 164  :                 bits -= op;

  00213	2b f9		 sub	 edi, ecx
  00215	d3 e0		 shl	 eax, cl
  00217	48		 dec	 eax
  00218	89 7d dc	 mov	 DWORD PTR _bits$1$[ebp], edi
  0021b	23 c2		 and	 eax, edx
  0021d	d3 ea		 shr	 edx, cl
  0021f	01 45 f4	 add	 DWORD PTR _dist$1$[ebp], eax

; 165  :                 Tracevv((stderr, "inflate:         distance %u\n", dist));
; 166  :                 op = (unsigned)(out - beg);     /* max distance in output */

  00222	8b c6		 mov	 eax, esi
  00224	2b 45 c0	 sub	 eax, DWORD PTR _beg$1$[ebp]

; 167  :                 if (dist > op) {                /* see if copy from window */

  00227	8b 4d f4	 mov	 ecx, DWORD PTR _dist$1$[ebp]
  0022a	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0022d	3b c8		 cmp	 ecx, eax
  0022f	0f 86 fb 00 00
	00		 jbe	 $LN34@inflate_fa

; 168  :                     op = dist - op;             /* distance back in window */

  00235	2b c8		 sub	 ecx, eax

; 169  :                     if (op > whave) {

  00237	3b 4d bc	 cmp	 ecx, DWORD PTR _whave$1$[ebp]
  0023a	76 10		 jbe	 SHORT $LN37@inflate_fa

; 170  :                         if (state->sane) {

  0023c	8b 45 ec	 mov	 eax, DWORD PTR _state$1$[ebp]
  0023f	83 b8 c4 1b 00
	00 00		 cmp	 DWORD PTR [eax+7108], 0
  00246	0f 85 bf 01 00
	00		 jne	 $LN75@inflate_fa
$LN37@inflate_fa:

; 174  :                             break;
; 175  :                         }
; 176  : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 177  :                         if (len <= op - whave) {
; 178  :                             do {
; 179  :                                 *out++ = 0;
; 180  :                             } while (--len);
; 181  :                             continue;
; 182  :                         }
; 183  :                         len -= op - whave;
; 184  :                         do {
; 185  :                             *out++ = 0;
; 186  :                         } while (--op > whave);
; 187  :                         if (op == 0) {
; 188  :                             from = out - dist;
; 189  :                             do {
; 190  :                                 *out++ = *from++;
; 191  :                             } while (--len);
; 192  :                             continue;
; 193  :                         }
; 194  : #endif
; 195  :                     }
; 196  :                     from = window;

  0024c	8b 45 cc	 mov	 eax, DWORD PTR _window$1$[ebp]

; 197  :                     if (wnext == 0) {           /* very common case */

  0024f	8b 7d e0	 mov	 edi, DWORD PTR _wnext$1$[ebp]
  00252	2b c1		 sub	 eax, ecx
  00254	85 ff		 test	 edi, edi
  00256	75 1a		 jne	 SHORT $LN38@inflate_fa

; 198  :                         from += wsize - op;

  00258	8b 7d d0	 mov	 edi, DWORD PTR _wsize$1$[ebp]
  0025b	03 f8		 add	 edi, eax

; 199  :                         if (op < len) {         /* some from window */

  0025d	3b cb		 cmp	 ecx, ebx
  0025f	73 76		 jae	 SHORT $LN69@inflate_fa

; 200  :                             len -= op;

  00261	2b d9		 sub	 ebx, ecx
$LL7@inflate_fa:

; 201  :                             do {
; 202  :                                 *out++ = *from++;

  00263	8a 07		 mov	 al, BYTE PTR [edi]
  00265	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  00268	88 06		 mov	 BYTE PTR [esi], al
  0026a	46		 inc	 esi

; 203  :                             } while (--op);

  0026b	83 e9 01	 sub	 ecx, 1
  0026e	75 f3		 jne	 SHORT $LL7@inflate_fa

; 204  :                             from = out - dist;  /* rest from output */
; 205  :                         }
; 206  :                     }

  00270	eb 60		 jmp	 SHORT $LN142@inflate_fa
$LN38@inflate_fa:

; 207  :                     else if (wnext < op) {      /* wrap around window */

  00272	03 f8		 add	 edi, eax
  00274	8b 45 e0	 mov	 eax, DWORD PTR _wnext$1$[ebp]
  00277	3b c1		 cmp	 eax, ecx
  00279	73 44		 jae	 SHORT $LN41@inflate_fa

; 208  :                         from += wsize + wnext - op;

  0027b	03 7d d0	 add	 edi, DWORD PTR _wsize$1$[ebp]

; 209  :                         op -= wnext;

  0027e	2b c8		 sub	 ecx, eax

; 210  :                         if (op < len) {         /* some from end of window */

  00280	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00283	3b cb		 cmp	 ecx, ebx
  00285	73 50		 jae	 SHORT $LN69@inflate_fa

; 211  :                             len -= op;

  00287	2b d9		 sub	 ebx, ecx
  00289	2b fe		 sub	 edi, esi
  0028b	0f 1f 44 00 00	 npad	 5
$LL10@inflate_fa:

; 212  :                             do {
; 213  :                                 *out++ = *from++;

  00290	8a 04 37	 mov	 al, BYTE PTR [edi+esi]
  00293	88 06		 mov	 BYTE PTR [esi], al
  00295	46		 inc	 esi

; 214  :                             } while (--op);

  00296	83 e9 01	 sub	 ecx, 1
  00299	75 f5		 jne	 SHORT $LL10@inflate_fa

; 215  :                             from = window;
; 216  :                             if (wnext < len) {  /* some from start of window */

  0029b	8b 45 e0	 mov	 eax, DWORD PTR _wnext$1$[ebp]
  0029e	8b 7d cc	 mov	 edi, DWORD PTR _window$1$[ebp]
  002a1	3b c3		 cmp	 eax, ebx
  002a3	73 32		 jae	 SHORT $LN69@inflate_fa

; 217  :                                 op = wnext;

  002a5	8b c8		 mov	 ecx, eax

; 218  :                                 len -= op;

  002a7	2b d8		 sub	 ebx, eax
  002a9	0f 1f 80 00 00
	00 00		 npad	 7
$LL13@inflate_fa:

; 219  :                                 do {
; 220  :                                     *out++ = *from++;

  002b0	8a 07		 mov	 al, BYTE PTR [edi]
  002b2	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  002b5	88 06		 mov	 BYTE PTR [esi], al
  002b7	46		 inc	 esi

; 221  :                                 } while (--op);

  002b8	83 e9 01	 sub	 ecx, 1
  002bb	75 f3		 jne	 SHORT $LL13@inflate_fa

; 222  :                                 from = out - dist;      /* rest from output */
; 223  :                             }
; 224  :                         }
; 225  :                     }

  002bd	eb 13		 jmp	 SHORT $LN142@inflate_fa
$LN41@inflate_fa:

; 226  :                     else {                      /* contiguous in window */
; 227  :                         from += wnext - op;
; 228  :                         if (op < len) {         /* some from window */

  002bf	3b cb		 cmp	 ecx, ebx
  002c1	73 14		 jae	 SHORT $LN69@inflate_fa

; 229  :                             len -= op;

  002c3	2b d9		 sub	 ebx, ecx
$LL16@inflate_fa:

; 230  :                             do {
; 231  :                                 *out++ = *from++;

  002c5	8a 07		 mov	 al, BYTE PTR [edi]
  002c7	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  002ca	88 06		 mov	 BYTE PTR [esi], al
  002cc	46		 inc	 esi

; 232  :                             } while (--op);

  002cd	83 e9 01	 sub	 ecx, 1
  002d0	75 f3		 jne	 SHORT $LL16@inflate_fa
$LN142@inflate_fa:

; 233  :                             from = out - dist;  /* rest from output */
; 234  :                         }
; 235  :                     }
; 236  :                     while (len > 2) {

  002d2	8b fe		 mov	 edi, esi
  002d4	2b 7d f4	 sub	 edi, DWORD PTR _dist$1$[ebp]
$LN69@inflate_fa:
  002d7	83 fb 02	 cmp	 ebx, 2
  002da	76 38		 jbe	 SHORT $LN18@inflate_fa
  002dc	8d 4b fd	 lea	 ecx, DWORD PTR [ebx-3]
  002df	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  002e4	f7 e1		 mul	 ecx
  002e6	d1 ea		 shr	 edx, 1
  002e8	42		 inc	 edx
  002e9	0f 1f 80 00 00
	00 00		 npad	 7
$LL17@inflate_fa:

; 237  :                         *out++ = *from++;

  002f0	0f b6 07	 movzx	 eax, BYTE PTR [edi]

; 238  :                         *out++ = *from++;
; 239  :                         *out++ = *from++;
; 240  :                         len -= 3;

  002f3	83 eb 03	 sub	 ebx, 3
  002f6	88 06		 mov	 BYTE PTR [esi], al
  002f8	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  002fc	88 46 01	 mov	 BYTE PTR [esi+1], al
  002ff	0f b6 47 02	 movzx	 eax, BYTE PTR [edi+2]
  00303	83 c7 03	 add	 edi, 3
  00306	88 46 02	 mov	 BYTE PTR [esi+2], al
  00309	83 c6 03	 add	 esi, 3
  0030c	83 ea 01	 sub	 edx, 1
  0030f	75 df		 jne	 SHORT $LL17@inflate_fa
  00311	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN18@inflate_fa:

; 241  :                     }
; 242  :                     if (len) {

  00314	85 db		 test	 ebx, ebx
  00316	74 57		 je	 SHORT $LN98@inflate_fa

; 243  :                         *out++ = *from++;

  00318	8a 07		 mov	 al, BYTE PTR [edi]
  0031a	88 06		 mov	 BYTE PTR [esi], al
  0031c	46		 inc	 esi

; 244  :                         if (len > 1)

  0031d	83 fb 01	 cmp	 ebx, 1
  00320	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
  00323	76 06		 jbe	 SHORT $LN99@inflate_fa

; 245  :                             *out++ = *from++;

  00325	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00328	88 06		 mov	 BYTE PTR [esi], al
  0032a	46		 inc	 esi
$LN99@inflate_fa:

; 285  :             break;
; 286  :         }
; 287  :     } while (in < last && out < end);

  0032b	8b 7d dc	 mov	 edi, DWORD PTR _bits$1$[ebp]
  0032e	eb 45		 jmp	 SHORT $LN2@inflate_fa
$LN34@inflate_fa:

; 246  :                     }
; 247  :                 }
; 248  :                 else {
; 249  :                     from = out - dist;          /* copy direct from output */

  00330	8b ce		 mov	 ecx, esi
  00332	2b 4d f4	 sub	 ecx, DWORD PTR _dist$1$[ebp]
$LL21@inflate_fa:

; 250  :                     do {                        /* minimum length is three */
; 251  :                         *out++ = *from++;

  00335	0f b6 01	 movzx	 eax, BYTE PTR [ecx]

; 252  :                         *out++ = *from++;
; 253  :                         *out++ = *from++;

  00338	8d 49 03	 lea	 ecx, DWORD PTR [ecx+3]
  0033b	88 06		 mov	 BYTE PTR [esi], al

; 254  :                         len -= 3;

  0033d	83 eb 03	 sub	 ebx, 3
  00340	0f b6 41 fe	 movzx	 eax, BYTE PTR [ecx-2]
  00344	88 46 01	 mov	 BYTE PTR [esi+1], al
  00347	0f b6 41 ff	 movzx	 eax, BYTE PTR [ecx-1]
  0034b	88 46 02	 mov	 BYTE PTR [esi+2], al
  0034e	83 c6 03	 add	 esi, 3

; 255  :                     } while (len > 2);

  00351	83 fb 02	 cmp	 ebx, 2
  00354	77 df		 ja	 SHORT $LL21@inflate_fa

; 256  :                     if (len) {

  00356	85 db		 test	 ebx, ebx
  00358	74 18		 je	 SHORT $LN101@inflate_fa

; 257  :                         *out++ = *from++;

  0035a	8a 01		 mov	 al, BYTE PTR [ecx]
  0035c	88 06		 mov	 BYTE PTR [esi], al
  0035e	46		 inc	 esi

; 258  :                         if (len > 1)

  0035f	83 fb 01	 cmp	 ebx, 1
  00362	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
  00365	76 0e		 jbe	 SHORT $LN2@inflate_fa

; 259  :                             *out++ = *from++;

  00367	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  0036a	88 06		 mov	 BYTE PTR [esi], al
  0036c	46		 inc	 esi
  0036d	eb 06		 jmp	 SHORT $LN2@inflate_fa
$LN98@inflate_fa:

; 241  :                     }
; 242  :                     if (len) {

  0036f	8b 7d dc	 mov	 edi, DWORD PTR _bits$1$[ebp]
$LN101@inflate_fa:

; 285  :             break;
; 286  :         }
; 287  :     } while (in < last && out < end);

  00372	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
$LN2@inflate_fa:
  00375	3b 5d c8	 cmp	 ebx, DWORD PTR _last$1$[ebp]
  00378	73 09		 jae	 SHORT $LN103@inflate_fa
  0037a	3b 75 c4	 cmp	 esi, DWORD PTR _end$1$[ebp]
  0037d	0f 82 0d fd ff
	ff		 jb	 $LL4@inflate_fa
$LN103@inflate_fa:

; 288  : 
; 289  :     /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
; 290  :     len = bits >> 3;

  00383	8b 5d f0	 mov	 ebx, DWORD PTR _strm$1$[ebp]
$LN3@inflate_fa:

; 291  :     in -= len;

  00386	8b 4d fc	 mov	 ecx, DWORD PTR _in$1$[ebp]
  00389	8b c7		 mov	 eax, edi
  0038b	c1 e8 03	 shr	 eax, 3
  0038e	2b c8		 sub	 ecx, eax

; 292  :     bits -= len << 3;
; 293  :     hold &= (1U << bits) - 1;
; 294  : 
; 295  :     /* update state and return */
; 296  :     strm->next_in = in;
; 297  :     strm->next_out = out;

  00390	89 73 0c	 mov	 DWORD PTR [ebx+12], esi
  00393	c1 e0 03	 shl	 eax, 3
  00396	2b f8		 sub	 edi, eax
  00398	89 0b		 mov	 DWORD PTR [ebx], ecx

; 298  :     strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));

  0039a	8b 45 c8	 mov	 eax, DWORD PTR _last$1$[ebp]
  0039d	2b c1		 sub	 eax, ecx
  0039f	8b cf		 mov	 ecx, edi
  003a1	83 c0 05	 add	 eax, 5
  003a4	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 299  :     strm->avail_out = (unsigned)(out < end ?

  003a7	8b 45 c4	 mov	 eax, DWORD PTR _end$1$[ebp]
  003aa	2b c6		 sub	 eax, esi
  003ac	05 01 01 00 00	 add	 eax, 257		; 00000101H
  003b1	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  003b4	b8 01 00 00 00	 mov	 eax, 1
  003b9	d3 e0		 shl	 eax, cl

; 300  :                                  257 + (end - out) : 257 - (out - end));
; 301  :     state->hold = hold;

  003bb	8b 4d ec	 mov	 ecx, DWORD PTR _state$1$[ebp]
  003be	48		 dec	 eax
  003bf	23 c2		 and	 eax, edx

; 302  :     state->bits = bits;

  003c1	89 79 40	 mov	 DWORD PTR [ecx+64], edi
  003c4	5f		 pop	 edi
  003c5	5e		 pop	 esi
  003c6	89 41 3c	 mov	 DWORD PTR [ecx+60], eax
  003c9	5b		 pop	 ebx

; 303  :     return;
; 304  : }

  003ca	8b e5		 mov	 esp, ebp
  003cc	5d		 pop	 ebp
  003cd	c3		 ret	 0
$LN52@inflate_fa:

; 275  :             goto dolen;
; 276  :         }
; 277  :         else if (op & 32) {                     /* end-of-block */

  003ce	8b 45 ec	 mov	 eax, DWORD PTR _state$1$[ebp]
  003d1	8b 5d f0	 mov	 ebx, DWORD PTR _strm$1$[ebp]
  003d4	f6 c1 20	 test	 cl, 32			; 00000020H
  003d7	74 09		 je	 SHORT $LN54@inflate_fa

; 278  :             Tracevv((stderr, "inflate:         end of block\n"));
; 279  :             state->mode = TYPE;

  003d9	c7 40 04 3f 3f
	00 00		 mov	 DWORD PTR [eax+4], 16191 ; 00003f3fH

; 280  :             break;

  003e0	eb a4		 jmp	 SHORT $LN3@inflate_fa
$LN54@inflate_fa:

; 281  :         }
; 282  :         else {
; 283  :             strm->msg = (char *)"invalid literal/length code";

  003e2	c7 43 18 00 00
	00 00		 mov	 DWORD PTR [ebx+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@

; 284  :             state->mode = BAD;

  003e9	c7 40 04 51 3f
	00 00		 mov	 DWORD PTR [eax+4], 16209 ; 00003f51H
  003f0	eb 94		 jmp	 SHORT $LN3@inflate_fa
$LN50@inflate_fa:

; 265  :                 goto dodist;
; 266  :             }
; 267  :             else {
; 268  :                 strm->msg = (char *)"invalid distance code";

  003f2	8b 5d f0	 mov	 ebx, DWORD PTR _strm$1$[ebp]

; 269  :                 state->mode = BAD;

  003f5	8b 45 ec	 mov	 eax, DWORD PTR _state$1$[ebp]
  003f8	c7 43 18 00 00
	00 00		 mov	 DWORD PTR [ebx+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code@
  003ff	c7 40 04 51 3f
	00 00		 mov	 DWORD PTR [eax+4], 16209 ; 00003f51H

; 270  :                 break;

  00406	e9 7b ff ff ff	 jmp	 $LN3@inflate_fa
$LN75@inflate_fa:

; 171  :                             strm->msg =

  0040b	8b 5d f0	 mov	 ebx, DWORD PTR _strm$1$[ebp]
  0040e	c7 43 18 00 00
	00 00		 mov	 DWORD PTR [ebx+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@

; 172  :                                 (char *)"invalid distance too far back";
; 173  :                             state->mode = BAD;

  00415	c7 40 04 51 3f
	00 00		 mov	 DWORD PTR [eax+4], 16209 ; 00003f51H

; 285  :             break;
; 286  :         }
; 287  :     } while (in < last && out < end);

  0041c	e9 65 ff ff ff	 jmp	 $LN3@inflate_fa
_inflate_fast ENDP
_TEXT	ENDS
END
