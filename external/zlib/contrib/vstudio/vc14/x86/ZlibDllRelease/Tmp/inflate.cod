; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31935.0 

	TITLE	c:\users\chris\documents\github\zlib\contrib\vstudio\vc14\x86\zlibdllrelease\tmp\inflate.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check@	; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@	; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check@	; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check@ DB 'incorrect length check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@ DB 'unknown header flags '
	DB	'set', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ DB 'unknown compression '
	DB	'method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check@ DB 'incorrect header check', 00H ; `string'
	ORG $+2
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	_inflateCodesUsed@4
PUBLIC	_inflateMark@4
PUBLIC	_inflateValidate@8
PUBLIC	_inflateUndermine@8
PUBLIC	_inflateCopy@8
PUBLIC	_inflateSyncPoint@4
PUBLIC	_inflateSync@4
PUBLIC	_inflateGetHeader@8
PUBLIC	_inflateSetDictionary@12
PUBLIC	_inflateGetDictionary@12
PUBLIC	_inflatePrime@12
PUBLIC	_inflateInit_@12
PUBLIC	_inflateReset2@8
PUBLIC	_inflateResetKeep@4
PUBLIC	_inflateEnd@4
PUBLIC	_inflate@8
PUBLIC	_inflateInit2_@16
PUBLIC	_inflateReset@4
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateReset@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateReset@4 PROC					; COMDAT

; 147  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 148  :     struct inflate_state FAR *state;
; 149  : 
; 150  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateRes
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 156  : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN2@inflateRes:

; 151  :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 152  :     state->wsize = 0;
; 153  :     state->whave = 0;
; 154  :     state->wnext = 0;
; 155  :     return inflateResetKeep(strm);

  0001b	89 4d 08	 mov	 DWORD PTR _strm$[ebp], ecx
  0001e	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0
  00025	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0
  0002c	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0

; 156  : }

  00033	5d		 pop	 ebp

; 152  :     state->wsize = 0;
; 153  :     state->whave = 0;
; 154  :     state->wnext = 0;
; 155  :     return inflateResetKeep(strm);

  00034	e9 00 00 00 00	 jmp	 _inflateResetKeep@4
_inflateReset@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateInit2_@16
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_version$ = 16						; size = 4
_stream_size$ = 20					; size = 4
_inflateInit2_@16 PROC					; COMDAT

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  :     int ret;
; 205  :     struct inflate_state FAR *state;
; 206  : 
; 207  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  00003	8b 45 10	 mov	 eax, DWORD PTR _version$[ebp]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  0000a	85 c0		 test	 eax, eax
  0000c	0f 84 ac 00 00
	00		 je	 $LN3@inflateIni
  00012	80 38 31	 cmp	 BYTE PTR [eax], 49	; 00000031H
  00015	0f 85 a3 00 00
	00		 jne	 $LN3@inflateIni
  0001b	83 7d 14 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  0001f	0f 85 99 00 00
	00		 jne	 $LN3@inflateIni

; 210  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00025	85 f6		 test	 esi, esi
  00027	75 08		 jne	 SHORT $LN4@inflateIni
  00029	8d 46 fe	 lea	 eax, DWORD PTR [esi-2]
  0002c	5e		 pop	 esi

; 240  : }

  0002d	5d		 pop	 ebp
  0002e	c2 10 00	 ret	 16			; 00000010H
$LN4@inflateIni:

; 211  :     strm->msg = Z_NULL;                 /* in case we return an error */
; 212  :     if (strm->zalloc == (alloc_func)0) {

  00031	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00034	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  0003b	85 c0		 test	 eax, eax
  0003d	75 13		 jne	 SHORT $LN10@inflateIni

; 213  : #ifdef Z_SOLO
; 214  :         return Z_STREAM_ERROR;
; 215  : #else
; 216  :         strm->zalloc = zcalloc;
; 217  :         strm->opaque = (voidpf)0;

  0003f	89 46 28	 mov	 DWORD PTR [esi+40], eax
  00042	33 c9		 xor	 ecx, ecx
  00044	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET _zcalloc
  0004b	b8 00 00 00 00	 mov	 eax, OFFSET _zcalloc
  00050	eb 03		 jmp	 SHORT $LN5@inflateIni
$LN10@inflateIni:
  00052	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
$LN5@inflateIni:

; 218  : #endif
; 219  :     }
; 220  :     if (strm->zfree == (free_func)0)

  00055	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00059	75 07		 jne	 SHORT $LN6@inflateIni

; 221  : #ifdef Z_SOLO
; 222  :         return Z_STREAM_ERROR;
; 223  : #else
; 224  :         strm->zfree = zcfree;

  0005b	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], OFFSET _zcfree
$LN6@inflateIni:
  00062	57		 push	 edi

; 225  : #endif
; 226  :     state = (struct inflate_state FAR *)

  00063	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  00068	6a 01		 push	 1
  0006a	51		 push	 ecx
  0006b	ff d0		 call	 eax
  0006d	8b f8		 mov	 edi, eax
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 227  :             ZALLOC(strm, 1, sizeof(struct inflate_state));
; 228  :     if (state == Z_NULL) return Z_MEM_ERROR;

  00072	85 ff		 test	 edi, edi
  00074	75 09		 jne	 SHORT $LN7@inflateIni
  00076	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi

; 240  : }

  0007b	5d		 pop	 ebp
  0007c	c2 10 00	 ret	 16			; 00000010H
$LN7@inflateIni:
  0007f	53		 push	 ebx

; 229  :     Tracev((stderr, "inflate: allocated\n"));
; 230  :     strm->state = (struct internal_state FAR *)state;
; 231  :     state->strm = strm;
; 232  :     state->window = Z_NULL;
; 233  :     state->mode = HEAD;     /* to pass state test in inflateReset2() */
; 234  :     ret = inflateReset2(strm, windowBits);

  00080	ff 75 0c	 push	 DWORD PTR _windowBits$[ebp]
  00083	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  00086	56		 push	 esi
  00087	89 37		 mov	 DWORD PTR [edi], esi
  00089	c7 47 38 00 00
	00 00		 mov	 DWORD PTR [edi+56], 0
  00090	c7 47 04 34 3f
	00 00		 mov	 DWORD PTR [edi+4], 16180 ; 00003f34H
  00097	e8 00 00 00 00	 call	 _inflateReset2@8
  0009c	8b d8		 mov	 ebx, eax

; 235  :     if (ret != Z_OK) {

  0009e	85 db		 test	 ebx, ebx
  000a0	74 13		 je	 SHORT $LN8@inflateIni

; 236  :         ZFREE(strm, state);

  000a2	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  000a5	57		 push	 edi
  000a6	ff 76 28	 push	 DWORD PTR [esi+40]
  000a9	ff d1		 call	 ecx
  000ab	83 c4 08	 add	 esp, 8

; 237  :         strm->state = Z_NULL;

  000ae	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
$LN8@inflateIni:

; 238  :     }
; 239  :     return ret;

  000b5	8b c3		 mov	 eax, ebx
  000b7	5b		 pop	 ebx
  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi

; 240  : }

  000ba	5d		 pop	 ebp
  000bb	c2 10 00	 ret	 16			; 00000010H
$LN3@inflateIni:

; 208  :         stream_size != (int)(sizeof(z_stream)))
; 209  :         return Z_VERSION_ERROR;

  000be	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  000c3	5e		 pop	 esi

; 240  : }

  000c4	5d		 pop	 ebp
  000c5	c2 10 00	 ret	 16			; 00000010H
_inflateInit2_@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflate@8
_TEXT	SEGMENT
tv5116 = -68						; size = 4
_copy$8$ = -64						; size = 4
tv5181 = -64						; size = 4
tv5176 = -64						; size = 4
tv5171 = -64						; size = 4
tv5105 = -64						; size = 4
tv5094 = -64						; size = 4
tv5074 = -64						; size = 4
tv4993 = -64						; size = 4
tv4971 = -64						; size = 4
tv4968 = -64						; size = 4
tv4967 = -64						; size = 4
tv4965 = -64						; size = 4
tv4962 = -64						; size = 4
tv4951 = -64						; size = 4
tv4950 = -64						; size = 4
tv4941 = -64						; size = 4
tv4693 = -64						; size = 4
_copy$3$ = -64						; size = 4
tv5121 = -60						; size = 4
_in$1$ = -56						; size = 4
$T1 = -52						; size = 4
$T2 = -52						; size = 4
$T3 = -52						; size = 4
$T4 = -52						; size = 4
$T5 = -52						; size = 4
tv5183 = -52						; size = 4
tv5075 = -52						; size = 4
tv5048 = -52						; size = 4
tv5001 = -52						; size = 4
tv5000 = -52						; size = 4
tv4998 = -52						; size = 4
tv4992 = -52						; size = 4
tv4990 = -52						; size = 4
tv4985 = -52						; size = 4
tv4984 = -52						; size = 4
tv4983 = -52						; size = 4
tv4970 = -52						; size = 4
_copy$5$ = -52						; size = 4
_copy$2$ = -52						; size = 4
_copy$1$ = -52						; size = 4
$T6 = -48						; size = 4
$T7 = -48						; size = 4
_from$1$ = -48						; size = 4
tv5173 = -48						; size = 4
tv5169 = -48						; size = 4
tv5113 = -48						; size = 4
tv5111 = -48						; size = 4
tv4940 = -48						; size = 4
_copy$4$ = -48						; size = 4
_len$1$ = -48						; size = 4
_ret$1$ = -44						; size = 4
$T8 = -40						; size = 4
$T9 = -40						; size = 4
_copy$7$ = -40						; size = 4
_copy$6$ = -40						; size = 4
tv5143 = -40						; size = 4
tv5115 = -40						; size = 4
tv5112 = -40						; size = 4
tv4679 = -40						; size = 4
_out$1$ = -36						; size = 4
_put$1$ = -32						; size = 4
_hbuf$ = -28						; size = 4
_left$1$ = -24						; size = 4
_bits$1$ = -20						; size = 4
_len$2$ = -16						; size = 4
_next$1$ = -16						; size = 4
_hold$1$ = -12						; size = 4
_state$1$ = -8						; size = 4
tv5123 = -1						; size = 1
tv5122 = -1						; size = 1
tv4924 = 8						; size = 4
_strm$ = 8						; size = 4
_flush$ = 12						; size = 4
_inflate@8 PROC						; COMDAT

; 628  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 629  :     struct inflate_state FAR *state;
; 630  :     z_const unsigned char FAR *next;    /* next input */
; 631  :     unsigned char FAR *put;     /* next output */
; 632  :     unsigned have, left;        /* available input and output */
; 633  :     unsigned long hold;         /* bit buffer */
; 634  :     unsigned bits;              /* bits in bit buffer */
; 635  :     unsigned in, out;           /* save starting available input and output */
; 636  :     unsigned copy;              /* number of stored or match bytes to copy */
; 637  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 638  :     code here;                  /* current decoding table entry */
; 639  :     code last;                  /* parent table entry */
; 640  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 641  :     int ret;                    /* return code */
; 642  : #ifdef GUNZIP
; 643  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 644  : #endif
; 645  :     static const unsigned short order[19] = /* permutation of code lengths */
; 646  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 647  : 
; 648  :     if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	83 ec 44	 sub	 esp, 68			; 00000044H
  00009	8b ca		 mov	 ecx, edx
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	e8 00 00 00 00	 call	 _inflateStateCheck
  00013	85 c0		 test	 eax, eax
  00015	0f 85 52 15 00
	00		 jne	 $LN333@inflate
  0001b	39 42 0c	 cmp	 DWORD PTR [edx+12], eax
  0001e	0f 84 49 15 00
	00		 je	 $LN333@inflate
  00024	39 02		 cmp	 DWORD PTR [edx], eax
  00026	75 09		 jne	 SHORT $LN721@inflate
  00028	39 42 04	 cmp	 DWORD PTR [edx+4], eax
  0002b	0f 85 3c 15 00
	00		 jne	 $LN333@inflate
$LN721@inflate:

; 649  :         (strm->next_in == Z_NULL && strm->avail_in != 0))
; 650  :         return Z_STREAM_ERROR;
; 651  : 
; 652  :     state = (struct inflate_state FAR *)strm->state;

  00031	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  00034	89 4d f8	 mov	 DWORD PTR _state$1$[ebp], ecx

; 653  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00037	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0003a	3d 3f 3f 00 00	 cmp	 eax, 16191		; 00003f3fH
  0003f	75 0c		 jne	 SHORT $LN4@inflate
  00041	c7 41 04 40 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16192 ; 00003f40H
  00048	b8 40 3f 00 00	 mov	 eax, 16192		; 00003f40H
$LN4@inflate:

; 654  :     LOAD();

  0004d	8b 5a 0c	 mov	 ebx, DWORD PTR [edx+12]

; 655  :     in = have;
; 656  :     out = left;
; 657  :     ret = Z_OK;
; 658  :     for (;;)
; 659  :         switch (state->mode) {

  00050	05 cc c0 ff ff	 add	 eax, -16180		; ffffc0ccH
  00055	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  00058	8b 71 40	 mov	 esi, DWORD PTR [ecx+64]
  0005b	89 5d e0	 mov	 DWORD PTR _put$1$[ebp], ebx
  0005e	8b 5a 10	 mov	 ebx, DWORD PTR [edx+16]
  00061	89 5d e8	 mov	 DWORD PTR _left$1$[ebp], ebx
  00064	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00066	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00069	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  0006c	8b 5d e8	 mov	 ebx, DWORD PTR _left$1$[ebp]
  0006f	89 5d dc	 mov	 DWORD PTR _out$1$[ebp], ebx
  00072	8b 5d f0	 mov	 ebx, DWORD PTR _next$1$[ebp]
  00075	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00078	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0007b	89 7d c8	 mov	 DWORD PTR _in$1$[ebp], edi
  0007e	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _ret$1$[ebp], 0
  00085	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00088	0f 87 df 14 00
	00		 ja	 $LN333@inflate

; 979  :                 for (;;) {
; 980  :                     here = state->lencode[BITS(state->lenbits)];

  0008e	8d 51 58	 lea	 edx, DWORD PTR [ecx+88]
  00091	89 55 c4	 mov	 DWORD PTR tv5121[ebp], edx

; 1124 :                 /* fallthrough */
; 1125 :         case DIST:
; 1126 :             for (;;) {
; 1127 :                 here = state->distcode[BITS(state->distbits)];

  00094	8d 51 5c	 lea	 edx, DWORD PTR [ecx+92]
  00097	89 55 bc	 mov	 DWORD PTR tv5116[ebp], edx
  0009a	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  0009d	0f 1f 00	 npad	 3
$LL5@inflate:

; 655  :     in = have;
; 656  :     out = left;
; 657  :     ret = Z_OK;
; 658  :     for (;;)
; 659  :         switch (state->mode) {

  000a0	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN791@inflate[eax*4]
$LN335@inflate:

; 660  :         case HEAD:
; 661  :             if (state->wrap == 0) {

  000a7	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  000aa	89 45 cc	 mov	 DWORD PTR tv5075[ebp], eax
  000ad	85 c0		 test	 eax, eax
  000af	75 0c		 jne	 SHORT $LN12@inflate

; 662  :                 state->mode = TYPEDO;

  000b1	c7 41 04 40 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16192 ; 00003f40H

; 663  :                 break;

  000b8	e9 9f 14 00 00	 jmp	 $LN8@inflate
$LN12@inflate:

; 664  :             }
; 665  :             NEEDBITS(16);

  000bd	83 fe 10	 cmp	 esi, 16			; 00000010H
  000c0	73 2a		 jae	 SHORT $LN10@inflate
$LL13@inflate:
  000c2	85 ff		 test	 edi, edi
  000c4	0f 84 0d 05 00
	00		 je	 $LN919@inflate
  000ca	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  000cd	8b ce		 mov	 ecx, esi
  000cf	d3 e0		 shl	 eax, cl
  000d1	83 c6 08	 add	 esi, 8
  000d4	03 d0		 add	 edx, eax
  000d6	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  000d9	43		 inc	 ebx
  000da	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  000dd	4f		 dec	 edi
  000de	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  000e1	83 fe 10	 cmp	 esi, 16			; 00000010H
  000e4	72 dc		 jb	 SHORT $LL13@inflate
  000e6	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  000e9	8b 45 cc	 mov	 eax, DWORD PTR tv5075[ebp]
$LN10@inflate:

; 666  : #ifdef GUNZIP
; 667  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  000ec	a8 02		 test	 al, 2
  000ee	74 5a		 je	 SHORT $LN338@inflate
  000f0	81 fa 1f 8b 00
	00		 cmp	 edx, 35615		; 00008b1fH
  000f6	75 52		 jne	 SHORT $LN338@inflate

; 668  :                 if (state->wbits == 0)

  000f8	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  000fc	75 07		 jne	 SHORT $LN339@inflate

; 669  :                     state->wbits = 15;

  000fe	c7 41 28 0f 00
	00 00		 mov	 DWORD PTR [ecx+40], 15	; 0000000fH
$LN339@inflate:

; 670  :                 state->check = crc32(0L, Z_NULL, 0);

  00105	6a 00		 push	 0
  00107	6a 00		 push	 0
  00109	6a 00		 push	 0
  0010b	e8 00 00 00 00	 call	 _crc32@12
  00110	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 671  :                 CRC2(state->check, hold);

  00113	6a 02		 push	 2
  00115	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00118	8b 4d f4	 mov	 ecx, DWORD PTR _hold$1$[ebp]
  0011b	88 4d e4	 mov	 BYTE PTR _hbuf$[ebp], cl
  0011e	c1 e9 08	 shr	 ecx, 8
  00121	88 4d e5	 mov	 BYTE PTR _hbuf$[ebp+1], cl
  00124	8d 4d e4	 lea	 ecx, DWORD PTR _hbuf$[ebp]
  00127	51		 push	 ecx
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 _crc32@12
  0012e	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 672  :                 INITBITS();

  00131	33 d2		 xor	 edx, edx
  00133	33 f6		 xor	 esi, esi
  00135	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00138	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0013b	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 673  :                 state->mode = FLAGS;

  0013e	c7 41 04 35 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16181 ; 00003f35H

; 674  :                 break;

  00145	e9 12 14 00 00	 jmp	 $LN8@inflate
$LN338@inflate:

; 675  :             }
; 676  :             if (state->head != Z_NULL)

  0014a	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0014d	85 c0		 test	 eax, eax
  0014f	74 07		 je	 SHORT $LN340@inflate

; 677  :                 state->head->done = -1;

  00151	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [eax+48], -1
$LN340@inflate:

; 678  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */

  00158	f6 41 0c 01	 test	 BYTE PTR [ecx+12], 1
  0015c	0f 84 cf 00 00
	00		 je	 $LN342@inflate
  00162	0f b6 ca	 movzx	 ecx, dl
  00165	8b c2		 mov	 eax, edx
  00167	c1 e1 08	 shl	 ecx, 8
  0016a	33 d2		 xor	 edx, edx
  0016c	c1 e8 08	 shr	 eax, 8
  0016f	03 c1		 add	 eax, ecx
  00171	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  00176	f7 f1		 div	 ecx
  00178	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0017b	85 d2		 test	 edx, edx
  0017d	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00180	0f 85 ab 00 00
	00		 jne	 $LN342@inflate

; 686  :             }
; 687  :             if (BITS(4) != Z_DEFLATED) {

  00186	8b c2		 mov	 eax, edx
  00188	24 0f		 and	 al, 15			; 0000000fH
  0018a	3c 08		 cmp	 al, 8
  0018c	74 0f		 je	 SHORT $LN26@inflate

; 688  :                 strm->msg = (char *)"unknown compression method";

  0018e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00191	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@

; 689  :                 state->mode = BAD;
; 690  :                 break;

  00198	e9 b8 13 00 00	 jmp	 $LN948@inflate
$LN26@inflate:

; 691  :             }
; 692  :             DROPBITS(4);

  0019d	c1 ea 04	 shr	 edx, 4
  001a0	83 ee 04	 sub	 esi, 4

; 693  :             len = BITS(4) + 8;

  001a3	8b c2		 mov	 eax, edx
  001a5	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  001a8	83 e0 0f	 and	 eax, 15			; 0000000fH
  001ab	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  001ae	83 c0 08	 add	 eax, 8
  001b1	89 45 d0	 mov	 DWORD PTR _len$1$[ebp], eax

; 694  :             if (state->wbits == 0)

  001b4	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  001b7	85 c0		 test	 eax, eax
  001b9	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  001bc	8b 45 d0	 mov	 eax, DWORD PTR _len$1$[ebp]
  001bf	75 06		 jne	 SHORT $LN344@inflate

; 695  :                 state->wbits = len;

  001c1	89 41 28	 mov	 DWORD PTR [ecx+40], eax
  001c4	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
$LN344@inflate:

; 696  :             if (len > 15 || len > state->wbits) {

  001c7	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  001ca	77 56		 ja	 SHORT $LN346@inflate
  001cc	3b 45 cc	 cmp	 eax, DWORD PTR $T3[ebp]
  001cf	77 51		 ja	 SHORT $LN346@inflate

; 700  :             }
; 701  :             state->dmax = 1U << len;

  001d1	8b 4d d0	 mov	 ecx, DWORD PTR _len$1$[ebp]
  001d4	b8 01 00 00 00	 mov	 eax, 1
  001d9	d3 e0		 shl	 eax, cl
  001db	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 702  :             state->flags = 0;               /* indicate zlib header */
; 703  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 704  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  001de	6a 00		 push	 0
  001e0	6a 00		 push	 0
  001e2	6a 00		 push	 0
  001e4	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  001e7	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  001ee	e8 00 00 00 00	 call	 _adler32@12
  001f3	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  001f6	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  001f9	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  001fc	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 705  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  001ff	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00202	c1 ea 08	 shr	 edx, 8
  00205	f7 d2		 not	 edx
  00207	83 e2 02	 and	 edx, 2
  0020a	81 ca 3d 3f 00
	00		 or	 edx, 16189		; 00003f3dH
  00210	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 706  :             INITBITS();

  00213	33 d2		 xor	 edx, edx
  00215	33 f6		 xor	 esi, esi
  00217	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  0021a	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 707  :             break;

  0021d	e9 3a 13 00 00	 jmp	 $LN8@inflate
$LN346@inflate:

; 697  :                 strm->msg = (char *)"invalid window size";

  00222	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00225	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@EMOGCLGO@invalid?5window?5size@

; 698  :                 state->mode = BAD;
; 699  :                 break;

  0022c	e9 24 13 00 00	 jmp	 $LN948@inflate
$LN342@inflate:

; 679  : #else
; 680  :             if (
; 681  : #endif
; 682  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {
; 683  :                 strm->msg = (char *)"incorrect header check";

  00231	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00234	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@LIBMMIGA@incorrect?5header?5check@

; 684  :                 state->mode = BAD;
; 685  :                 break;

  0023b	e9 15 13 00 00	 jmp	 $LN948@inflate
$LN32@inflate:

; 708  : #ifdef GUNZIP
; 709  :         case FLAGS:
; 710  :             NEEDBITS(16);

  00240	83 fe 10	 cmp	 esi, 16			; 00000010H
  00243	73 27		 jae	 SHORT $LN30@inflate
$LL33@inflate:
  00245	85 ff		 test	 edi, edi
  00247	0f 84 8a 03 00
	00		 je	 $LN919@inflate
  0024d	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00250	8b ce		 mov	 ecx, esi
  00252	d3 e0		 shl	 eax, cl
  00254	83 c6 08	 add	 esi, 8
  00257	03 d0		 add	 edx, eax
  00259	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0025c	43		 inc	 ebx
  0025d	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00260	4f		 dec	 edi
  00261	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00264	83 fe 10	 cmp	 esi, 16			; 00000010H
  00267	72 dc		 jb	 SHORT $LL33@inflate
  00269	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN30@inflate:

; 711  :             state->flags = (int)(hold);

  0026c	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 712  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  0026f	80 fa 08	 cmp	 dl, 8
  00272	74 0f		 je	 SHORT $LN349@inflate

; 713  :                 strm->msg = (char *)"unknown compression method";

  00274	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00277	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@

; 714  :                 state->mode = BAD;
; 715  :                 break;

  0027e	e9 d2 12 00 00	 jmp	 $LN948@inflate
$LN349@inflate:

; 716  :             }
; 717  :             if (state->flags & 0xe000) {

  00283	f7 c2 00 e0 00
	00		 test	 edx, 57344		; 0000e000H
  00289	74 0f		 je	 SHORT $LN350@inflate

; 718  :                 strm->msg = (char *)"unknown header flags set";

  0028b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0028e	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@

; 719  :                 state->mode = BAD;
; 720  :                 break;

  00295	e9 bb 12 00 00	 jmp	 $LN948@inflate
$LN350@inflate:

; 721  :             }
; 722  :             if (state->head != Z_NULL)

  0029a	8b 71 24	 mov	 esi, DWORD PTR [ecx+36]
  0029d	8b c2		 mov	 eax, edx
  0029f	c1 e8 08	 shr	 eax, 8
  002a2	85 f6		 test	 esi, esi
  002a4	74 0b		 je	 SHORT $LN654@inflate

; 723  :                 state->head->text = (int)((hold >> 8) & 1);

  002a6	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
  002a9	83 e0 01	 and	 eax, 1
  002ac	89 06		 mov	 DWORD PTR [esi], eax
  002ae	8b 45 cc	 mov	 eax, DWORD PTR $T5[ebp]
$LN654@inflate:

; 724  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  002b1	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  002b8	74 20		 je	 SHORT $LN39@inflate
  002ba	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  002be	74 1a		 je	 SHORT $LN39@inflate

; 725  :                 CRC2(state->check, hold);

  002c0	88 45 e5	 mov	 BYTE PTR _hbuf$[ebp+1], al
  002c3	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  002c6	6a 02		 push	 2
  002c8	50		 push	 eax
  002c9	ff 71 1c	 push	 DWORD PTR [ecx+28]
  002cc	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  002cf	e8 00 00 00 00	 call	 _crc32@12
  002d4	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  002d7	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN39@inflate:

; 726  :             INITBITS();

  002da	33 d2		 xor	 edx, edx

; 727  :             state->mode = TIME;

  002dc	c7 41 04 36 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16182 ; 00003f36H
  002e3	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  002e6	33 f6		 xor	 esi, esi

; 728  :                 /* fallthrough */
; 729  :         case TIME:
; 730  :             NEEDBITS(32);

  002e8	eb 06		 jmp	 SHORT $LL47@inflate
$LN46@inflate:
  002ea	83 fe 20	 cmp	 esi, 32			; 00000020H
  002ed	73 22		 jae	 SHORT $LN44@inflate
  002ef	90		 npad	 1
$LL47@inflate:
  002f0	85 ff		 test	 edi, edi
  002f2	0f 84 df 02 00
	00		 je	 $LN919@inflate
  002f8	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  002fb	8b ce		 mov	 ecx, esi
  002fd	d3 e0		 shl	 eax, cl
  002ff	83 c6 08	 add	 esi, 8
  00302	03 d0		 add	 edx, eax
  00304	4f		 dec	 edi
  00305	43		 inc	 ebx
  00306	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00309	83 fe 20	 cmp	 esi, 32			; 00000020H
  0030c	72 e2		 jb	 SHORT $LL47@inflate
  0030e	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN44@inflate:

; 731  :             if (state->head != Z_NULL)

  00311	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00314	85 c0		 test	 eax, eax
  00316	74 03		 je	 SHORT $LN355@inflate

; 732  :                 state->head->time = hold;

  00318	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN355@inflate:

; 733  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  0031b	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  00322	74 33		 je	 SHORT $LN53@inflate
  00324	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  00328	74 2d		 je	 SHORT $LN53@inflate

; 734  :                 CRC4(state->check, hold);

  0032a	8b c2		 mov	 eax, edx
  0032c	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  0032f	c1 e8 08	 shr	 eax, 8
  00332	88 45 e5	 mov	 BYTE PTR _hbuf$[ebp+1], al
  00335	8b c2		 mov	 eax, edx
  00337	c1 e8 10	 shr	 eax, 16			; 00000010H
  0033a	88 45 e6	 mov	 BYTE PTR _hbuf$[ebp+2], al
  0033d	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00340	6a 04		 push	 4
  00342	50		 push	 eax
  00343	ff 71 1c	 push	 DWORD PTR [ecx+28]
  00346	c1 ea 18	 shr	 edx, 24			; 00000018H
  00349	88 55 e7	 mov	 BYTE PTR _hbuf$[ebp+3], dl
  0034c	e8 00 00 00 00	 call	 _crc32@12
  00351	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00354	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN53@inflate:

; 735  :             INITBITS();

  00357	33 d2		 xor	 edx, edx

; 736  :             state->mode = OS;

  00359	c7 41 04 37 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16183 ; 00003f37H
  00360	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00363	33 f6		 xor	 esi, esi

; 737  :                 /* fallthrough */
; 738  :         case OS:
; 739  :             NEEDBITS(16);

  00365	eb 09		 jmp	 SHORT $LL61@inflate
$LN60@inflate:
  00367	83 fe 10	 cmp	 esi, 16			; 00000010H
  0036a	73 28		 jae	 SHORT $LN58@inflate
  0036c	0f 1f 40 00	 npad	 4
$LL61@inflate:
  00370	85 ff		 test	 edi, edi
  00372	0f 84 5f 02 00
	00		 je	 $LN919@inflate
  00378	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0037b	8b ce		 mov	 ecx, esi
  0037d	d3 e0		 shl	 eax, cl
  0037f	43		 inc	 ebx
  00380	03 d0		 add	 edx, eax
  00382	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00385	83 c6 08	 add	 esi, 8
  00388	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  0038b	4f		 dec	 edi
  0038c	83 fe 10	 cmp	 esi, 16			; 00000010H
  0038f	72 df		 jb	 SHORT $LL61@inflate
  00391	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN58@inflate:

; 740  :             if (state->head != Z_NULL) {

  00394	8b 71 24	 mov	 esi, DWORD PTR [ecx+36]
  00397	8b c2		 mov	 eax, edx
  00399	c1 e8 08	 shr	 eax, 8
  0039c	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
  0039f	85 f6		 test	 esi, esi
  003a1	74 11		 je	 SHORT $LN723@inflate

; 741  :                 state->head->xflags = (int)(hold & 0xff);

  003a3	0f b6 c2	 movzx	 eax, dl
  003a6	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 742  :                 state->head->os = (int)(hold >> 8);

  003a9	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  003ac	8b 75 cc	 mov	 esi, DWORD PTR $T1[ebp]
  003af	89 70 0c	 mov	 DWORD PTR [eax+12], esi
  003b2	8b c6		 mov	 eax, esi
$LN723@inflate:

; 743  :             }
; 744  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  003b4	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  003bb	74 20		 je	 SHORT $LN67@inflate
  003bd	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  003c1	74 1a		 je	 SHORT $LN67@inflate

; 745  :                 CRC2(state->check, hold);

  003c3	88 45 e5	 mov	 BYTE PTR _hbuf$[ebp+1], al
  003c6	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  003c9	6a 02		 push	 2
  003cb	50		 push	 eax
  003cc	ff 71 1c	 push	 DWORD PTR [ecx+28]
  003cf	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  003d2	e8 00 00 00 00	 call	 _crc32@12
  003d7	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  003da	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN67@inflate:

; 746  :             INITBITS();

  003dd	33 d2		 xor	 edx, edx

; 747  :             state->mode = EXLEN;

  003df	c7 41 04 38 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16184 ; 00003f38H
  003e6	33 f6		 xor	 esi, esi
  003e8	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  003eb	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN361@inflate:

; 748  :                 /* fallthrough */
; 749  :         case EXLEN:
; 750  :             if (state->flags & 0x0400) {

  003ee	f7 41 14 00 04
	00 00		 test	 DWORD PTR [ecx+20], 1024 ; 00000400H
  003f5	74 74		 je	 SHORT $LN362@inflate

; 751  :                 NEEDBITS(16);

  003f7	83 fe 10	 cmp	 esi, 16			; 00000010H
  003fa	73 28		 jae	 SHORT $LN72@inflate
  003fc	0f 1f 40 00	 npad	 4
$LL75@inflate:
  00400	85 ff		 test	 edi, edi
  00402	0f 84 cf 01 00
	00		 je	 $LN919@inflate
  00408	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0040b	8b ce		 mov	 ecx, esi
  0040d	d3 e0		 shl	 eax, cl
  0040f	43		 inc	 ebx
  00410	03 d0		 add	 edx, eax
  00412	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00415	83 c6 08	 add	 esi, 8
  00418	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  0041b	4f		 dec	 edi
  0041c	83 fe 10	 cmp	 esi, 16			; 00000010H
  0041f	72 df		 jb	 SHORT $LL75@inflate
  00421	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN72@inflate:

; 752  :                 state->length = (unsigned)(hold);
; 753  :                 if (state->head != Z_NULL)

  00424	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00427	89 51 44	 mov	 DWORD PTR [ecx+68], edx
  0042a	85 c0		 test	 eax, eax
  0042c	74 03		 je	 SHORT $LN365@inflate

; 754  :                     state->head->extra_len = (unsigned)hold;

  0042e	89 50 14	 mov	 DWORD PTR [eax+20], edx
$LN365@inflate:

; 755  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00431	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  00438	74 23		 je	 SHORT $LN81@inflate
  0043a	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  0043e	74 1d		 je	 SHORT $LN81@inflate

; 756  :                     CRC2(state->check, hold);

  00440	6a 02		 push	 2
  00442	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00445	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  00448	50		 push	 eax
  00449	ff 71 1c	 push	 DWORD PTR [ecx+28]
  0044c	c1 ea 08	 shr	 edx, 8
  0044f	88 55 e5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  00452	e8 00 00 00 00	 call	 _crc32@12
  00457	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0045a	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN81@inflate:

; 757  :                 INITBITS();

  0045d	33 f6		 xor	 esi, esi
  0045f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  00466	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 758  :             }

  00469	eb 0e		 jmp	 SHORT $LN367@inflate
$LN362@inflate:

; 759  :             else if (state->head != Z_NULL)

  0046b	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0046e	85 c0		 test	 eax, eax
  00470	74 07		 je	 SHORT $LN367@inflate

; 760  :                 state->head->extra = Z_NULL;

  00472	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN367@inflate:

; 761  :             state->mode = EXTRA;

  00479	c7 41 04 39 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16185 ; 00003f39H
$LN368@inflate:

; 762  :                 /* fallthrough */
; 763  :         case EXTRA:
; 764  :             if (state->flags & 0x0400) {

  00480	f7 41 14 00 04
	00 00		 test	 DWORD PTR [ecx+20], 1024 ; 00000400H
  00487	0f 84 b9 00 00
	00		 je	 $LN724@inflate

; 765  :                 copy = state->length;

  0048d	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]

; 766  :                 if (copy > have) copy = have;
; 767  :                 if (copy) {

  00490	8b d7		 mov	 edx, edi
  00492	3b c7		 cmp	 eax, edi
  00494	0f 46 d0	 cmovbe	 edx, eax
  00497	89 55 d8	 mov	 DWORD PTR tv4679[ebp], edx
  0049a	85 d2		 test	 edx, edx
  0049c	0f 84 9c 00 00
	00		 je	 $LN725@inflate

; 768  :                     if (state->head != Z_NULL &&
; 769  :                         state->head->extra != Z_NULL &&

  004a2	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  004a6	89 45 d0	 mov	 DWORD PTR $T6[ebp], eax
  004a9	74 62		 je	 SHORT $LN372@inflate
  004ab	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  004ae	89 45 d0	 mov	 DWORD PTR $T6[ebp], eax
  004b1	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  004b4	85 c9		 test	 ecx, ecx
  004b6	89 4d c0	 mov	 DWORD PTR tv4971[ebp], ecx
  004b9	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  004bc	74 4f		 je	 SHORT $LN372@inflate
  004be	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  004c1	89 45 d0	 mov	 DWORD PTR $T6[ebp], eax
  004c4	8b 52 14	 mov	 edx, DWORD PTR [edx+20]
  004c7	2b d0		 sub	 edx, eax
  004c9	89 55 f0	 mov	 DWORD PTR _len$2$[ebp], edx
  004cc	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  004cf	8b 45 f0	 mov	 eax, DWORD PTR _len$2$[ebp]
  004d2	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  004d5	3b c2		 cmp	 eax, edx
  004d7	89 55 cc	 mov	 DWORD PTR tv4970[ebp], edx
  004da	8b 55 d8	 mov	 edx, DWORD PTR tv4679[ebp]
  004dd	73 2e		 jae	 SHORT $LN372@inflate

; 770  :                         (len = state->head->extra_len - state->length) <
; 771  :                             state->head->extra_max) {
; 772  :                         zmemcpy(state->head->extra + len, next,

  004df	8d 0c 02	 lea	 ecx, DWORD PTR [edx+eax]
  004e2	8b 55 cc	 mov	 edx, DWORD PTR tv4970[ebp]
  004e5	2b d0		 sub	 edx, eax
  004e7	3b 4d cc	 cmp	 ecx, DWORD PTR tv4970[ebp]
  004ea	8b 45 d8	 mov	 eax, DWORD PTR tv4679[ebp]
  004ed	0f 47 c2	 cmova	 eax, edx
  004f0	50		 push	 eax
  004f1	8b 45 f0	 mov	 eax, DWORD PTR _len$2$[ebp]
  004f4	03 45 c0	 add	 eax, DWORD PTR tv4971[ebp]
  004f7	53		 push	 ebx
  004f8	50		 push	 eax
  004f9	e8 00 00 00 00	 call	 _memcpy
  004fe	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00501	83 c4 0c	 add	 esp, 12			; 0000000cH
  00504	8b 55 d8	 mov	 edx, DWORD PTR tv4679[ebp]
  00507	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  0050a	89 45 d0	 mov	 DWORD PTR $T6[ebp], eax
$LN372@inflate:

; 773  :                                 len + copy > state->head->extra_max ?
; 774  :                                 state->head->extra_max - len : copy);
; 775  :                     }
; 776  :                     if ((state->flags & 0x0200) && (state->wrap & 4))

  0050d	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  00514	74 16		 je	 SHORT $LN373@inflate
  00516	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  0051a	74 10		 je	 SHORT $LN373@inflate

; 777  :                         state->check = crc32(state->check, next, copy);

  0051c	52		 push	 edx
  0051d	53		 push	 ebx
  0051e	ff 71 1c	 push	 DWORD PTR [ecx+28]
  00521	e8 00 00 00 00	 call	 _crc32@12
  00526	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00529	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN373@inflate:

; 778  :                     have -= copy;

  0052c	8b 55 d8	 mov	 edx, DWORD PTR tv4679[ebp]
  0052f	2b fa		 sub	 edi, edx

; 779  :                     next += copy;
; 780  :                     state->length -= copy;

  00531	8b 45 d0	 mov	 eax, DWORD PTR $T6[ebp]
  00534	03 da		 add	 ebx, edx
  00536	2b c2		 sub	 eax, edx
  00538	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  0053b	89 41 44	 mov	 DWORD PTR [ecx+68], eax
$LN725@inflate:

; 781  :                 }
; 782  :                 if (state->length) goto inf_leave;

  0053e	85 c0		 test	 eax, eax
  00540	0f 85 91 00 00
	00		 jne	 $LN919@inflate
$LN724@inflate:

; 783  :             }
; 784  :             state->length = 0;

  00546	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 785  :             state->mode = NAME;

  0054d	c7 41 04 3a 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16186 ; 00003f3aH
$LN375@inflate:

; 786  :                 /* fallthrough */
; 787  :         case NAME:
; 788  :             if (state->flags & 0x0800) {

  00554	f7 41 14 00 08
	00 00		 test	 DWORD PTR [ecx+20], 2048 ; 00000800H
  0055b	0f 84 f7 00 00
	00		 je	 $LN376@inflate

; 789  :                 if (have == 0) goto inf_leave;

  00561	85 ff		 test	 edi, edi
  00563	74 72		 je	 SHORT $LN919@inflate

; 790  :                 copy = 0;

  00565	33 d2		 xor	 edx, edx
$LL88@inflate:

; 791  :                 do {
; 792  :                     len = (unsigned)(next[copy++]);

  00567	8a 04 1a	 mov	 al, BYTE PTR [edx+ebx]
  0056a	42		 inc	 edx
  0056b	88 45 ff	 mov	 BYTE PTR tv5123[ebp], al

; 793  :                     if (state->head != Z_NULL &&
; 794  :                             state->head->name != Z_NULL &&

  0056e	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00571	89 55 cc	 mov	 DWORD PTR _copy$1$[ebp], edx
  00574	85 c0		 test	 eax, eax
  00576	74 1d		 je	 SHORT $LN86@inflate
  00578	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  0057c	74 17		 je	 SHORT $LN86@inflate
  0057e	8b 71 44	 mov	 esi, DWORD PTR [ecx+68]
  00581	3b 70 20	 cmp	 esi, DWORD PTR [eax+32]
  00584	73 0f		 jae	 SHORT $LN86@inflate

; 795  :                             state->length < state->head->name_max)
; 796  :                         state->head->name[state->length++] = (Bytef)len;

  00586	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00589	8a 55 ff	 mov	 dl, BYTE PTR tv5123[ebp]
  0058c	88 14 30	 mov	 BYTE PTR [eax+esi], dl
  0058f	ff 41 44	 inc	 DWORD PTR [ecx+68]
  00592	8b 55 cc	 mov	 edx, DWORD PTR _copy$1$[ebp]
$LN86@inflate:

; 797  :                 } while (len && copy < have);

  00595	8a 45 ff	 mov	 al, BYTE PTR tv5123[ebp]
  00598	84 c0		 test	 al, al
  0059a	74 04		 je	 SHORT $LN380@inflate
  0059c	3b d7		 cmp	 edx, edi
  0059e	72 c7		 jb	 SHORT $LL88@inflate
$LN380@inflate:

; 798  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  005a0	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  005a7	8b 75 ec	 mov	 esi, DWORD PTR _bits$1$[ebp]
  005aa	74 1c		 je	 SHORT $LN381@inflate
  005ac	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  005b0	74 16		 je	 SHORT $LN381@inflate

; 799  :                     state->check = crc32(state->check, next, copy);

  005b2	52		 push	 edx
  005b3	53		 push	 ebx
  005b4	ff 71 1c	 push	 DWORD PTR [ecx+28]
  005b7	e8 00 00 00 00	 call	 _crc32@12
  005bc	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  005bf	8b 55 cc	 mov	 edx, DWORD PTR _copy$1$[ebp]
  005c2	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  005c5	8a 45 ff	 mov	 al, BYTE PTR tv5123[ebp]
$LN381@inflate:

; 800  :                 have -= copy;
; 801  :                 next += copy;

  005c8	03 da		 add	 ebx, edx
  005ca	2b fa		 sub	 edi, edx
  005cc	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx

; 802  :                 if (len) goto inf_leave;

  005cf	84 c0		 test	 al, al
  005d1	0f 84 8f 00 00
	00		 je	 $LN383@inflate
$LN919@inflate:

; 1265 :             goto inf_leave;
; 1266 :         case MEM:
; 1267 :             return Z_MEM_ERROR;
; 1268 :         case SYNC:
; 1269 :                 /* fallthrough */
; 1270 :         default:
; 1271 :             return Z_STREAM_ERROR;
; 1272 :         }
; 1273 : 
; 1274 :     /*
; 1275 :        Return from inflate(), updating the total counts and the check value.
; 1276 :        If there was no progress during the inflate() call, return a buffer
; 1277 :        error.  Call updatewindow() to create and/or update the window state.
; 1278 :        Note: a memory error from inflate() is non-recoverable.
; 1279 :      */
; 1280 :   inf_leave:
; 1281 :     RESTORE();

  005d7	8b 55 0c	 mov	 edx, DWORD PTR _flush$[ebp]
$inf_leave$954:
  005da	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  005dd	8b 45 e0	 mov	 eax, DWORD PTR _put$1$[ebp]
  005e0	89 19		 mov	 DWORD PTR [ecx], ebx
  005e2	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
  005e5	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  005e8	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  005eb	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  005ee	8b 45 f4	 mov	 eax, DWORD PTR _hold$1$[ebp]
  005f1	89 79 04	 mov	 DWORD PTR [ecx+4], edi

; 1282 :     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&

  005f4	83 7b 2c 00	 cmp	 DWORD PTR [ebx+44], 0
  005f8	89 73 40	 mov	 DWORD PTR [ebx+64], esi
  005fb	8b 75 dc	 mov	 esi, DWORD PTR _out$1$[ebp]
  005fe	89 43 3c	 mov	 DWORD PTR [ebx+60], eax
  00601	75 27		 jne	 SHORT $LN503@inflate
  00603	3b 71 10	 cmp	 esi, DWORD PTR [ecx+16]
  00606	0f 84 cc 0f 00
	00		 je	 $LN504@inflate
  0060c	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0060f	3d 51 3f 00 00	 cmp	 eax, 16209		; 00003f51H
  00614	0f 8d be 0f 00
	00		 jge	 $LN504@inflate
  0061a	3d 4e 3f 00 00	 cmp	 eax, 16206		; 00003f4eH
  0061f	7c 09		 jl	 SHORT $LN503@inflate
  00621	83 fa 04	 cmp	 edx, 4
  00624	0f 84 ae 0f 00
	00		 je	 $LN504@inflate
$LN503@inflate:

; 1283 :             (state->mode < CHECK || flush != Z_FINISH)))
; 1284 :         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {

  0062a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0062d	8b c6		 mov	 eax, esi
  0062f	2b 41 10	 sub	 eax, DWORD PTR [ecx+16]
  00632	50		 push	 eax
  00633	e8 00 00 00 00	 call	 _updatewindow
  00638	83 c4 04	 add	 esp, 4
  0063b	85 c0		 test	 eax, eax
  0063d	0f 84 92 0f 00
	00		 je	 $LN883@inflate

; 1285 :             state->mode = MEM;

  00643	c7 43 04 52 3f
	00 00		 mov	 DWORD PTR [ebx+4], 16210 ; 00003f52H
$LN498@inflate:
  0064a	5f		 pop	 edi

; 1300 :         ret = Z_BUF_ERROR;
; 1301 :     return ret;
; 1302 : }

  0064b	5e		 pop	 esi
  0064c	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00651	5b		 pop	 ebx
  00652	8b e5		 mov	 esp, ebp
  00654	5d		 pop	 ebp
  00655	c2 08 00	 ret	 8
$LN376@inflate:

; 803  :             }
; 804  :             else if (state->head != Z_NULL)

  00658	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0065b	85 c0		 test	 eax, eax
  0065d	74 07		 je	 SHORT $LN383@inflate

; 805  :                 state->head->name = Z_NULL;

  0065f	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
$LN383@inflate:

; 806  :             state->length = 0;

  00666	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 807  :             state->mode = COMMENT;

  0066d	c7 41 04 3b 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16187 ; 00003f3bH
$LN384@inflate:

; 808  :                 /* fallthrough */
; 809  :         case COMMENT:
; 810  :             if (state->flags & 0x1000) {

  00674	f7 41 14 00 10
	00 00		 test	 DWORD PTR [ecx+20], 4096 ; 00001000H
  0067b	74 7c		 je	 SHORT $LN385@inflate

; 811  :                 if (have == 0) goto inf_leave;

  0067d	85 ff		 test	 edi, edi
  0067f	0f 84 52 ff ff
	ff		 je	 $LN919@inflate

; 812  :                 copy = 0;

  00685	33 d2		 xor	 edx, edx
$LL91@inflate:

; 813  :                 do {
; 814  :                     len = (unsigned)(next[copy++]);

  00687	8a 04 1a	 mov	 al, BYTE PTR [edx+ebx]
  0068a	42		 inc	 edx
  0068b	88 45 ff	 mov	 BYTE PTR tv5122[ebp], al

; 815  :                     if (state->head != Z_NULL &&
; 816  :                             state->head->comment != Z_NULL &&

  0068e	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00691	89 55 cc	 mov	 DWORD PTR _copy$2$[ebp], edx
  00694	85 c0		 test	 eax, eax
  00696	74 1d		 je	 SHORT $LN89@inflate
  00698	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  0069c	74 17		 je	 SHORT $LN89@inflate
  0069e	8b 71 44	 mov	 esi, DWORD PTR [ecx+68]
  006a1	3b 70 28	 cmp	 esi, DWORD PTR [eax+40]
  006a4	73 0f		 jae	 SHORT $LN89@inflate

; 817  :                             state->length < state->head->comm_max)
; 818  :                         state->head->comment[state->length++] = (Bytef)len;

  006a6	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  006a9	8a 55 ff	 mov	 dl, BYTE PTR tv5122[ebp]
  006ac	88 14 30	 mov	 BYTE PTR [eax+esi], dl
  006af	ff 41 44	 inc	 DWORD PTR [ecx+68]
  006b2	8b 55 cc	 mov	 edx, DWORD PTR _copy$2$[ebp]
$LN89@inflate:

; 819  :                 } while (len && copy < have);

  006b5	8a 45 ff	 mov	 al, BYTE PTR tv5122[ebp]
  006b8	84 c0		 test	 al, al
  006ba	74 04		 je	 SHORT $LN389@inflate
  006bc	3b d7		 cmp	 edx, edi
  006be	72 c7		 jb	 SHORT $LL91@inflate
$LN389@inflate:

; 820  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  006c0	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  006c7	8b 75 ec	 mov	 esi, DWORD PTR _bits$1$[ebp]
  006ca	74 1c		 je	 SHORT $LN390@inflate
  006cc	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  006d0	74 16		 je	 SHORT $LN390@inflate

; 821  :                     state->check = crc32(state->check, next, copy);

  006d2	52		 push	 edx
  006d3	53		 push	 ebx
  006d4	ff 71 1c	 push	 DWORD PTR [ecx+28]
  006d7	e8 00 00 00 00	 call	 _crc32@12
  006dc	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  006df	8b 55 cc	 mov	 edx, DWORD PTR _copy$2$[ebp]
  006e2	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  006e5	8a 45 ff	 mov	 al, BYTE PTR tv5122[ebp]
$LN390@inflate:

; 822  :                 have -= copy;
; 823  :                 next += copy;

  006e8	03 da		 add	 ebx, edx
  006ea	2b fa		 sub	 edi, edx
  006ec	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx

; 824  :                 if (len) goto inf_leave;

  006ef	84 c0		 test	 al, al
  006f1	0f 85 e0 fe ff
	ff		 jne	 $LN919@inflate

; 825  :             }

  006f7	eb 0e		 jmp	 SHORT $LN392@inflate
$LN385@inflate:

; 826  :             else if (state->head != Z_NULL)

  006f9	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  006fc	85 c0		 test	 eax, eax
  006fe	74 07		 je	 SHORT $LN392@inflate

; 827  :                 state->head->comment = Z_NULL;

  00700	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
$LN392@inflate:
  00707	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 828  :             state->mode = HCRC;

  0070a	c7 41 04 3c 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16188 ; 00003f3cH
$LN393@inflate:

; 829  :                 /* fallthrough */
; 830  :         case HCRC:
; 831  :             if (state->flags & 0x0200) {

  00711	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00714	89 45 c0	 mov	 DWORD PTR tv4693[ebp], eax
  00717	a9 00 02 00 00	 test	 eax, 512		; 00000200H
  0071c	74 55		 je	 SHORT $LN101@inflate

; 832  :                 NEEDBITS(16);

  0071e	83 fe 10	 cmp	 esi, 16			; 00000010H
  00721	73 27		 jae	 SHORT $LN92@inflate
$LL95@inflate:
  00723	85 ff		 test	 edi, edi
  00725	0f 84 ac fe ff
	ff		 je	 $LN919@inflate
  0072b	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0072e	8b ce		 mov	 ecx, esi
  00730	d3 e0		 shl	 eax, cl
  00732	83 c6 08	 add	 esi, 8
  00735	03 d0		 add	 edx, eax
  00737	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0073a	43		 inc	 ebx
  0073b	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  0073e	4f		 dec	 edi
  0073f	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00742	83 fe 10	 cmp	 esi, 16			; 00000010H
  00745	72 dc		 jb	 SHORT $LL95@inflate
  00747	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN92@inflate:

; 833  :                 if ((state->wrap & 4) && hold != (state->check & 0xffff)) {

  0074a	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  0074e	74 17		 je	 SHORT $LN102@inflate
  00750	0f b7 41 1c	 movzx	 eax, WORD PTR [ecx+28]
  00754	3b d0		 cmp	 edx, eax
  00756	74 0f		 je	 SHORT $LN102@inflate

; 834  :                     strm->msg = (char *)"header crc mismatch";

  00758	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0075b	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@GONKLEPM@header?5crc?5mismatch@

; 835  :                     state->mode = BAD;
; 836  :                     break;

  00762	e9 ee 0d 00 00	 jmp	 $LN948@inflate
$LN102@inflate:

; 837  :                 }
; 838  :                 INITBITS();

  00767	33 f6		 xor	 esi, esi
  00769	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  00770	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN101@inflate:

; 839  :             }
; 840  :             if (state->head != Z_NULL) {

  00773	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00776	85 c0		 test	 eax, eax
  00778	74 16		 je	 SHORT $LN397@inflate

; 841  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  0077a	8b 55 c0	 mov	 edx, DWORD PTR tv4693[ebp]
  0077d	c1 fa 09	 sar	 edx, 9
  00780	83 e2 01	 and	 edx, 1
  00783	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 842  :                 state->head->done = 1;

  00786	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00789	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [eax+48], 1
$LN397@inflate:

; 843  :             }
; 844  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  00790	6a 00		 push	 0
  00792	6a 00		 push	 0
  00794	6a 00		 push	 0
  00796	e8 00 00 00 00	 call	 _crc32@12
  0079b	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0079e	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  007a1	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  007a4	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 845  :             state->mode = TYPE;
; 846  :             break;

  007a7	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  007aa	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
  007b1	e9 a6 0d 00 00	 jmp	 $LN8@inflate
$LN105@inflate:

; 847  : #endif
; 848  :         case DICTID:
; 849  :             NEEDBITS(32);

  007b6	83 fe 20	 cmp	 esi, 32			; 00000020H
  007b9	73 26		 jae	 SHORT $LN103@inflate
  007bb	0f 1f 44 00 00	 npad	 5
$LL106@inflate:
  007c0	85 ff		 test	 edi, edi
  007c2	0f 84 0f fe ff
	ff		 je	 $LN919@inflate
  007c8	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  007cb	8b ce		 mov	 ecx, esi
  007cd	d3 e0		 shl	 eax, cl
  007cf	43		 inc	 ebx
  007d0	03 d0		 add	 edx, eax
  007d2	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  007d5	83 c6 08	 add	 esi, 8
  007d8	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  007db	4f		 dec	 edi
  007dc	83 fe 20	 cmp	 esi, 32			; 00000020H
  007df	72 df		 jb	 SHORT $LL106@inflate
$LN103@inflate:

; 850  :             strm->adler = state->check = ZSWAP32(hold);

  007e1	8b ca		 mov	 ecx, edx
  007e3	8b c2		 mov	 eax, edx
  007e5	c1 e0 10	 shl	 eax, 16			; 00000010H
  007e8	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  007ee	03 c8		 add	 ecx, eax
  007f0	8b c2		 mov	 eax, edx
  007f2	c1 e8 08	 shr	 eax, 8
  007f5	c1 e1 08	 shl	 ecx, 8
  007f8	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  007fd	c1 ea 18	 shr	 edx, 24			; 00000018H
  00800	03 c1		 add	 eax, ecx
  00802	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00805	03 c2		 add	 eax, edx
  00807	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0080a	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  0080d	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 851  :             INITBITS();

  00810	33 d2		 xor	 edx, edx
  00812	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00815	33 f6		 xor	 esi, esi

; 852  :             state->mode = DICT;

  00817	c7 41 04 3e 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16190 ; 00003f3eH
$LN400@inflate:

; 853  :                 /* fallthrough */
; 854  :         case DICT:
; 855  :             if (state->havedict == 0) {

  0081e	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00822	0f 84 53 0d 00
	00		 je	 $LN587@inflate

; 858  :             }
; 859  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  00828	6a 00		 push	 0
  0082a	6a 00		 push	 0
  0082c	6a 00		 push	 0
  0082e	e8 00 00 00 00	 call	 _adler32@12
  00833	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00836	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00839	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  0083c	89 42 30	 mov	 DWORD PTR [edx+48], eax
  0083f	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 860  :             state->mode = TYPE;

  00842	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
$LN402@inflate:

; 861  :                 /* fallthrough */
; 862  :         case TYPE:
; 863  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  00849	8b 45 0c	 mov	 eax, DWORD PTR _flush$[ebp]
  0084c	83 f8 05	 cmp	 eax, 5
  0084f	0f 84 79 0d 00
	00		 je	 $LN906@inflate
  00855	83 f8 06	 cmp	 eax, 6
  00858	0f 84 70 0d 00
	00		 je	 $LN906@inflate
$LN403@inflate:

; 864  :                 /* fallthrough */
; 865  :         case TYPEDO:
; 866  :             if (state->last) {

  0085e	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00862	74 1e		 je	 SHORT $LN122@inflate

; 867  :                 BYTEBITS();

  00864	8b ce		 mov	 ecx, esi
  00866	83 e1 07	 and	 ecx, 7
  00869	d3 ea		 shr	 edx, cl
  0086b	2b f1		 sub	 esi, ecx

; 868  :                 state->mode = CHECK;

  0086d	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00870	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00873	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00876	c7 41 04 4e 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16206 ; 00003f4eH

; 869  :                 break;

  0087d	e9 da 0c 00 00	 jmp	 $LN8@inflate
$LN122@inflate:

; 870  :             }
; 871  :             NEEDBITS(3);

  00882	83 fe 03	 cmp	 esi, 3
  00885	73 24		 jae	 SHORT $LN120@inflate
$LL123@inflate:
  00887	85 ff		 test	 edi, edi
  00889	0f 84 48 fd ff
	ff		 je	 $LN919@inflate
  0088f	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00892	8b ce		 mov	 ecx, esi
  00894	d3 e0		 shl	 eax, cl
  00896	43		 inc	 ebx
  00897	03 d0		 add	 edx, eax
  00899	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  0089c	83 c6 08	 add	 esi, 8
  0089f	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  008a2	4f		 dec	 edi
  008a3	83 fe 03	 cmp	 esi, 3
  008a6	72 df		 jb	 SHORT $LL123@inflate
  008a8	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN120@inflate:

; 872  :             state->last = BITS(1);

  008ab	8b c2		 mov	 eax, edx

; 873  :             DROPBITS(1);

  008ad	d1 ea		 shr	 edx, 1
  008af	83 e0 01	 and	 eax, 1
  008b2	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 874  :             switch (BITS(2)) {

  008b5	8b c2		 mov	 eax, edx
  008b7	83 e0 03	 and	 eax, 3
  008ba	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN792@inflate[eax*4]
$LN408@inflate:

; 898  :             }
; 899  :             DROPBITS(2);

  008c1	c1 ea 02	 shr	 edx, 2
  008c4	83 ee 03	 sub	 esi, 3
  008c7	c7 41 04 41 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16193 ; 00003f41H
  008ce	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  008d1	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 900  :             break;

  008d4	e9 83 0c 00 00	 jmp	 $LN8@inflate
$LN409@inflate:

; 875  :             case 0:                             /* stored block */
; 876  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 877  :                         state->last ? " (last)" : ""));
; 878  :                 state->mode = STORED;
; 879  :                 break;
; 880  :             case 1:                             /* fixed block */
; 881  :                 fixedtables(state);

  008d9	e8 00 00 00 00	 call	 _fixedtables

; 882  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 883  :                         state->last ? " (last)" : ""));
; 884  :                 state->mode = LEN_;             /* decode codes */
; 885  :                 if (flush == Z_TREES) {

  008de	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  008e2	c7 41 04 47 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16199 ; 00003f47H
  008e9	75 37		 jne	 SHORT $LN138@inflate

; 886  :                     DROPBITS(2);

  008eb	c1 ea 02	 shr	 edx, 2
  008ee	83 ee 03	 sub	 esi, 3
  008f1	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx

; 887  :                     goto inf_leave;

  008f4	e9 de fc ff ff	 jmp	 $LN919@inflate
$LN411@inflate:

; 898  :             }
; 899  :             DROPBITS(2);

  008f9	c1 ea 02	 shr	 edx, 2
  008fc	83 ee 03	 sub	 esi, 3
  008ff	c7 41 04 44 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16196 ; 00003f44H
  00906	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00909	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 900  :             break;

  0090c	e9 4b 0c 00 00	 jmp	 $LN8@inflate
$LN412@inflate:

; 888  :                 }
; 889  :                 break;
; 890  :             case 2:                             /* dynamic block */
; 891  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 892  :                         state->last ? " (last)" : ""));
; 893  :                 state->mode = TABLE;
; 894  :                 break;
; 895  :             case 3:
; 896  :                 strm->msg = (char *)"invalid block type";

  00911	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00914	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type@

; 897  :                 state->mode = BAD;

  0091b	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
$LN138@inflate:

; 898  :             }
; 899  :             DROPBITS(2);

  00922	c1 ea 02	 shr	 edx, 2
  00925	83 ee 03	 sub	 esi, 3
  00928	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  0092b	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 900  :             break;

  0092e	e9 29 0c 00 00	 jmp	 $LN8@inflate
$LN141@inflate:

; 901  :         case STORED:
; 902  :             BYTEBITS();                         /* go to byte boundary */

  00933	8b ce		 mov	 ecx, esi
  00935	83 e1 07	 and	 ecx, 7
  00938	2b f1		 sub	 esi, ecx
  0093a	d3 ea		 shr	 edx, cl
  0093c	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  0093f	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 903  :             NEEDBITS(32);

  00942	83 fe 20	 cmp	 esi, 32			; 00000020H
  00945	73 24		 jae	 SHORT $LN142@inflate
$LL145@inflate:
  00947	85 ff		 test	 edi, edi
  00949	0f 84 88 fc ff
	ff		 je	 $LN919@inflate
  0094f	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00952	8b ce		 mov	 ecx, esi
  00954	d3 e0		 shl	 eax, cl
  00956	83 c6 08	 add	 esi, 8
  00959	03 d0		 add	 edx, eax
  0095b	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0095e	43		 inc	 ebx
  0095f	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00962	4f		 dec	 edi
  00963	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00966	83 fe 20	 cmp	 esi, 32			; 00000020H
  00969	72 dc		 jb	 SHORT $LL145@inflate
$LN142@inflate:

; 904  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  0096b	8b c2		 mov	 eax, edx
  0096d	0f b7 ca	 movzx	 ecx, dx
  00970	f7 d0		 not	 eax
  00972	89 4d c0	 mov	 DWORD PTR tv4965[ebp], ecx
  00975	c1 e8 10	 shr	 eax, 16			; 00000010H
  00978	3b c8		 cmp	 ecx, eax
  0097a	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0097d	74 0f		 je	 SHORT $LN415@inflate

; 905  :                 strm->msg = (char *)"invalid stored block lengths";

  0097f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00982	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@

; 906  :                 state->mode = BAD;
; 907  :                 break;

  00989	e9 c7 0b 00 00	 jmp	 $LN948@inflate
$LN415@inflate:

; 908  :             }
; 909  :             state->length = (unsigned)hold & 0xffff;

  0098e	8b 45 c0	 mov	 eax, DWORD PTR tv4965[ebp]

; 910  :             Tracev((stderr, "inflate:       stored length %u\n",
; 911  :                     state->length));
; 912  :             INITBITS();

  00991	33 d2		 xor	 edx, edx
  00993	33 f6		 xor	 esi, esi
  00995	89 41 44	 mov	 DWORD PTR [ecx+68], eax

; 913  :             state->mode = COPY_;
; 914  :             if (flush == Z_TREES) goto inf_leave;

  00998	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  0099c	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  0099f	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  009a2	c7 41 04 42 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16194 ; 00003f42H
  009a9	0f 84 28 fc ff
	ff		 je	 $LN919@inflate
$LN416@inflate:

; 915  :                 /* fallthrough */
; 916  :         case COPY_:
; 917  :             state->mode = COPY;

  009af	c7 41 04 43 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16195 ; 00003f43H
$LN418@inflate:

; 918  :                 /* fallthrough */
; 919  :         case COPY:
; 920  :             copy = state->length;

  009b6	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  009b9	89 45 c0	 mov	 DWORD PTR _copy$3$[ebp], eax

; 921  :             if (copy) {

  009bc	85 c0		 test	 eax, eax
  009be	0f 84 fa 06 00
	00		 je	 $LN419@inflate

; 922  :                 if (copy > have) copy = have;
; 923  :                 if (copy > left) copy = left;

  009c4	39 7d c0	 cmp	 DWORD PTR _copy$3$[ebp], edi
  009c7	8b c7		 mov	 eax, edi

; 924  :                 if (copy == 0) goto inf_leave;

  009c9	8b 4d e8	 mov	 ecx, DWORD PTR _left$1$[ebp]
  009cc	0f 46 45 c0	 cmovbe	 eax, DWORD PTR _copy$3$[ebp]
  009d0	3b c1		 cmp	 eax, ecx
  009d2	0f 46 c8	 cmovbe	 ecx, eax
  009d5	89 4d c0	 mov	 DWORD PTR tv5105[ebp], ecx
  009d8	85 c9		 test	 ecx, ecx
  009da	0f 84 f7 fb ff
	ff		 je	 $LN919@inflate

; 925  :                 zmemcpy(put, next, copy);

  009e0	51		 push	 ecx
  009e1	53		 push	 ebx
  009e2	ff 75 e0	 push	 DWORD PTR _put$1$[ebp]
  009e5	e8 00 00 00 00	 call	 _memcpy

; 926  :                 have -= copy;

  009ea	8b 45 c0	 mov	 eax, DWORD PTR tv5105[ebp]
  009ed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 927  :                 next += copy;
; 928  :                 left -= copy;
; 929  :                 put += copy;
; 930  :                 state->length -= copy;

  009f0	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  009f3	03 d8		 add	 ebx, eax
  009f5	29 45 e8	 sub	 DWORD PTR _left$1$[ebp], eax
  009f8	2b f8		 sub	 edi, eax
  009fa	01 45 e0	 add	 DWORD PTR _put$1$[ebp], eax

; 931  :                 break;

  009fd	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00a00	29 41 44	 sub	 DWORD PTR [ecx+68], eax
  00a03	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00a06	e9 51 0b 00 00	 jmp	 $LN8@inflate
$LN155@inflate:

; 932  :             }
; 933  :             Tracev((stderr, "inflate:       stored end\n"));
; 934  :             state->mode = TYPE;
; 935  :             break;
; 936  :         case TABLE:
; 937  :             NEEDBITS(14);

  00a0b	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  00a0e	73 21		 jae	 SHORT $LN153@inflate
$LL156@inflate:
  00a10	85 ff		 test	 edi, edi
  00a12	0f 84 bf fb ff
	ff		 je	 $LN919@inflate
  00a18	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00a1b	8b ce		 mov	 ecx, esi
  00a1d	d3 e0		 shl	 eax, cl
  00a1f	43		 inc	 ebx
  00a20	03 d0		 add	 edx, eax
  00a22	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00a25	83 c6 08	 add	 esi, 8
  00a28	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00a2b	4f		 dec	 edi
  00a2c	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  00a2f	72 df		 jb	 SHORT $LL156@inflate
$LN153@inflate:

; 938  :             state->nlen = BITS(5) + 257;

  00a31	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00a34	8b ca		 mov	 ecx, edx
  00a36	83 e1 1f	 and	 ecx, 31			; 0000001fH

; 939  :             DROPBITS(5);

  00a39	c1 ea 05	 shr	 edx, 5
  00a3c	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H

; 940  :             state->ndist = BITS(5) + 1;
; 941  :             DROPBITS(5);
; 942  :             state->ncode = BITS(4) + 4;
; 943  :             DROPBITS(4);

  00a42	83 ee 0e	 sub	 esi, 14			; 0000000eH
  00a45	89 4d c0	 mov	 DWORD PTR tv4962[ebp], ecx
  00a48	89 48 64	 mov	 DWORD PTR [eax+100], ecx
  00a4b	8b ca		 mov	 ecx, edx
  00a4d	83 e1 1f	 and	 ecx, 31			; 0000001fH
  00a50	c1 ea 05	 shr	 edx, 5
  00a53	41		 inc	 ecx
  00a54	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00a57	89 48 68	 mov	 DWORD PTR [eax+104], ecx
  00a5a	8b c2		 mov	 eax, edx
  00a5c	89 4d cc	 mov	 DWORD PTR tv5183[ebp], ecx
  00a5f	83 e0 0f	 and	 eax, 15			; 0000000fH
  00a62	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00a65	83 c0 04	 add	 eax, 4
  00a68	c1 ea 04	 shr	 edx, 4

; 944  : #ifndef PKZIP_BUG_WORKAROUND
; 945  :             if (state->nlen > 286 || state->ndist > 30) {

  00a6b	81 7d c0 1e 01
	00 00		 cmp	 DWORD PTR tv4962[ebp], 286 ; 0000011eH
  00a72	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00a75	89 41 60	 mov	 DWORD PTR [ecx+96], eax
  00a78	0f 87 fc 00 00
	00		 ja	 $LN426@inflate
  00a7e	83 7d cc 1e	 cmp	 DWORD PTR tv5183[ebp], 30 ; 0000001eH
  00a82	0f 87 f2 00 00
	00		 ja	 $LN426@inflate

; 949  :             }
; 950  : #endif
; 951  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 952  :             state->have = 0;

  00a88	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], 0

; 953  :             state->mode = LENLENS;

  00a8f	c7 41 04 45 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16197 ; 00003f45H
$LN533@inflate:

; 954  :                 /* fallthrough */
; 955  :         case LENLENS:
; 956  :             while (state->have < state->ncode) {

  00a96	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00a99	3b 41 60	 cmp	 eax, DWORD PTR [ecx+96]
  00a9c	73 5f		 jae	 SHORT $LN535@inflate
  00a9e	66 90		 npad	 2
$LL170@inflate:

; 957  :                 NEEDBITS(3);

  00aa0	83 fe 03	 cmp	 esi, 3
  00aa3	73 21		 jae	 SHORT $LN172@inflate
$LL175@inflate:
  00aa5	85 ff		 test	 edi, edi
  00aa7	0f 84 2a fb ff
	ff		 je	 $LN919@inflate
  00aad	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00ab0	8b ce		 mov	 ecx, esi
  00ab2	d3 e0		 shl	 eax, cl
  00ab4	43		 inc	 ebx
  00ab5	03 d0		 add	 edx, eax
  00ab7	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00aba	83 c6 08	 add	 esi, 8
  00abd	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00ac0	4f		 dec	 edi
  00ac1	83 fe 03	 cmp	 esi, 3
  00ac4	72 df		 jb	 SHORT $LL175@inflate
$LN172@inflate:

; 958  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00ac6	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00ac9	8b ca		 mov	 ecx, edx
  00acb	8b 55 f8	 mov	 edx, DWORD PTR _state$1$[ebp]
  00ace	83 e1 07	 and	 ecx, 7

; 959  :                 DROPBITS(3);

  00ad1	83 ee 03	 sub	 esi, 3
  00ad4	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00ad7	8b 40 6c	 mov	 eax, DWORD PTR [eax+108]
  00ada	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00ae2	66 89 4c 42 74	 mov	 WORD PTR [edx+eax*2+116], cx
  00ae7	8b ca		 mov	 ecx, edx
  00ae9	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00aec	c1 ea 03	 shr	 edx, 3
  00aef	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00af2	ff 41 6c	 inc	 DWORD PTR [ecx+108]
  00af5	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00af8	3b 41 60	 cmp	 eax, DWORD PTR [ecx+96]
  00afb	72 a3		 jb	 SHORT $LL170@inflate
$LN535@inflate:

; 960  :             }
; 961  :             while (state->have < 19)

  00afd	83 f8 13	 cmp	 eax, 19			; 00000013H
  00b00	73 29		 jae	 SHORT $LN184@inflate
  00b02	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL183@inflate:

; 962  :                 state->lens[order[state->have++]] = 0;

  00b10	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00b18	33 d2		 xor	 edx, edx
  00b1a	66 89 54 41 74	 mov	 WORD PTR [ecx+eax*2+116], dx
  00b1f	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00b22	40		 inc	 eax
  00b23	89 41 6c	 mov	 DWORD PTR [ecx+108], eax
  00b26	83 f8 13	 cmp	 eax, 19			; 00000013H
  00b29	72 e5		 jb	 SHORT $LL183@inflate
$LN184@inflate:

; 963  :             state->next = state->codes;
; 964  :             state->lencode = (const code FAR *)(state->next);

  00b2b	8b 55 f8	 mov	 edx, DWORD PTR _state$1$[ebp]
  00b2e	8d 81 34 05 00
	00		 lea	 eax, DWORD PTR [ecx+1332]
  00b34	83 c1 70	 add	 ecx, 112		; 00000070H
  00b37	89 42 50	 mov	 DWORD PTR [edx+80], eax
  00b3a	89 01		 mov	 DWORD PTR [ecx], eax

; 965  :             state->lenbits = 7;
; 966  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  00b3c	8d 82 f4 02 00
	00		 lea	 eax, DWORD PTR [edx+756]
  00b42	50		 push	 eax
  00b43	8d 42 58	 lea	 eax, DWORD PTR [edx+88]
  00b46	c7 42 58 07 00
	00 00		 mov	 DWORD PTR [edx+88], 7
  00b4d	50		 push	 eax
  00b4e	51		 push	 ecx
  00b4f	6a 13		 push	 19			; 00000013H
  00b51	83 c2 74	 add	 edx, 116		; 00000074H
  00b54	33 c9		 xor	 ecx, ecx
  00b56	e8 00 00 00 00	 call	 _inflate_table

; 967  :                                 &(state->lenbits), state->work);
; 968  :             if (ret) {

  00b5b	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00b5e	83 c4 10	 add	 esp, 16			; 00000010H
  00b61	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00b64	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00b67	85 c0		 test	 eax, eax
  00b69	74 1e		 je	 SHORT $LN429@inflate

; 969  :                 strm->msg = (char *)"invalid code lengths set";

  00b6b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00b6e	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@

; 970  :                 state->mode = BAD;
; 971  :                 break;

  00b75	e9 db 09 00 00	 jmp	 $LN948@inflate
$LN426@inflate:

; 946  :                 strm->msg = (char *)"too many length or distance symbols";

  00b7a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00b7d	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@

; 947  :                 state->mode = BAD;
; 948  :                 break;

  00b84	e9 cc 09 00 00	 jmp	 $LN948@inflate
$LN429@inflate:

; 972  :             }
; 973  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 974  :             state->have = 0;

  00b89	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], 0

; 975  :             state->mode = CODELENS;

  00b90	c7 41 04 46 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16198 ; 00003f46H
$LN536@inflate:

; 976  :                 /* fallthrough */
; 977  :         case CODELENS:
; 978  :             while (state->have < state->nlen + state->ndist) {

  00b97	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00b9a	03 41 64	 add	 eax, DWORD PTR [ecx+100]
  00b9d	39 41 6c	 cmp	 DWORD PTR [ecx+108], eax
  00ba0	0f 83 4a 02 00
	00		 jae	 $LN882@inflate
$LL185@inflate:

; 979  :                 for (;;) {
; 980  :                     here = state->lencode[BITS(state->lenbits)];

  00ba6	8b 4d c4	 mov	 ecx, DWORD PTR tv5121[ebp]
  00ba9	b8 01 00 00 00	 mov	 eax, 1
  00bae	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00bb0	d3 e0		 shl	 eax, cl
  00bb2	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00bb5	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00bb8	89 4d c0	 mov	 DWORD PTR tv5094[ebp], ecx
  00bbb	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00bbe	89 45 cc	 mov	 DWORD PTR tv5001[ebp], eax
  00bc1	8b c1		 mov	 eax, ecx
  00bc3	8b 4d cc	 mov	 ecx, DWORD PTR tv5001[ebp]
  00bc6	23 c2		 and	 eax, edx
  00bc8	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00bcb	8b c8		 mov	 ecx, eax
  00bcd	c1 e9 08	 shr	 ecx, 8
  00bd0	89 4d d8	 mov	 DWORD PTR $T8[ebp], ecx
  00bd3	89 45 d0	 mov	 DWORD PTR $T7[ebp], eax
  00bd6	c1 6d d0 10	 shr	 DWORD PTR $T7[ebp], 16	; 00000010H
  00bda	0f b6 c9	 movzx	 ecx, cl

; 981  :                     if ((unsigned)(here.bits) <= bits) break;

  00bdd	3b ce		 cmp	 ecx, esi
  00bdf	76 45		 jbe	 SHORT $LN878@inflate
$LL187@inflate:

; 982  :                     PULLBYTE();

  00be1	85 ff		 test	 edi, edi
  00be3	0f 84 ee f9 ff
	ff		 je	 $LN919@inflate
  00be9	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00bec	8b ce		 mov	 ecx, esi
  00bee	d3 e0		 shl	 eax, cl
  00bf0	43		 inc	 ebx
  00bf1	8b 4d cc	 mov	 ecx, DWORD PTR tv5001[ebp]
  00bf4	03 d0		 add	 edx, eax
  00bf6	8b 45 c0	 mov	 eax, DWORD PTR tv5094[ebp]
  00bf9	83 c6 08	 add	 esi, 8
  00bfc	23 c2		 and	 eax, edx
  00bfe	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00c01	4f		 dec	 edi
  00c02	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00c05	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00c08	8b c8		 mov	 ecx, eax
  00c0a	c1 e9 08	 shr	 ecx, 8
  00c0d	89 4d d8	 mov	 DWORD PTR $T8[ebp], ecx
  00c10	89 45 d0	 mov	 DWORD PTR tv4940[ebp], eax
  00c13	c1 6d d0 10	 shr	 DWORD PTR tv4940[ebp], 16 ; 00000010H
  00c17	0f b6 c9	 movzx	 ecx, cl
  00c1a	3b ce		 cmp	 ecx, esi
  00c1c	77 c3		 ja	 SHORT $LL187@inflate

; 981  :                     if ((unsigned)(here.bits) <= bits) break;

  00c1e	8b 4d d0	 mov	 ecx, DWORD PTR tv4940[ebp]
  00c21	0f b7 c9	 movzx	 ecx, cx
  00c24	eb 03		 jmp	 SHORT $LN563@inflate
$LN878@inflate:
  00c26	8b 4d d0	 mov	 ecx, DWORD PTR $T7[ebp]
$LN563@inflate:

; 983  :                 }
; 984  :                 if (here.val < 16) {

  00c29	0f b7 d9	 movzx	 ebx, cx
  00c2c	89 5d c0	 mov	 DWORD PTR tv4941[ebp], ebx
  00c2f	8b 5d f0	 mov	 ebx, DWORD PTR _next$1$[ebp]
  00c32	66 83 f9 10	 cmp	 cx, 16			; 00000010H
  00c36	73 33		 jae	 SHORT $LN433@inflate

; 985  :                     DROPBITS(here.bits);

  00c38	8b 4d d8	 mov	 ecx, DWORD PTR $T8[ebp]
  00c3b	d3 ea		 shr	 edx, cl
  00c3d	8b c8		 mov	 ecx, eax
  00c3f	c1 e9 08	 shr	 ecx, 8
  00c42	0f b6 c9	 movzx	 ecx, cl
  00c45	2b f1		 sub	 esi, ecx
  00c47	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx

; 986  :                     state->lens[state->have++] = here.val;

  00c4a	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00c4d	8b 55 f8	 mov	 edx, DWORD PTR _state$1$[ebp]
  00c50	c1 e8 10	 shr	 eax, 16			; 00000010H
  00c53	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00c56	8b 49 6c	 mov	 ecx, DWORD PTR [ecx+108]
  00c59	66 89 44 4a 74	 mov	 WORD PTR [edx+ecx*2+116], ax
  00c5e	8b ca		 mov	 ecx, edx
  00c60	ff 41 6c	 inc	 DWORD PTR [ecx+108]
  00c63	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]

; 987  :                 }

  00c66	e9 70 01 00 00	 jmp	 $LN949@inflate
$LN433@inflate:

; 988  :                 else {
; 989  :                     if (here.val == 16) {

  00c6b	8b 4d c0	 mov	 ecx, DWORD PTR tv4941[ebp]
  00c6e	66 83 f9 10	 cmp	 cx, 16			; 00000010H
  00c72	75 78		 jne	 SHORT $LN435@inflate

; 990  :                         NEEDBITS(here.bits + 2);

  00c74	8b 4d d8	 mov	 ecx, DWORD PTR $T8[ebp]
  00c77	c1 e8 08	 shr	 eax, 8
  00c7a	0f b6 c0	 movzx	 eax, al
  00c7d	89 45 cc	 mov	 DWORD PTR tv4998[ebp], eax
  00c80	0f b6 c1	 movzx	 eax, cl
  00c83	83 c0 02	 add	 eax, 2
  00c86	89 45 c0	 mov	 DWORD PTR tv4993[ebp], eax
  00c89	3b f0		 cmp	 esi, eax
  00c8b	73 24		 jae	 SHORT $LN196@inflate
  00c8d	0f 1f 00	 npad	 3
$LL199@inflate:
  00c90	85 ff		 test	 edi, edi
  00c92	0f 84 3f f9 ff
	ff		 je	 $LN919@inflate
  00c98	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00c9b	8b ce		 mov	 ecx, esi
  00c9d	d3 e0		 shl	 eax, cl
  00c9f	43		 inc	 ebx
  00ca0	03 d0		 add	 edx, eax
  00ca2	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00ca5	83 c6 08	 add	 esi, 8
  00ca8	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00cab	4f		 dec	 edi
  00cac	3b 75 c0	 cmp	 esi, DWORD PTR tv4993[ebp]
  00caf	72 df		 jb	 SHORT $LL199@inflate
$LN196@inflate:

; 991  :                         DROPBITS(here.bits);

  00cb1	8b 4d cc	 mov	 ecx, DWORD PTR tv4998[ebp]
  00cb4	2b f1		 sub	 esi, ecx
  00cb6	d3 ea		 shr	 edx, cl

; 992  :                         if (state->have == 0) {

  00cb8	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00cbb	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00cbe	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00cc1	83 79 6c 00	 cmp	 DWORD PTR [ecx+108], 0
  00cc5	0f 84 4b 01 00
	00		 je	 $LN568@inflate

; 993  :                             strm->msg = (char *)"invalid bit length repeat";
; 994  :                             state->mode = BAD;
; 995  :                             break;
; 996  :                         }
; 997  :                         len = state->lens[state->have - 1];
; 998  :                         copy = 3 + BITS(2);

  00ccb	8b c2		 mov	 eax, edx

; 999  :                         DROPBITS(2);

  00ccd	c1 ea 02	 shr	 edx, 2
  00cd0	83 e0 03	 and	 eax, 3
  00cd3	83 c0 03	 add	 eax, 3
  00cd6	83 ee 02	 sub	 esi, 2
  00cd9	89 45 d0	 mov	 DWORD PTR _copy$4$[ebp], eax
  00cdc	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00cdf	0f b7 44 41 72	 movzx	 eax, WORD PTR [ecx+eax*2+114]
  00ce4	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1000 :                     }

  00ce7	e9 ae 00 00 00	 jmp	 $LN950@inflate
$LN435@inflate:

; 1001 :                     else if (here.val == 17) {

  00cec	66 83 f9 11	 cmp	 cx, 17			; 00000011H
  00cf0	0f b6 c4	 movzx	 eax, ah
  00cf3	8b 4d d8	 mov	 ecx, DWORD PTR $T8[ebp]
  00cf6	75 4b		 jne	 SHORT $LN226@inflate

; 1002 :                         NEEDBITS(here.bits + 3);

  00cf8	89 45 cc	 mov	 DWORD PTR tv4992[ebp], eax
  00cfb	0f b6 c1	 movzx	 eax, cl
  00cfe	83 c0 03	 add	 eax, 3
  00d01	89 45 c0	 mov	 DWORD PTR tv4951[ebp], eax
  00d04	3b f0		 cmp	 esi, eax
  00d06	73 21		 jae	 SHORT $LN210@inflate
$LL213@inflate:
  00d08	85 ff		 test	 edi, edi
  00d0a	0f 84 c7 f8 ff
	ff		 je	 $LN919@inflate
  00d10	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00d13	8b ce		 mov	 ecx, esi
  00d15	d3 e0		 shl	 eax, cl
  00d17	43		 inc	 ebx
  00d18	03 d0		 add	 edx, eax
  00d1a	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00d1d	83 c6 08	 add	 esi, 8
  00d20	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00d23	4f		 dec	 edi
  00d24	3b 75 c0	 cmp	 esi, DWORD PTR tv4951[ebp]
  00d27	72 df		 jb	 SHORT $LL213@inflate
$LN210@inflate:

; 1003 :                         DROPBITS(here.bits);

  00d29	8b 4d cc	 mov	 ecx, DWORD PTR tv4992[ebp]
  00d2c	d3 ea		 shr	 edx, cl

; 1004 :                         len = 0;
; 1005 :                         copy = 3 + BITS(3);

  00d2e	8b c2		 mov	 eax, edx
  00d30	83 e0 07	 and	 eax, 7
  00d33	83 c0 03	 add	 eax, 3

; 1006 :                         DROPBITS(3);

  00d36	c1 ea 03	 shr	 edx, 3
  00d39	89 45 d0	 mov	 DWORD PTR _copy$4$[ebp], eax
  00d3c	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 1007 :                     }

  00d41	eb 49		 jmp	 SHORT $LN951@inflate
$LN226@inflate:

; 1008 :                     else {
; 1009 :                         NEEDBITS(here.bits + 7);

  00d43	89 45 cc	 mov	 DWORD PTR tv4990[ebp], eax
  00d46	0f b6 c1	 movzx	 eax, cl
  00d49	83 c0 07	 add	 eax, 7
  00d4c	89 45 c0	 mov	 DWORD PTR tv4950[ebp], eax
  00d4f	3b f0		 cmp	 esi, eax
  00d51	73 21		 jae	 SHORT $LN224@inflate
$LL227@inflate:
  00d53	85 ff		 test	 edi, edi
  00d55	0f 84 7c f8 ff
	ff		 je	 $LN919@inflate
  00d5b	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00d5e	8b ce		 mov	 ecx, esi
  00d60	d3 e0		 shl	 eax, cl
  00d62	43		 inc	 ebx
  00d63	03 d0		 add	 edx, eax
  00d65	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00d68	83 c6 08	 add	 esi, 8
  00d6b	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00d6e	4f		 dec	 edi
  00d6f	3b 75 c0	 cmp	 esi, DWORD PTR tv4950[ebp]
  00d72	72 df		 jb	 SHORT $LL227@inflate
$LN224@inflate:

; 1010 :                         DROPBITS(here.bits);

  00d74	8b 4d cc	 mov	 ecx, DWORD PTR tv4990[ebp]
  00d77	d3 ea		 shr	 edx, cl

; 1011 :                         len = 0;
; 1012 :                         copy = 11 + BITS(7);

  00d79	8b c2		 mov	 eax, edx
  00d7b	83 e0 7f	 and	 eax, 127		; 0000007fH
  00d7e	83 c0 0b	 add	 eax, 11			; 0000000bH

; 1013 :                         DROPBITS(7);

  00d81	c1 ea 07	 shr	 edx, 7
  00d84	89 45 d0	 mov	 DWORD PTR _copy$4$[ebp], eax
  00d87	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
$LN951@inflate:

; 1014 :                     }
; 1015 :                     if (state->have + copy > state->nlen + state->ndist) {

  00d8c	2b c1		 sub	 eax, ecx
  00d8e	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], 0
  00d95	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00d98	03 f0		 add	 esi, eax
$LN950@inflate:
  00d9a	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00d9d	8b 49 64	 mov	 ecx, DWORD PTR [ecx+100]
  00da0	89 45 d8	 mov	 DWORD PTR $T9[ebp], eax
  00da3	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00da6	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00da9	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00dac	03 48 68	 add	 ecx, DWORD PTR [eax+104]
  00daf	8b 45 d0	 mov	 eax, DWORD PTR _copy$4$[ebp]
  00db2	03 45 d8	 add	 eax, DWORD PTR $T9[ebp]
  00db5	3b c1		 cmp	 eax, ecx
  00db7	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00dba	77 5a		 ja	 SHORT $LN568@inflate
  00dbc	8b 55 d0	 mov	 edx, DWORD PTR _copy$4$[ebp]
  00dbf	8b 45 d8	 mov	 eax, DWORD PTR $T9[ebp]
  00dc2	8b 5d cc	 mov	 ebx, DWORD PTR $T4[ebp]
$LL238@inflate:

; 1016 :                         strm->msg = (char *)"invalid bit length repeat";
; 1017 :                         state->mode = BAD;
; 1018 :                         break;
; 1019 :                     }
; 1020 :                     while (copy--)
; 1021 :                         state->lens[state->have++] = (unsigned short)len;

  00dc5	66 89 5c 41 74	 mov	 WORD PTR [ecx+eax*2+116], bx
  00dca	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00dcd	8d 40 01	 lea	 eax, DWORD PTR [eax+1]
  00dd0	89 41 6c	 mov	 DWORD PTR [ecx+108], eax
  00dd3	83 ea 01	 sub	 edx, 1
  00dd6	75 ed		 jne	 SHORT $LL238@inflate
  00dd8	8b 5d f0	 mov	 ebx, DWORD PTR _next$1$[ebp]
$LN949@inflate:

; 976  :                 /* fallthrough */
; 977  :         case CODELENS:
; 978  :             while (state->have < state->nlen + state->ndist) {

  00ddb	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00dde	89 45 d8	 mov	 DWORD PTR $T9[ebp], eax
  00de1	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00de4	03 41 68	 add	 eax, DWORD PTR [ecx+104]
  00de7	39 45 d8	 cmp	 DWORD PTR $T9[ebp], eax
  00dea	0f 82 b6 fd ff
	ff		 jb	 $LL185@inflate
$LN882@inflate:

; 1022 :                 }
; 1023 :             }
; 1024 : 
; 1025 :             /* handle error breaks in while */
; 1026 :             if (state->mode == BAD) break;

  00df0	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
$LN186@inflate:
  00df3	81 79 04 51 3f
	00 00		 cmp	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00dfa	0f 84 5c 07 00
	00		 je	 $LN8@inflate

; 1027 : 
; 1028 :             /* check for end-of-block code (better have one) */
; 1029 :             if (state->lens[256] == 0) {

  00e00	66 83 b9 74 02
	00 00 00	 cmp	 WORD PTR [ecx+628], 0
  00e08	75 1f		 jne	 SHORT $LN445@inflate

; 1030 :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00e0a	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@

; 1031 :                 state->mode = BAD;
; 1032 :                 break;

  00e11	e9 3f 07 00 00	 jmp	 $LN948@inflate
$LN568@inflate:

; 1022 :                 }
; 1023 :             }
; 1024 : 
; 1025 :             /* handle error breaks in while */
; 1026 :             if (state->mode == BAD) break;

  00e16	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00e19	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
  00e20	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00e27	eb ca		 jmp	 SHORT $LN186@inflate
$LN445@inflate:

; 1033 :             }
; 1034 : 
; 1035 :             /* build code tables -- note: do not change the lenbits or distbits
; 1036 :                values here (9 and 6) without reading the comments in inftrees.h
; 1037 :                concerning the ENOUGH constants, which depend on those values */
; 1038 :             state->next = state->codes;

  00e29	8d 51 70	 lea	 edx, DWORD PTR [ecx+112]

; 1039 :             state->lencode = (const code FAR *)(state->next);
; 1040 :             state->lenbits = 9;

  00e2c	c7 41 58 09 00
	00 00		 mov	 DWORD PTR [ecx+88], 9
  00e33	8d 81 34 05 00
	00		 lea	 eax, DWORD PTR [ecx+1332]
  00e39	89 55 c0	 mov	 DWORD PTR tv5181[ebp], edx
  00e3c	89 02		 mov	 DWORD PTR [edx], eax
  00e3e	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 1041 :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  00e41	8d 81 f4 02 00
	00		 lea	 eax, DWORD PTR [ecx+756]
  00e47	50		 push	 eax
  00e48	8d 41 58	 lea	 eax, DWORD PTR [ecx+88]
  00e4b	50		 push	 eax
  00e4c	52		 push	 edx
  00e4d	ff 71 64	 push	 DWORD PTR [ecx+100]
  00e50	8d 51 74	 lea	 edx, DWORD PTR [ecx+116]
  00e53	b9 01 00 00 00	 mov	 ecx, 1
  00e58	e8 00 00 00 00	 call	 _inflate_table

; 1042 :                                 &(state->lenbits), state->work);
; 1043 :             if (ret) {

  00e5d	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00e60	83 c4 10	 add	 esp, 16			; 00000010H
  00e63	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00e66	85 c0		 test	 eax, eax
  00e68	74 12		 je	 SHORT $LN446@inflate

; 1044 :                 strm->msg = (char *)"invalid literal/lengths set";

  00e6a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 1045 :                 state->mode = BAD;
; 1046 :                 break;

  00e6d	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00e70	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@
  00e77	e9 d9 06 00 00	 jmp	 $LN948@inflate
$LN446@inflate:

; 1047 :             }
; 1048 :             state->distcode = (const code FAR *)(state->next);

  00e7c	8b 55 c0	 mov	 edx, DWORD PTR tv5181[ebp]

; 1049 :             state->distbits = 6;

  00e7f	c7 41 5c 06 00
	00 00		 mov	 DWORD PTR [ecx+92], 6
  00e86	8b 02		 mov	 eax, DWORD PTR [edx]
  00e88	89 41 54	 mov	 DWORD PTR [ecx+84], eax

; 1050 :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  00e8b	8d 81 f4 02 00
	00		 lea	 eax, DWORD PTR [ecx+756]
  00e91	50		 push	 eax
  00e92	8d 41 5c	 lea	 eax, DWORD PTR [ecx+92]
  00e95	50		 push	 eax
  00e96	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00e99	52		 push	 edx
  00e9a	ff 71 68	 push	 DWORD PTR [ecx+104]
  00e9d	83 c1 74	 add	 ecx, 116		; 00000074H
  00ea0	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00ea3	b9 02 00 00 00	 mov	 ecx, 2
  00ea8	e8 00 00 00 00	 call	 _inflate_table

; 1051 :                             &(state->next), &(state->distbits), state->work);
; 1052 :             if (ret) {

  00ead	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00eb0	83 c4 10	 add	 esp, 16			; 00000010H
  00eb3	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00eb6	85 c0		 test	 eax, eax
  00eb8	74 12		 je	 SHORT $LN447@inflate

; 1053 :                 strm->msg = (char *)"invalid distances set";

  00eba	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 1054 :                 state->mode = BAD;
; 1055 :                 break;

  00ebd	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00ec0	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set@
  00ec7	e9 89 06 00 00	 jmp	 $LN948@inflate
$LN447@inflate:

; 1056 :             }
; 1057 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1058 :             state->mode = LEN_;
; 1059 :             if (flush == Z_TREES) goto inf_leave;

  00ecc	8b 55 0c	 mov	 edx, DWORD PTR _flush$[ebp]
  00ecf	c7 41 04 47 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16199 ; 00003f47H
  00ed6	83 fa 06	 cmp	 edx, 6
  00ed9	0f 84 fb f6 ff
	ff		 je	 $inf_leave$954
  00edf	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN448@inflate:

; 1060 :                 /* fallthrough */
; 1061 :         case LEN_:
; 1062 :             state->mode = LEN;

  00ee2	c7 41 04 48 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16200 ; 00003f48H
$LN450@inflate:

; 1063 :                 /* fallthrough */
; 1064 :         case LEN:
; 1065 :             if (have >= 6 && left >= 258) {

  00ee9	83 ff 06	 cmp	 edi, 6
  00eec	72 72		 jb	 SHORT $LN451@inflate
  00eee	81 7d e8 02 01
	00 00		 cmp	 DWORD PTR _left$1$[ebp], 258 ; 00000102H
  00ef5	72 69		 jb	 SHORT $LN451@inflate

; 1066 :                 RESTORE();

  00ef7	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00efa	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  00efd	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00f00	8b 4d e8	 mov	 ecx, DWORD PTR _left$1$[ebp]
  00f03	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00f06	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00f09	89 18		 mov	 DWORD PTR [eax], ebx
  00f0b	89 78 04	 mov	 DWORD PTR [eax+4], edi
  00f0e	89 51 3c	 mov	 DWORD PTR [ecx+60], edx

; 1067 :                 inflate_fast(strm, out);

  00f11	8b 55 dc	 mov	 edx, DWORD PTR _out$1$[ebp]
  00f14	89 71 40	 mov	 DWORD PTR [ecx+64], esi
  00f17	8b c8		 mov	 ecx, eax
  00f19	e8 00 00 00 00	 call	 _inflate_fast

; 1068 :                 LOAD();

  00f1e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00f21	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00f24	8b 18		 mov	 ebx, DWORD PTR [eax]
  00f26	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00f29	89 4d e0	 mov	 DWORD PTR _put$1$[ebp], ecx
  00f2c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00f2f	89 4d e8	 mov	 DWORD PTR _left$1$[ebp], ecx
  00f32	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00f35	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx

; 1069 :                 if (state->mode == TYPE)

  00f38	81 79 04 3f 3f
	00 00		 cmp	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
  00f3f	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00f42	8b 71 40	 mov	 esi, DWORD PTR [ecx+64]
  00f45	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00f48	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00f4b	0f 85 0b 06 00
	00		 jne	 $LN8@inflate

; 1070 :                     state->back = -1;

  00f51	c7 81 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7112], -1

; 1071 :                 break;

  00f5b	e9 fc 05 00 00	 jmp	 $LN8@inflate
$LN451@inflate:

; 1072 :             }
; 1073 :             state->back = 0;

  00f60	c7 81 c8 1b 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+7112], 0

; 1074 :             for (;;) {
; 1075 :                 here = state->lencode[BITS(state->lenbits)];

  00f6a	b8 01 00 00 00	 mov	 eax, 1
  00f6f	8b 4d c4	 mov	 ecx, DWORD PTR tv5121[ebp]
  00f72	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00f74	d3 e0		 shl	 eax, cl
  00f76	48		 dec	 eax
  00f77	89 45 d0	 mov	 DWORD PTR tv5169[ebp], eax
  00f7a	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00f7d	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00f80	8b 45 d0	 mov	 eax, DWORD PTR tv5169[ebp]
  00f83	23 c2		 and	 eax, edx
  00f85	89 4d cc	 mov	 DWORD PTR tv5000[ebp], ecx
  00f88	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00f8b	8b c8		 mov	 ecx, eax
  00f8d	c1 e9 08	 shr	 ecx, 8
  00f90	0f b6 c9	 movzx	 ecx, cl

; 1076 :                 if ((unsigned)(here.bits) <= bits) break;

  00f93	3b ce		 cmp	 ecx, esi
  00f95	76 33		 jbe	 SHORT $LN570@inflate
$LL246@inflate:

; 1077 :                 PULLBYTE();

  00f97	85 ff		 test	 edi, edi
  00f99	0f 84 38 f6 ff
	ff		 je	 $LN919@inflate
  00f9f	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00fa2	8b ce		 mov	 ecx, esi
  00fa4	d3 e0		 shl	 eax, cl
  00fa6	43		 inc	 ebx
  00fa7	8b 4d cc	 mov	 ecx, DWORD PTR tv5000[ebp]
  00faa	03 d0		 add	 edx, eax
  00fac	8b 45 d0	 mov	 eax, DWORD PTR tv5169[ebp]
  00faf	83 c6 08	 add	 esi, 8
  00fb2	23 c2		 and	 eax, edx
  00fb4	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  00fb7	4f		 dec	 edi
  00fb8	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  00fbb	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00fbe	8b c8		 mov	 ecx, eax
  00fc0	c1 e9 08	 shr	 ecx, 8
  00fc3	0f b6 c9	 movzx	 ecx, cl
  00fc6	3b ce		 cmp	 ecx, esi
  00fc8	77 cd		 ja	 SHORT $LL246@inflate
$LN570@inflate:

; 1078 :             }
; 1079 :             if (here.op && (here.op & 0xf0) == 0) {

  00fca	84 c0		 test	 al, al
  00fcc	0f 84 a5 00 00
	00		 je	 $LN263@inflate
  00fd2	a8 f0		 test	 al, 240			; 000000f0H
  00fd4	0f 85 9d 00 00
	00		 jne	 $LN263@inflate

; 1080 :                 last = here;

  00fda	8b c8		 mov	 ecx, eax
  00fdc	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00fdf	89 4d d0	 mov	 DWORD PTR tv5113[ebp], ecx
  00fe2	8b c8		 mov	 ecx, eax
  00fe4	c1 e9 08	 shr	 ecx, 8

; 1081 :                 for (;;) {
; 1082 :                     here = state->lencode[last.val +

  00fe7	0f b6 c9	 movzx	 ecx, cl
  00fea	89 4d d8	 mov	 DWORD PTR tv5115[ebp], ecx
  00fed	0f b6 c8	 movzx	 ecx, al
  00ff0	b8 01 00 00 00	 mov	 eax, 1
  00ff5	03 4d d8	 add	 ecx, DWORD PTR tv5115[ebp]
  00ff8	d3 e0		 shl	 eax, cl
  00ffa	8b 4d d8	 mov	 ecx, DWORD PTR tv5115[ebp]
  00ffd	48		 dec	 eax
  00ffe	89 45 c0	 mov	 DWORD PTR tv5171[ebp], eax
  01001	23 c2		 and	 eax, edx

; 1083 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1084 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01003	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  01006	d3 e8		 shr	 eax, cl
  01008	03 45 d0	 add	 eax, DWORD PTR tv5113[ebp]
  0100b	8b 4d cc	 mov	 ecx, DWORD PTR tv5000[ebp]
  0100e	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  01011	8b c8		 mov	 ecx, eax
  01013	c1 e9 08	 shr	 ecx, 8
  01016	0f b6 c9	 movzx	 ecx, cl
  01019	03 4d d8	 add	 ecx, DWORD PTR tv5115[ebp]
  0101c	3b ce		 cmp	 ecx, esi
  0101e	76 3e		 jbe	 SHORT $LN260@inflate
$LL252@inflate:

; 1085 :                     PULLBYTE();

  01020	85 ff		 test	 edi, edi
  01022	0f 84 af f5 ff
	ff		 je	 $LN919@inflate
  01028	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0102b	8b ce		 mov	 ecx, esi
  0102d	d3 e0		 shl	 eax, cl
  0102f	43		 inc	 ebx
  01030	8b 4d d8	 mov	 ecx, DWORD PTR tv5115[ebp]
  01033	03 d0		 add	 edx, eax
  01035	8b 45 c0	 mov	 eax, DWORD PTR tv5171[ebp]
  01038	83 c6 08	 add	 esi, 8
  0103b	23 c2		 and	 eax, edx
  0103d	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  01040	d3 e8		 shr	 eax, cl
  01042	4f		 dec	 edi
  01043	03 45 d0	 add	 eax, DWORD PTR tv5113[ebp]
  01046	8b 4d cc	 mov	 ecx, DWORD PTR tv5000[ebp]
  01049	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  0104c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0104f	8b c8		 mov	 ecx, eax
  01051	c1 e9 08	 shr	 ecx, 8
  01054	0f b6 c9	 movzx	 ecx, cl
  01057	03 4d d8	 add	 ecx, DWORD PTR tv5115[ebp]
  0105a	3b ce		 cmp	 ecx, esi
  0105c	77 c2		 ja	 SHORT $LL252@inflate
$LN260@inflate:

; 1086 :                 }
; 1087 :                 DROPBITS(last.bits);

  0105e	8b 4d d8	 mov	 ecx, DWORD PTR tv5115[ebp]
  01061	d3 ea		 shr	 edx, cl
  01063	2b f1		 sub	 esi, ecx

; 1088 :                 state->back += last.bits;

  01065	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01068	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  0106b	8b 55 d8	 mov	 edx, DWORD PTR tv5115[ebp]
  0106e	89 91 c8 1b 00
	00		 mov	 DWORD PTR [ecx+7112], edx
  01074	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN263@inflate:

; 1089 :             }
; 1090 :             DROPBITS(here.bits);

  01077	8b c8		 mov	 ecx, eax
  01079	c1 e9 08	 shr	 ecx, 8
  0107c	0f b6 c9	 movzx	 ecx, cl
  0107f	d3 ea		 shr	 edx, cl
  01081	2b f1		 sub	 esi, ecx
  01083	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx

; 1091 :             state->back += here.bits;

  01086	8b 55 f8	 mov	 edx, DWORD PTR _state$1$[ebp]
  01089	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0108c	01 8a c8 1b 00
	00		 add	 DWORD PTR [edx+7112], ecx

; 1092 :             state->length = (unsigned)here.val;

  01092	8b c8		 mov	 ecx, eax
  01094	c1 e9 10	 shr	 ecx, 16			; 00000010H
  01097	89 4a 44	 mov	 DWORD PTR [edx+68], ecx

; 1093 :             if ((int)(here.op) == 0) {

  0109a	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  0109d	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  010a0	84 c0		 test	 al, al
  010a2	75 0c		 jne	 SHORT $LN458@inflate

; 1094 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1095 :                         "inflate:         literal '%c'\n" :
; 1096 :                         "inflate:         literal 0x%02x\n", here.val));
; 1097 :                 state->mode = LIT;

  010a4	c7 41 04 4d 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16205 ; 00003f4dH

; 1098 :                 break;

  010ab	e9 ac 04 00 00	 jmp	 $LN8@inflate
$LN458@inflate:

; 1099 :             }
; 1100 :             if (here.op & 32) {

  010b0	a8 20		 test	 al, 32			; 00000020H
  010b2	74 16		 je	 SHORT $LN459@inflate

; 1101 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1102 :                 state->back = -1;

  010b4	c7 81 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7112], -1
$LN419@inflate:

; 655  :     in = have;
; 656  :     out = left;
; 657  :     ret = Z_OK;
; 658  :     for (;;)
; 659  :         switch (state->mode) {

  010be	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
  010c5	e9 92 04 00 00	 jmp	 $LN8@inflate
$LN459@inflate:

; 1103 :                 state->mode = TYPE;
; 1104 :                 break;
; 1105 :             }
; 1106 :             if (here.op & 64) {

  010ca	a8 40		 test	 al, 64			; 00000040H
  010cc	74 0f		 je	 SHORT $LN460@inflate

; 1107 :                 strm->msg = (char *)"invalid literal/length code";

  010ce	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  010d1	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@

; 1108 :                 state->mode = BAD;
; 1109 :                 break;

  010d8	e9 78 04 00 00	 jmp	 $LN948@inflate
$LN460@inflate:

; 1110 :             }
; 1111 :             state->extra = (unsigned)(here.op) & 15;

  010dd	0f b6 c0	 movzx	 eax, al
  010e0	83 e0 0f	 and	 eax, 15			; 0000000fH

; 1112 :             state->mode = LENEXT;

  010e3	c7 41 04 49 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16201 ; 00003f49H
  010ea	89 41 4c	 mov	 DWORD PTR [ecx+76], eax
$LN461@inflate:

; 1113 :                 /* fallthrough */
; 1114 :         case LENEXT:
; 1115 :             if (state->extra) {

  010ed	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  010f0	89 45 cc	 mov	 DWORD PTR tv4985[ebp], eax
  010f3	85 c0		 test	 eax, eax
  010f5	74 52		 je	 SHORT $LN728@inflate

; 1116 :                 NEEDBITS(state->extra);

  010f7	3b f0		 cmp	 esi, eax
  010f9	73 26		 jae	 SHORT $LN264@inflate
  010fb	0f 1f 44 00 00	 npad	 5
$LL267@inflate:
  01100	85 ff		 test	 edi, edi
  01102	0f 84 cf f4 ff
	ff		 je	 $LN919@inflate
  01108	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0110b	8b ce		 mov	 ecx, esi
  0110d	d3 e0		 shl	 eax, cl
  0110f	43		 inc	 ebx
  01110	03 d0		 add	 edx, eax
  01112	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  01115	83 c6 08	 add	 esi, 8
  01118	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  0111b	4f		 dec	 edi
  0111c	3b 75 cc	 cmp	 esi, DWORD PTR tv4985[ebp]
  0111f	72 df		 jb	 SHORT $LL267@inflate
$LN264@inflate:

; 1117 :                 state->length += BITS(state->extra);

  01121	8b 4d cc	 mov	 ecx, DWORD PTR tv4985[ebp]
  01124	b8 01 00 00 00	 mov	 eax, 1
  01129	d3 e0		 shl	 eax, cl
  0112b	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0112e	48		 dec	 eax
  0112f	23 c2		 and	 eax, edx
  01131	01 41 44	 add	 DWORD PTR [ecx+68], eax

; 1118 :                 DROPBITS(state->extra);

  01134	8b 45 cc	 mov	 eax, DWORD PTR tv4985[ebp]
  01137	8b c8		 mov	 ecx, eax
  01139	d3 ea		 shr	 edx, cl
  0113b	2b f0		 sub	 esi, eax

; 1119 :                 state->back += state->extra;

  0113d	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01140	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  01143	01 81 c8 1b 00
	00		 add	 DWORD PTR [ecx+7112], eax
$LN728@inflate:

; 1120 :             }
; 1121 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1122 :             state->was = state->length;

  01149	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  0114c	89 81 cc 1b 00
	00		 mov	 DWORD PTR [ecx+7116], eax

; 1123 :             state->mode = DIST;

  01152	c7 41 04 4a 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16202 ; 00003f4aH
$LN464@inflate:

; 1124 :                 /* fallthrough */
; 1125 :         case DIST:
; 1126 :             for (;;) {
; 1127 :                 here = state->distcode[BITS(state->distbits)];

  01159	8b 4d bc	 mov	 ecx, DWORD PTR tv5116[ebp]
  0115c	b8 01 00 00 00	 mov	 eax, 1
  01161	8b 09		 mov	 ecx, DWORD PTR [ecx]
  01163	d3 e0		 shl	 eax, cl
  01165	48		 dec	 eax
  01166	89 45 d0	 mov	 DWORD PTR tv5173[ebp], eax
  01169	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  0116c	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0116f	8b 45 d0	 mov	 eax, DWORD PTR tv5173[ebp]
  01172	23 c2		 and	 eax, edx
  01174	89 4d cc	 mov	 DWORD PTR tv4983[ebp], ecx
  01177	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0117a	8b c8		 mov	 ecx, eax
  0117c	c1 e9 08	 shr	 ecx, 8
  0117f	0f b6 c9	 movzx	 ecx, cl

; 1128 :                 if ((unsigned)(here.bits) <= bits) break;

  01182	3b ce		 cmp	 ecx, esi
  01184	76 33		 jbe	 SHORT $LN575@inflate
$LL275@inflate:

; 1129 :                 PULLBYTE();

  01186	85 ff		 test	 edi, edi
  01188	0f 84 49 f4 ff
	ff		 je	 $LN919@inflate
  0118e	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  01191	8b ce		 mov	 ecx, esi
  01193	d3 e0		 shl	 eax, cl
  01195	43		 inc	 ebx
  01196	8b 4d cc	 mov	 ecx, DWORD PTR tv4983[ebp]
  01199	03 d0		 add	 edx, eax
  0119b	8b 45 d0	 mov	 eax, DWORD PTR tv5173[ebp]
  0119e	83 c6 08	 add	 esi, 8
  011a1	23 c2		 and	 eax, edx
  011a3	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  011a6	4f		 dec	 edi
  011a7	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  011aa	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  011ad	8b c8		 mov	 ecx, eax
  011af	c1 e9 08	 shr	 ecx, 8
  011b2	0f b6 c9	 movzx	 ecx, cl
  011b5	3b ce		 cmp	 ecx, esi
  011b7	77 cd		 ja	 SHORT $LL275@inflate
$LN575@inflate:

; 1130 :             }
; 1131 :             if ((here.op & 0xf0) == 0) {

  011b9	a8 f0		 test	 al, 240			; 000000f0H
  011bb	0f 85 a3 00 00
	00		 jne	 $LN292@inflate

; 1132 :                 last = here;

  011c1	8b c8		 mov	 ecx, eax
  011c3	c1 e9 10	 shr	 ecx, 16			; 00000010H
  011c6	89 4d d0	 mov	 DWORD PTR tv5111[ebp], ecx
  011c9	8b c8		 mov	 ecx, eax
  011cb	c1 e9 08	 shr	 ecx, 8

; 1133 :                 for (;;) {
; 1134 :                     here = state->distcode[last.val +

  011ce	0f b6 c9	 movzx	 ecx, cl
  011d1	89 4d d8	 mov	 DWORD PTR tv5112[ebp], ecx
  011d4	0f b6 c8	 movzx	 ecx, al
  011d7	b8 01 00 00 00	 mov	 eax, 1
  011dc	03 4d d8	 add	 ecx, DWORD PTR tv5112[ebp]
  011df	d3 e0		 shl	 eax, cl
  011e1	8b 4d d8	 mov	 ecx, DWORD PTR tv5112[ebp]
  011e4	48		 dec	 eax
  011e5	89 45 c0	 mov	 DWORD PTR tv5176[ebp], eax
  011e8	23 c2		 and	 eax, edx
  011ea	d3 e8		 shr	 eax, cl
  011ec	03 45 d0	 add	 eax, DWORD PTR tv5111[ebp]
  011ef	8b 4d cc	 mov	 ecx, DWORD PTR tv4983[ebp]
  011f2	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  011f5	8b c8		 mov	 ecx, eax
  011f7	c1 e9 08	 shr	 ecx, 8

; 1135 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1136 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  011fa	0f b6 c9	 movzx	 ecx, cl
  011fd	03 4d d8	 add	 ecx, DWORD PTR tv5112[ebp]
  01200	3b ce		 cmp	 ecx, esi
  01202	76 3e		 jbe	 SHORT $LN289@inflate
$LL281@inflate:

; 1137 :                     PULLBYTE();

  01204	85 ff		 test	 edi, edi
  01206	0f 84 cb f3 ff
	ff		 je	 $LN919@inflate
  0120c	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0120f	8b ce		 mov	 ecx, esi
  01211	d3 e0		 shl	 eax, cl
  01213	43		 inc	 ebx
  01214	8b 4d d8	 mov	 ecx, DWORD PTR tv5112[ebp]
  01217	03 d0		 add	 edx, eax
  01219	8b 45 c0	 mov	 eax, DWORD PTR tv5176[ebp]
  0121c	83 c6 08	 add	 esi, 8
  0121f	23 c2		 and	 eax, edx
  01221	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  01224	d3 e8		 shr	 eax, cl
  01226	4f		 dec	 edi
  01227	03 45 d0	 add	 eax, DWORD PTR tv5111[ebp]
  0122a	8b 4d cc	 mov	 ecx, DWORD PTR tv4983[ebp]
  0122d	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  01230	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  01233	8b c8		 mov	 ecx, eax
  01235	c1 e9 08	 shr	 ecx, 8
  01238	0f b6 c9	 movzx	 ecx, cl
  0123b	03 4d d8	 add	 ecx, DWORD PTR tv5112[ebp]
  0123e	3b ce		 cmp	 ecx, esi
  01240	77 c2		 ja	 SHORT $LL281@inflate
$LN289@inflate:

; 1138 :                 }
; 1139 :                 DROPBITS(last.bits);

  01242	8b 4d d8	 mov	 ecx, DWORD PTR tv5112[ebp]
  01245	2b f1		 sub	 esi, ecx
  01247	d3 ea		 shr	 edx, cl

; 1140 :                 state->back += last.bits;

  01249	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0124c	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  0124f	8b 55 f8	 mov	 edx, DWORD PTR _state$1$[ebp]
  01252	8b 89 c8 1b 00
	00		 mov	 ecx, DWORD PTR [ecx+7112]
  01258	03 4d d8	 add	 ecx, DWORD PTR tv5112[ebp]
  0125b	89 8a c8 1b 00
	00		 mov	 DWORD PTR [edx+7112], ecx
  01261	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN292@inflate:

; 1141 :             }
; 1142 :             DROPBITS(here.bits);

  01264	8b c8		 mov	 ecx, eax
  01266	c1 e9 08	 shr	 ecx, 8
  01269	0f b6 c9	 movzx	 ecx, cl
  0126c	d3 ea		 shr	 edx, cl
  0126e	2b f1		 sub	 esi, ecx
  01270	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx

; 1143 :             state->back += here.bits;

  01273	8b 55 f8	 mov	 edx, DWORD PTR _state$1$[ebp]
  01276	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  01279	01 8a c8 1b 00
	00		 add	 DWORD PTR [edx+7112], ecx

; 1144 :             if (here.op & 64) {

  0127f	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  01282	a8 40		 test	 al, 64			; 00000040H
  01284	74 12		 je	 SHORT $LN470@inflate

; 1145 :                 strm->msg = (char *)"invalid distance code";

  01286	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 1146 :                 state->mode = BAD;

  01289	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0128c	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code@

; 1147 :                 break;

  01293	e9 bd 02 00 00	 jmp	 $LN948@inflate
$LN470@inflate:

; 1148 :             }
; 1149 :             state->offset = (unsigned)here.val;

  01298	8b 55 f8	 mov	 edx, DWORD PTR _state$1$[ebp]
  0129b	8b c8		 mov	 ecx, eax
  0129d	c1 e9 10	 shr	 ecx, 16			; 00000010H

; 1150 :             state->extra = (unsigned)(here.op) & 15;

  012a0	0f b6 c0	 movzx	 eax, al
  012a3	83 e0 0f	 and	 eax, 15			; 0000000fH
  012a6	89 4a 48	 mov	 DWORD PTR [edx+72], ecx
  012a9	8b ca		 mov	 ecx, edx
  012ab	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  012ae	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 1151 :             state->mode = DISTEXT;

  012b1	c7 41 04 4b 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16203 ; 00003f4bH
$LN471@inflate:

; 1152 :                 /* fallthrough */
; 1153 :         case DISTEXT:
; 1154 :             if (state->extra) {

  012b8	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  012bb	89 45 cc	 mov	 DWORD PTR tv4984[ebp], eax
  012be	85 c0		 test	 eax, eax
  012c0	74 50		 je	 SHORT $LN730@inflate

; 1155 :                 NEEDBITS(state->extra);

  012c2	3b f0		 cmp	 esi, eax
  012c4	73 21		 jae	 SHORT $LN293@inflate
$LL296@inflate:
  012c6	85 ff		 test	 edi, edi
  012c8	0f 84 09 f3 ff
	ff		 je	 $LN919@inflate
  012ce	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  012d1	8b ce		 mov	 ecx, esi
  012d3	d3 e0		 shl	 eax, cl
  012d5	43		 inc	 ebx
  012d6	03 d0		 add	 edx, eax
  012d8	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  012db	83 c6 08	 add	 esi, 8
  012de	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  012e1	4f		 dec	 edi
  012e2	3b 75 cc	 cmp	 esi, DWORD PTR tv4984[ebp]
  012e5	72 df		 jb	 SHORT $LL296@inflate
$LN293@inflate:

; 1156 :                 state->offset += BITS(state->extra);

  012e7	8b 4d cc	 mov	 ecx, DWORD PTR tv4984[ebp]
  012ea	b8 01 00 00 00	 mov	 eax, 1
  012ef	d3 e0		 shl	 eax, cl
  012f1	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  012f4	48		 dec	 eax
  012f5	23 c2		 and	 eax, edx
  012f7	01 41 48	 add	 DWORD PTR [ecx+72], eax

; 1157 :                 DROPBITS(state->extra);

  012fa	8b 45 cc	 mov	 eax, DWORD PTR tv4984[ebp]
  012fd	8b c8		 mov	 ecx, eax
  012ff	d3 ea		 shr	 edx, cl
  01301	2b f0		 sub	 esi, eax

; 1158 :                 state->back += state->extra;

  01303	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01306	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  01309	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0130c	01 81 c8 1b 00
	00		 add	 DWORD PTR [ecx+7112], eax
$LN730@inflate:

; 1159 :             }
; 1160 : #ifdef INFLATE_STRICT
; 1161 :             if (state->offset > state->dmax) {
; 1162 :                 strm->msg = (char *)"invalid distance too far back";
; 1163 :                 state->mode = BAD;
; 1164 :                 break;
; 1165 :             }
; 1166 : #endif
; 1167 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1168 :             state->mode = MATCH;

  01312	c7 41 04 4c 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16204 ; 00003f4cH
$LN474@inflate:

; 1169 :                 /* fallthrough */
; 1170 :         case MATCH:
; 1171 :             if (left == 0) goto inf_leave;

  01319	83 7d e8 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  0131d	0f 84 b4 f2 ff
	ff		 je	 $LN919@inflate

; 1172 :             copy = out - left;

  01323	8b 45 dc	 mov	 eax, DWORD PTR _out$1$[ebp]
  01326	2b 45 e8	 sub	 eax, DWORD PTR _left$1$[ebp]
  01329	89 45 cc	 mov	 DWORD PTR _copy$5$[ebp], eax

; 1173 :             if (state->offset > copy) {         /* copy from window */

  0132c	8b 41 48	 mov	 eax, DWORD PTR [ecx+72]
  0132f	89 45 d8	 mov	 DWORD PTR _copy$6$[ebp], eax
  01332	3b 45 cc	 cmp	 eax, DWORD PTR _copy$5$[ebp]
  01335	76 52		 jbe	 SHORT $LN476@inflate

; 1174 :                 copy = state->offset - copy;

  01337	2b 45 cc	 sub	 eax, DWORD PTR _copy$5$[ebp]
  0133a	89 45 d8	 mov	 DWORD PTR _copy$6$[ebp], eax

; 1175 :                 if (copy > state->whave) {

  0133d	3b 41 30	 cmp	 eax, DWORD PTR [ecx+48]
  01340	76 18		 jbe	 SHORT $LN479@inflate

; 1176 :                     if (state->sane) {

  01342	83 b9 c4 1b 00
	00 00		 cmp	 DWORD PTR [ecx+7108], 0
  01349	74 0f		 je	 SHORT $LN479@inflate

; 1177 :                         strm->msg = (char *)"invalid distance too far back";

  0134b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0134e	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@

; 1178 :                         state->mode = BAD;
; 1179 :                         break;

  01355	e9 fb 01 00 00	 jmp	 $LN948@inflate
$LN479@inflate:

; 1180 :                     }
; 1181 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1182 :                     Trace((stderr, "inflate.c too far\n"));
; 1183 :                     copy -= state->whave;
; 1184 :                     if (copy > state->length) copy = state->length;
; 1185 :                     if (copy > left) copy = left;
; 1186 :                     left -= copy;
; 1187 :                     state->length -= copy;
; 1188 :                     do {
; 1189 :                         *put++ = 0;
; 1190 :                     } while (--copy);
; 1191 :                     if (state->length == 0) state->mode = LEN;
; 1192 :                     break;
; 1193 : #endif
; 1194 :                 }
; 1195 :                 if (copy > state->wnext) {

  0135a	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  0135d	39 45 d8	 cmp	 DWORD PTR _copy$6$[ebp], eax
  01360	76 06		 jbe	 SHORT $LN480@inflate

; 1196 :                     copy -= state->wnext;

  01362	29 45 d8	 sub	 DWORD PTR _copy$6$[ebp], eax

; 1197 :                     from = state->window + (state->wsize - copy);

  01365	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
$LN480@inflate:

; 1198 :                 }
; 1199 :                 else
; 1200 :                     from = state->window + (state->wnext - copy);
; 1201 :                 if (copy > state->length) copy = state->length;

  01368	2b 45 d8	 sub	 eax, DWORD PTR _copy$6$[ebp]
  0136b	03 41 38	 add	 eax, DWORD PTR [ecx+56]
  0136e	89 45 d0	 mov	 DWORD PTR _from$1$[ebp], eax
  01371	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]

; 1202 :             }

  01374	8b c8		 mov	 ecx, eax
  01376	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax
  01379	8b 45 d8	 mov	 eax, DWORD PTR _copy$6$[ebp]
  0137c	3b c1		 cmp	 eax, ecx
  0137e	0f 46 c8	 cmovbe	 ecx, eax
  01381	89 4d d8	 mov	 DWORD PTR _copy$7$[ebp], ecx
  01384	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01387	eb 12		 jmp	 SHORT $LN477@inflate
$LN476@inflate:

; 1203 :             else {                              /* copy from output */
; 1204 :                 from = put - state->offset;

  01389	8b 45 e0	 mov	 eax, DWORD PTR _put$1$[ebp]
  0138c	2b 45 d8	 sub	 eax, DWORD PTR _copy$6$[ebp]
  0138f	89 45 d0	 mov	 DWORD PTR _from$1$[ebp], eax

; 1205 :                 copy = state->length;

  01392	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  01395	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax
  01398	89 45 d8	 mov	 DWORD PTR _copy$7$[ebp], eax
$LN477@inflate:

; 1206 :             }
; 1207 :             if (copy > left) copy = left;
; 1208 :             left -= copy;

  0139b	8b 5d e8	 mov	 ebx, DWORD PTR _left$1$[ebp]
  0139e	8b c3		 mov	 eax, ebx
  013a0	39 5d d8	 cmp	 DWORD PTR _copy$7$[ebp], ebx

; 1209 :             state->length -= copy;

  013a3	8b 55 cc	 mov	 edx, DWORD PTR $T2[ebp]
  013a6	0f 46 45 d8	 cmovbe	 eax, DWORD PTR _copy$7$[ebp]
  013aa	2b d0		 sub	 edx, eax
  013ac	89 45 c0	 mov	 DWORD PTR _copy$8$[ebp], eax
  013af	2b d8		 sub	 ebx, eax
  013b1	89 51 44	 mov	 DWORD PTR [ecx+68], edx
  013b4	8b 55 d0	 mov	 edx, DWORD PTR _from$1$[ebp]
  013b7	8b c8		 mov	 ecx, eax
  013b9	89 5d e8	 mov	 DWORD PTR _left$1$[ebp], ebx
  013bc	8b 5d e0	 mov	 ebx, DWORD PTR _put$1$[ebp]
  013bf	2b d3		 sub	 edx, ebx
$LL306@inflate:

; 1210 :             do {
; 1211 :                 *put++ = *from++;

  013c1	8a 04 1a	 mov	 al, BYTE PTR [edx+ebx]
  013c4	88 03		 mov	 BYTE PTR [ebx], al
  013c6	43		 inc	 ebx

; 1212 :             } while (--copy);

  013c7	83 e9 01	 sub	 ecx, 1
  013ca	75 f5		 jne	 SHORT $LL306@inflate

; 1213 :             if (state->length == 0) state->mode = LEN;

  013cc	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  013cf	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
  013d2	89 5d e0	 mov	 DWORD PTR _put$1$[ebp], ebx
  013d5	8b 5d f0	 mov	 ebx, DWORD PTR _next$1$[ebp]
  013d8	83 79 44 00	 cmp	 DWORD PTR [ecx+68], 0
  013dc	0f 85 7a 01 00
	00		 jne	 $LN8@inflate
  013e2	c7 41 04 48 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16200 ; 00003f48H

; 1214 :             break;

  013e9	e9 6e 01 00 00	 jmp	 $LN8@inflate
$LN485@inflate:

; 1215 :         case LIT:
; 1216 :             if (left == 0) goto inf_leave;

  013ee	83 7d e8 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  013f2	0f 84 df f1 ff
	ff		 je	 $LN919@inflate

; 1217 :             *put++ = (unsigned char)(state->length);

  013f8	8a 41 44	 mov	 al, BYTE PTR [ecx+68]
  013fb	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  013fe	ff 45 e0	 inc	 DWORD PTR _put$1$[ebp]

; 1218 :             left--;

  01401	ff 4d e8	 dec	 DWORD PTR _left$1$[ebp]
  01404	88 01		 mov	 BYTE PTR [ecx], al

; 1219 :             state->mode = LEN;

  01406	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01409	c7 41 04 48 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16200 ; 00003f48H

; 1220 :             break;

  01410	e9 47 01 00 00	 jmp	 $LN8@inflate
$LN487@inflate:

; 1221 :         case CHECK:
; 1222 :             if (state->wrap) {

  01415	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  01419	0f 84 d5 00 00
	00		 je	 $LN316@inflate

; 1223 :                 NEEDBITS(32);

  0141f	83 fe 20	 cmp	 esi, 32			; 00000020H
  01422	73 24		 jae	 SHORT $LN307@inflate
$LL310@inflate:
  01424	85 ff		 test	 edi, edi
  01426	0f 84 ab f1 ff
	ff		 je	 $LN919@inflate
  0142c	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0142f	8b ce		 mov	 ecx, esi
  01431	d3 e0		 shl	 eax, cl
  01433	83 c6 08	 add	 esi, 8
  01436	03 d0		 add	 edx, eax
  01438	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0143b	43		 inc	 ebx
  0143c	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  0143f	4f		 dec	 edi
  01440	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  01443	83 fe 20	 cmp	 esi, 32			; 00000020H
  01446	72 dc		 jb	 SHORT $LL310@inflate
$LN307@inflate:

; 1224 :                 out -= left;

  01448	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  0144b	29 45 dc	 sub	 DWORD PTR _out$1$[ebp], eax

; 1225 :                 strm->total_out += out;

  0144e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01451	8b 4d dc	 mov	 ecx, DWORD PTR _out$1$[ebp]
  01454	01 48 14	 add	 DWORD PTR [eax+20], ecx

; 1226 :                 state->total += out;

  01457	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0145a	8b 45 dc	 mov	 eax, DWORD PTR _out$1$[ebp]
  0145d	01 41 20	 add	 DWORD PTR [ecx+32], eax

; 1227 :                 if ((state->wrap & 4) && out)

  01460	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  01464	74 33		 je	 SHORT $LN490@inflate
  01466	85 c0		 test	 eax, eax
  01468	74 2f		 je	 SHORT $LN490@inflate

; 1228 :                     strm->adler = state->check =

  0146a	8b 45 e0	 mov	 eax, DWORD PTR _put$1$[ebp]
  0146d	ff 75 dc	 push	 DWORD PTR _out$1$[ebp]
  01470	2b 45 dc	 sub	 eax, DWORD PTR _out$1$[ebp]
  01473	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  01477	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0147a	50		 push	 eax
  0147b	52		 push	 edx
  0147c	74 07		 je	 SHORT $LN512@inflate
  0147e	e8 00 00 00 00	 call	 _crc32@12
  01483	eb 05		 jmp	 SHORT $LN513@inflate
$LN512@inflate:
  01485	e8 00 00 00 00	 call	 _adler32@12
$LN513@inflate:
  0148a	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0148d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01490	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  01493	89 42 30	 mov	 DWORD PTR [edx+48], eax
  01496	8b 55 f4	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN490@inflate:

; 1229 :                         UPDATE_CHECK(state->check, put - out, out);
; 1230 :                 out = left;
; 1231 :                 if ((state->wrap & 4) && (

  01499	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  0149d	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  014a0	89 45 dc	 mov	 DWORD PTR _out$1$[ebp], eax
  014a3	74 45		 je	 SHORT $LN317@inflate
  014a5	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  014a9	8b c2		 mov	 eax, edx
  014ab	75 2c		 jne	 SHORT $LN515@inflate
  014ad	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  014b2	89 45 d8	 mov	 DWORD PTR tv5143[ebp], eax
  014b5	8b c2		 mov	 eax, edx
  014b7	c1 e0 10	 shl	 eax, 16			; 00000010H
  014ba	01 45 d8	 add	 DWORD PTR tv5143[ebp], eax
  014bd	8b c2		 mov	 eax, edx
  014bf	c1 65 d8 08	 shl	 DWORD PTR tv5143[ebp], 8
  014c3	c1 e8 08	 shr	 eax, 8
  014c6	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  014cb	01 45 d8	 add	 DWORD PTR tv5143[ebp], eax
  014ce	8b c2		 mov	 eax, edx
  014d0	c1 e8 18	 shr	 eax, 24			; 00000018H
  014d3	01 45 d8	 add	 DWORD PTR tv5143[ebp], eax
  014d6	8b 45 d8	 mov	 eax, DWORD PTR tv5143[ebp]
$LN515@inflate:
  014d9	3b 41 1c	 cmp	 eax, DWORD PTR [ecx+28]
  014dc	74 0c		 je	 SHORT $LN317@inflate

; 1232 : #ifdef GUNZIP
; 1233 :                      state->flags ? hold :
; 1234 : #endif
; 1235 :                      ZSWAP32(hold)) != state->check) {
; 1236 :                     strm->msg = (char *)"incorrect data check";

  014de	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  014e1	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BF@MEIGEHBE@incorrect?5data?5check@

; 1237 :                     state->mode = BAD;
; 1238 :                     break;

  014e8	eb 6b		 jmp	 SHORT $LN948@inflate
$LN317@inflate:

; 1239 :                 }
; 1240 :                 INITBITS();

  014ea	33 d2		 xor	 edx, edx
  014ec	33 f6		 xor	 esi, esi
  014ee	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  014f1	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN316@inflate:

; 1241 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1242 :             }
; 1243 : #ifdef GUNZIP
; 1244 :             state->mode = LENGTH;

  014f4	c7 41 04 4f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16207 ; 00003f4fH
$LN492@inflate:

; 1245 :                 /* fallthrough */
; 1246 :         case LENGTH:
; 1247 :             if (state->wrap && state->flags) {

  014fb	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  014fe	89 45 c0	 mov	 DWORD PTR tv5074[ebp], eax
  01501	85 c0		 test	 eax, eax
  01503	0f 84 a6 00 00
	00		 je	 $LN327@inflate
  01509	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  0150d	0f 84 9c 00 00
	00		 je	 $LN327@inflate

; 1248 :                 NEEDBITS(32);

  01513	83 fe 20	 cmp	 esi, 32			; 00000020H
  01516	73 2a		 jae	 SHORT $LN318@inflate
$LL321@inflate:
  01518	85 ff		 test	 edi, edi
  0151a	0f 84 b7 f0 ff
	ff		 je	 $LN919@inflate
  01520	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  01523	8b ce		 mov	 ecx, esi
  01525	d3 e0		 shl	 eax, cl
  01527	83 c6 08	 add	 esi, 8
  0152a	03 d0		 add	 edx, eax
  0152c	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0152f	43		 inc	 ebx
  01530	89 55 f4	 mov	 DWORD PTR _hold$1$[ebp], edx
  01533	4f		 dec	 edi
  01534	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  01537	83 fe 20	 cmp	 esi, 32			; 00000020H
  0153a	72 dc		 jb	 SHORT $LL321@inflate
  0153c	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0153f	8b 45 c0	 mov	 eax, DWORD PTR tv5074[ebp]
$LN318@inflate:

; 1249 :                 if ((state->wrap & 4) && hold != (state->total & 0xffffffff)) {

  01542	a8 04		 test	 al, 4
  01544	74 60		 je	 SHORT $LN328@inflate
  01546	3b 51 20	 cmp	 edx, DWORD PTR [ecx+32]
  01549	74 5b		 je	 SHORT $LN328@inflate

; 1250 :                     strm->msg = (char *)"incorrect length check";

  0154b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0154e	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
$LN948@inflate:

; 655  :     in = have;
; 656  :     out = left;
; 657  :     ret = Z_OK;
; 658  :     for (;;)
; 659  :         switch (state->mode) {

  01555	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
$LN8@inflate:
  0155c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0155f	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  01564	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  01567	0f 86 33 eb ff
	ff		 jbe	 $LL5@inflate
$LN333@inflate:
  0156d	5f		 pop	 edi

; 1300 :         ret = Z_BUF_ERROR;
; 1301 :     return ret;
; 1302 : }

  0156e	5e		 pop	 esi
  0156f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  01574	5b		 pop	 ebx
  01575	8b e5		 mov	 esp, ebp
  01577	5d		 pop	 ebp
  01578	c2 08 00	 ret	 8
$LN587@inflate:

; 856  :                 RESTORE();

  0157b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0157e	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  01581	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  01584	8b 4d e8	 mov	 ecx, DWORD PTR _left$1$[ebp]
  01587	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0158a	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0158d	89 78 04	 mov	 DWORD PTR [eax+4], edi
  01590	89 18		 mov	 DWORD PTR [eax], ebx

; 857  :                 return Z_NEED_DICT;

  01592	b8 02 00 00 00	 mov	 eax, 2
  01597	5f		 pop	 edi
  01598	89 71 40	 mov	 DWORD PTR [ecx+64], esi

; 1300 :         ret = Z_BUF_ERROR;
; 1301 :     return ret;
; 1302 : }

  0159b	5e		 pop	 esi
  0159c	89 51 3c	 mov	 DWORD PTR [ecx+60], edx
  0159f	5b		 pop	 ebx
  015a0	8b e5		 mov	 esp, ebp
  015a2	5d		 pop	 ebp
  015a3	c2 08 00	 ret	 8
$LN328@inflate:

; 1251 :                     state->mode = BAD;
; 1252 :                     break;
; 1253 :                 }
; 1254 :                 INITBITS();

  015a6	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  015ad	33 f6		 xor	 esi, esi
$LN327@inflate:

; 1255 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1256 :             }
; 1257 : #endif
; 1258 :             state->mode = DONE;

  015af	c7 41 04 50 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16208 ; 00003f50H
$LN496@inflate:

; 1259 :                 /* fallthrough */
; 1260 :         case DONE:
; 1261 :             ret = Z_STREAM_END;

  015b6	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _ret$1$[ebp], 1

; 1262 :             goto inf_leave;

  015bd	e9 15 f0 ff ff	 jmp	 $LN919@inflate
$LN497@inflate:

; 1263 :         case BAD:
; 1264 :             ret = Z_DATA_ERROR;

  015c2	c7 45 d4 fd ff
	ff ff		 mov	 DWORD PTR _ret$1$[ebp], -3 ; fffffffdH
  015c9	e9 09 f0 ff ff	 jmp	 $LN919@inflate
$LN906@inflate:

; 1265 :             goto inf_leave;
; 1266 :         case MEM:
; 1267 :             return Z_MEM_ERROR;
; 1268 :         case SYNC:
; 1269 :                 /* fallthrough */
; 1270 :         default:
; 1271 :             return Z_STREAM_ERROR;
; 1272 :         }
; 1273 : 
; 1274 :     /*
; 1275 :        Return from inflate(), updating the total counts and the check value.
; 1276 :        If there was no progress during the inflate() call, return a buffer
; 1277 :        error.  Call updatewindow() to create and/or update the window state.
; 1278 :        Note: a memory error from inflate() is non-recoverable.
; 1279 :      */
; 1280 :   inf_leave:
; 1281 :     RESTORE();

  015ce	8b d0		 mov	 edx, eax
  015d0	e9 05 f0 ff ff	 jmp	 $inf_leave$954
$LN883@inflate:

; 1283 :             (state->mode < CHECK || flush != Z_FINISH)))
; 1284 :         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {

  015d5	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
$LN504@inflate:

; 1286 :             return Z_MEM_ERROR;
; 1287 :         }
; 1288 :     in -= strm->avail_in;

  015d8	8b 45 c8	 mov	 eax, DWORD PTR _in$1$[ebp]
  015db	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]

; 1289 :     out -= strm->avail_out;

  015de	2b 71 10	 sub	 esi, DWORD PTR [ecx+16]

; 1290 :     strm->total_in += in;

  015e1	01 41 08	 add	 DWORD PTR [ecx+8], eax

; 1291 :     strm->total_out += out;

  015e4	01 71 14	 add	 DWORD PTR [ecx+20], esi

; 1292 :     state->total += out;

  015e7	01 73 20	 add	 DWORD PTR [ebx+32], esi

; 1293 :     if ((state->wrap & 4) && out)

  015ea	f6 43 0c 04	 test	 BYTE PTR [ebx+12], 4
  015ee	89 45 c8	 mov	 DWORD PTR _in$1$[ebp], eax
  015f1	89 75 dc	 mov	 DWORD PTR _out$1$[ebp], esi
  015f4	74 35		 je	 SHORT $LN880@inflate
  015f6	85 f6		 test	 esi, esi
  015f8	74 31		 je	 SHORT $LN880@inflate

; 1294 :         strm->adler = state->check =

  015fa	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  015fd	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  01600	2b c6		 sub	 eax, esi
  01602	83 7b 14 00	 cmp	 DWORD PTR [ebx+20], 0
  01606	56		 push	 esi
  01607	50		 push	 eax
  01608	51		 push	 ecx
  01609	74 10		 je	 SHORT $LN516@inflate
  0160b	e8 00 00 00 00	 call	 _crc32@12
  01610	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  01613	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  01616	89 47 30	 mov	 DWORD PTR [edi+48], eax
  01619	eb 13		 jmp	 SHORT $LN505@inflate
$LN516@inflate:
  0161b	e8 00 00 00 00	 call	 _adler32@12
  01620	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  01623	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  01626	89 47 30	 mov	 DWORD PTR [edi+48], eax
  01629	eb 03		 jmp	 SHORT $LN505@inflate
$LN880@inflate:

; 1295 :             UPDATE_CHECK(state->check, strm->next_out - out, out);
; 1296 :     strm->data_type = (int)state->bits + (state->last ? 64 : 0) +

  0162b	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
$LN505@inflate:
  0162e	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  01631	81 fa 47 3f 00
	00		 cmp	 edx, 16199		; 00003f47H
  01637	74 0c		 je	 SHORT $LN518@inflate
  01639	81 fa 42 3f 00
	00		 cmp	 edx, 16194		; 00003f42H
  0163f	74 04		 je	 SHORT $LN518@inflate
  01641	33 f6		 xor	 esi, esi
  01643	eb 05		 jmp	 SHORT $LN519@inflate
$LN518@inflate:
  01645	be 00 01 00 00	 mov	 esi, 256		; 00000100H
$LN519@inflate:
  0164a	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0164d	f7 d9		 neg	 ecx
  0164f	c7 45 08 80 00
	00 00		 mov	 DWORD PTR tv4924[ebp], 128 ; 00000080H
  01656	1b c9		 sbb	 ecx, ecx
  01658	33 c0		 xor	 eax, eax
  0165a	83 e1 40	 and	 ecx, 64			; 00000040H
  0165d	81 fa 3f 3f 00
	00		 cmp	 edx, 16191		; 00003f3fH
  01663	0f 44 45 08	 cmove	 eax, DWORD PTR tv4924[ebp]
  01667	03 ce		 add	 ecx, esi
  01669	03 c1		 add	 eax, ecx
  0166b	03 43 40	 add	 eax, DWORD PTR [ebx+64]

; 1297 :                       (state->mode == TYPE ? 128 : 0) +
; 1298 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
; 1299 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  0166e	83 7d c8 00	 cmp	 DWORD PTR _in$1$[ebp], 0
  01672	89 47 2c	 mov	 DWORD PTR [edi+44], eax
  01675	75 06		 jne	 SHORT $LN508@inflate
  01677	83 7d dc 00	 cmp	 DWORD PTR _out$1$[ebp], 0
  0167b	74 06		 je	 SHORT $LN507@inflate
$LN508@inflate:
  0167d	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  01681	75 16		 jne	 SHORT $LN885@inflate
$LN507@inflate:
  01683	8b 45 d4	 mov	 eax, DWORD PTR _ret$1$[ebp]
  01686	b9 fb ff ff ff	 mov	 ecx, -5			; fffffffbH
  0168b	5f		 pop	 edi
  0168c	85 c0		 test	 eax, eax

; 1300 :         ret = Z_BUF_ERROR;
; 1301 :     return ret;
; 1302 : }

  0168e	5e		 pop	 esi
  0168f	0f 44 c1	 cmove	 eax, ecx
  01692	5b		 pop	 ebx
  01693	8b e5		 mov	 esp, ebp
  01695	5d		 pop	 ebp
  01696	c2 08 00	 ret	 8
$LN885@inflate:

; 1297 :                       (state->mode == TYPE ? 128 : 0) +
; 1298 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
; 1299 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  01699	8b 45 d4	 mov	 eax, DWORD PTR _ret$1$[ebp]
  0169c	5f		 pop	 edi

; 1300 :         ret = Z_BUF_ERROR;
; 1301 :     return ret;
; 1302 : }

  0169d	5e		 pop	 esi
  0169e	5b		 pop	 ebx
  0169f	8b e5		 mov	 esp, ebp
  016a1	5d		 pop	 ebp
  016a2	c2 08 00	 ret	 8
  016a5	0f 1f 00	 npad	 3
$LN791@inflate:
  016a8	00 00 00 00	 DD	 $LN335@inflate
  016ac	00 00 00 00	 DD	 $LN32@inflate
  016b0	00 00 00 00	 DD	 $LN46@inflate
  016b4	00 00 00 00	 DD	 $LN60@inflate
  016b8	00 00 00 00	 DD	 $LN361@inflate
  016bc	00 00 00 00	 DD	 $LN368@inflate
  016c0	00 00 00 00	 DD	 $LN375@inflate
  016c4	00 00 00 00	 DD	 $LN384@inflate
  016c8	00 00 00 00	 DD	 $LN393@inflate
  016cc	00 00 00 00	 DD	 $LN105@inflate
  016d0	00 00 00 00	 DD	 $LN400@inflate
  016d4	00 00 00 00	 DD	 $LN402@inflate
  016d8	00 00 00 00	 DD	 $LN403@inflate
  016dc	00 00 00 00	 DD	 $LN141@inflate
  016e0	00 00 00 00	 DD	 $LN416@inflate
  016e4	00 00 00 00	 DD	 $LN418@inflate
  016e8	00 00 00 00	 DD	 $LN155@inflate
  016ec	00 00 00 00	 DD	 $LN533@inflate
  016f0	00 00 00 00	 DD	 $LN536@inflate
  016f4	00 00 00 00	 DD	 $LN448@inflate
  016f8	00 00 00 00	 DD	 $LN450@inflate
  016fc	00 00 00 00	 DD	 $LN461@inflate
  01700	00 00 00 00	 DD	 $LN464@inflate
  01704	00 00 00 00	 DD	 $LN471@inflate
  01708	00 00 00 00	 DD	 $LN474@inflate
  0170c	00 00 00 00	 DD	 $LN485@inflate
  01710	00 00 00 00	 DD	 $LN487@inflate
  01714	00 00 00 00	 DD	 $LN492@inflate
  01718	00 00 00 00	 DD	 $LN496@inflate
  0171c	00 00 00 00	 DD	 $LN497@inflate
  01720	00 00 00 00	 DD	 $LN498@inflate
  01724	00 00 00 00	 DD	 $LN333@inflate
$LN792@inflate:
  01728	00 00 00 00	 DD	 $LN408@inflate
  0172c	00 00 00 00	 DD	 $LN409@inflate
  01730	00 00 00 00	 DD	 $LN411@inflate
  01734	00 00 00 00	 DD	 $LN412@inflate
_inflate@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateEnd@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateEnd@4 PROC					; COMDAT

; 1306 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]

; 1307 :     struct inflate_state FAR *state;
; 1308 :     if (inflateStateCheck(strm))

  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 _inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0a		 je	 SHORT $LN2@inflateEnd

; 1309 :         return Z_STREAM_ERROR;

  00012	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00017	5e		 pop	 esi

; 1316 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN2@inflateEnd:

; 1310 :     state = (struct inflate_state FAR *)strm->state;
; 1311 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  0001c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0001f	53		 push	 ebx
  00020	57		 push	 edi
  00021	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00024	85 c0		 test	 eax, eax
  00026	74 0c		 je	 SHORT $LN5@inflateEnd
  00028	50		 push	 eax
  00029	ff 76 28	 push	 DWORD PTR [esi+40]
  0002c	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0002f	ff d0		 call	 eax
  00031	83 c4 08	 add	 esp, 8
$LN5@inflateEnd:

; 1312 :     ZFREE(strm, strm->state);

  00034	ff 76 1c	 push	 DWORD PTR [esi+28]
  00037	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0003a	ff 76 28	 push	 DWORD PTR [esi+40]
  0003d	ff d0		 call	 eax
  0003f	83 c4 08	 add	 esp, 8

; 1313 :     strm->state = Z_NULL;

  00042	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 1314 :     Tracev((stderr, "inflate: end\n"));
; 1315 :     return Z_OK;

  00049	33 c0		 xor	 eax, eax
  0004b	5f		 pop	 edi
  0004c	5b		 pop	 ebx
  0004d	5e		 pop	 esi

; 1316 : }

  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
_inflateEnd@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateStateCheck
_TEXT	SEGMENT
_inflateStateCheck PROC					; COMDAT
; _strm$ = ecx

; 108  :     struct inflate_state FAR *state;
; 109  :     if (strm == Z_NULL ||
; 110  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)

  00000	85 c9		 test	 ecx, ecx
  00002	74 27		 je	 SHORT $LN3@inflateSta
  00004	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  00008	74 21		 je	 SHORT $LN3@inflateSta
  0000a	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0000e	74 1b		 je	 SHORT $LN3@inflateSta

; 112  :     state = (struct inflate_state FAR *)strm->state;

  00010	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 113  :     if (state == Z_NULL || state->strm != strm ||
; 114  :         state->mode < HEAD || state->mode > SYNC)

  00013	85 c0		 test	 eax, eax
  00015	74 14		 je	 SHORT $LN3@inflateSta
  00017	39 08		 cmp	 DWORD PTR [eax], ecx
  00019	75 10		 jne	 SHORT $LN3@inflateSta
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  00023	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00026	77 03		 ja	 SHORT $LN3@inflateSta

; 115  :         return 1;
; 116  :     return 0;

  00028	33 c0		 xor	 eax, eax

; 117  : }

  0002a	c3		 ret	 0
$LN3@inflateSta:

; 111  :         return 1;

  0002b	b8 01 00 00 00	 mov	 eax, 1

; 117  : }

  00030	c3		 ret	 0
_inflateStateCheck ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateResetKeep@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateResetKeep@4 PROC				; COMDAT

; 121  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 122  :     struct inflate_state FAR *state;
; 123  : 
; 124  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	8b ca		 mov	 ecx, edx
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	85 c0		 test	 eax, eax
  0000f	74 09		 je	 SHORT $LN2@inflateRes
  00011	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 143  : }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN2@inflateRes:

; 125  :     state = (struct inflate_state FAR *)strm->state;

  0001a	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]

; 126  :     strm->total_in = strm->total_out = state->total = 0;

  0001d	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
  00024	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0
  0002b	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 127  :     strm->msg = Z_NULL;

  00032	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 128  :     if (state->wrap)        /* to support ill-conceived Java test suite */

  00039	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0003c	85 c0		 test	 eax, eax
  0003e	74 06		 je	 SHORT $LN3@inflateRes

; 129  :         strm->adler = state->wrap & 1;

  00040	83 e0 01	 and	 eax, 1
  00043	89 42 30	 mov	 DWORD PTR [edx+48], eax
$LN3@inflateRes:

; 130  :     state->mode = HEAD;
; 131  :     state->last = 0;
; 132  :     state->havedict = 0;
; 133  :     state->flags = -1;
; 134  :     state->dmax = 32768U;
; 135  :     state->head = Z_NULL;
; 136  :     state->hold = 0;
; 137  :     state->bits = 0;
; 138  :     state->lencode = state->distcode = state->next = state->codes;

  00046	8d 81 34 05 00
	00		 lea	 eax, DWORD PTR [ecx+1332]
  0004c	c7 41 04 34 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16180 ; 00003f34H
  00053	89 41 70	 mov	 DWORD PTR [ecx+112], eax
  00056	89 41 54	 mov	 DWORD PTR [ecx+84], eax
  00059	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 139  :     state->sane = 1;
; 140  :     state->back = -1;
; 141  :     Tracev((stderr, "inflate: reset\n"));
; 142  :     return Z_OK;

  0005c	33 c0		 xor	 eax, eax
  0005e	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00065	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0006c	c7 41 14 ff ff
	ff ff		 mov	 DWORD PTR [ecx+20], -1
  00073	c7 41 18 00 80
	00 00		 mov	 DWORD PTR [ecx+24], 32768 ; 00008000H
  0007a	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0
  00081	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0
  00088	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0
  0008f	c7 81 c4 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+7108], 1
  00099	c7 81 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7112], -1

; 143  : }

  000a3	5d		 pop	 ebp
  000a4	c2 04 00	 ret	 4
_inflateResetKeep@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateReset2@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_inflateReset2@8 PROC					; COMDAT

; 161  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 162  :     int wrap;
; 163  :     struct inflate_state FAR *state;
; 164  : 
; 165  :     /* get the state */
; 166  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 75 0c	 mov	 esi, DWORD PTR _windowBits$[ebp]
  0000b	57		 push	 edi
  0000c	e8 00 00 00 00	 call	 _inflateStateCheck
  00011	85 c0		 test	 eax, eax
  00013	75 65		 jne	 SHORT $LN8@inflateRes

; 167  :     state = (struct inflate_state FAR *)strm->state;

  00015	8b 59 1c	 mov	 ebx, DWORD PTR [ecx+28]

; 168  : 
; 169  :     /* extract wrap request from windowBits parameter */
; 170  :     if (windowBits < 0) {

  00018	85 f6		 test	 esi, esi
  0001a	79 0b		 jns	 SHORT $LN3@inflateRes

; 171  :         if (windowBits < -15)

  0001c	83 fe f1	 cmp	 esi, -15		; fffffff1H
  0001f	7c 59		 jl	 SHORT $LN8@inflateRes

; 172  :             return Z_STREAM_ERROR;
; 173  :         wrap = 0;

  00021	33 ff		 xor	 edi, edi

; 174  :         windowBits = -windowBits;

  00023	f7 de		 neg	 esi

; 175  :     }

  00025	eb 10		 jmp	 SHORT $LN6@inflateRes
$LN3@inflateRes:

; 176  :     else {
; 177  :         wrap = (windowBits >> 4) + 5;

  00027	8b fe		 mov	 edi, esi
  00029	c1 ef 04	 shr	 edi, 4
  0002c	83 c7 05	 add	 edi, 5

; 178  : #ifdef GUNZIP
; 179  :         if (windowBits < 48)

  0002f	83 fe 30	 cmp	 esi, 48			; 00000030H
  00032	7d 03		 jge	 SHORT $LN6@inflateRes

; 180  :             windowBits &= 15;

  00034	83 e6 0f	 and	 esi, 15			; 0000000fH
$LN6@inflateRes:

; 181  : #endif
; 182  :     }
; 183  : 
; 184  :     /* set number of window bits, free window if different */
; 185  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  00037	85 f6		 test	 esi, esi
  00039	74 0a		 je	 SHORT $LN7@inflateRes
  0003b	83 fe 08	 cmp	 esi, 8
  0003e	7c 3a		 jl	 SHORT $LN8@inflateRes
  00040	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  00043	7f 35		 jg	 SHORT $LN8@inflateRes
$LN7@inflateRes:

; 186  :         return Z_STREAM_ERROR;
; 187  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  00045	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  00048	85 c0		 test	 eax, eax
  0004a	74 1b		 je	 SHORT $LN9@inflateRes
  0004c	39 73 28	 cmp	 DWORD PTR [ebx+40], esi
  0004f	74 16		 je	 SHORT $LN9@inflateRes

; 188  :         ZFREE(strm, state->window);

  00051	50		 push	 eax
  00052	ff 71 28	 push	 DWORD PTR [ecx+40]
  00055	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00058	ff d0		 call	 eax
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0005d	83 c4 08	 add	 esp, 8

; 189  :         state->window = Z_NULL;

  00060	c7 43 38 00 00
	00 00		 mov	 DWORD PTR [ebx+56], 0
$LN9@inflateRes:

; 190  :     }
; 191  : 
; 192  :     /* update state and reset the rest of it */
; 193  :     state->wrap = wrap;
; 194  :     state->wbits = (unsigned)windowBits;
; 195  :     return inflateReset(strm);

  00067	51		 push	 ecx
  00068	89 7b 0c	 mov	 DWORD PTR [ebx+12], edi
  0006b	89 73 28	 mov	 DWORD PTR [ebx+40], esi
  0006e	e8 00 00 00 00	 call	 _inflateReset@4
  00073	5f		 pop	 edi

; 196  : }

  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	5d		 pop	 ebp
  00077	c2 08 00	 ret	 8
$LN8@inflateRes:
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00081	5b		 pop	 ebx
  00082	5d		 pop	 ebp
  00083	c2 08 00	 ret	 8
_inflateReset2@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateInit_@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_version$ = 12						; size = 4
_stream_size$ = 16					; size = 4
_inflateInit_@12 PROC					; COMDAT

; 246  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 247  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00003	ff 75 10	 push	 DWORD PTR _stream_size$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _version$[ebp]
  00009	6a 0f		 push	 15			; 0000000fH
  0000b	ff 75 08	 push	 DWORD PTR _strm$[ebp]
  0000e	e8 00 00 00 00	 call	 _inflateInit2_@16

; 248  : }

  00013	5d		 pop	 ebp
  00014	c2 0c 00	 ret	 12			; 0000000cH
_inflateInit_@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflatePrime@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_bits$ = 12						; size = 4
_value$ = 16						; size = 4
_inflatePrime@12 PROC					; COMDAT

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 255  :     struct inflate_state FAR *state;
; 256  : 
; 257  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	85 c0		 test	 eax, eax
  0000f	75 43		 jne	 SHORT $LN5@inflatePri

; 258  :     state = (struct inflate_state FAR *)strm->state;

  00011	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]

; 259  :     if (bits < 0) {

  00014	8b 4d 0c	 mov	 ecx, DWORD PTR _bits$[ebp]
  00017	85 c9		 test	 ecx, ecx
  00019	79 0c		 jns	 SHORT $LN3@inflatePri

; 260  :         state->hold = 0;

  0001b	5f		 pop	 edi
  0001c	89 42 3c	 mov	 DWORD PTR [edx+60], eax

; 261  :         state->bits = 0;

  0001f	89 42 40	 mov	 DWORD PTR [edx+64], eax

; 269  : }

  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c2 0c 00	 ret	 12			; 0000000cH
$LN3@inflatePri:

; 262  :         return Z_OK;
; 263  :     }
; 264  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  00027	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0002a	7f 28		 jg	 SHORT $LN5@inflatePri
  0002c	8b 72 40	 mov	 esi, DWORD PTR [edx+64]
  0002f	8d 3c 0e	 lea	 edi, DWORD PTR [esi+ecx]
  00032	83 ff 20	 cmp	 edi, 32			; 00000020H
  00035	77 1d		 ja	 SHORT $LN5@inflatePri

; 265  :     value &= (1L << bits) - 1;

  00037	b8 01 00 00 00	 mov	 eax, 1

; 266  :     state->hold += (unsigned)value << state->bits;
; 267  :     state->bits += (uInt)bits;

  0003c	89 7a 40	 mov	 DWORD PTR [edx+64], edi
  0003f	d3 e0		 shl	 eax, cl
  00041	8b ce		 mov	 ecx, esi
  00043	48		 dec	 eax
  00044	23 45 10	 and	 eax, DWORD PTR _value$[ebp]
  00047	d3 e0		 shl	 eax, cl
  00049	01 42 3c	 add	 DWORD PTR [edx+60], eax

; 268  :     return Z_OK;

  0004c	33 c0		 xor	 eax, eax
  0004e	5f		 pop	 edi

; 269  : }

  0004f	5e		 pop	 esi
  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
$LN5@inflatePri:
  00054	5f		 pop	 edi

; 262  :         return Z_OK;
; 263  :     }
; 264  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  00055	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 269  : }

  0005a	5e		 pop	 esi
  0005b	5d		 pop	 ebp
  0005c	c2 0c 00	 ret	 12			; 0000000cH
_inflatePrime@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _fixedtables
_TEXT	SEGMENT
_fixedtables PROC					; COMDAT
; _state$ = ecx

; 284  : #ifdef BUILDFIXED
; 285  :     static int virgin = 1;
; 286  :     static code *lenfix, *distfix;
; 287  :     static code fixed[544];
; 288  : 
; 289  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 290  :     if (virgin) {
; 291  :         unsigned sym, bits;
; 292  :         static code *next;
; 293  : 
; 294  :         /* literal/length table */
; 295  :         sym = 0;
; 296  :         while (sym < 144) state->lens[sym++] = 8;
; 297  :         while (sym < 256) state->lens[sym++] = 9;
; 298  :         while (sym < 280) state->lens[sym++] = 7;
; 299  :         while (sym < 288) state->lens[sym++] = 8;
; 300  :         next = fixed;
; 301  :         lenfix = next;
; 302  :         bits = 9;
; 303  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 304  : 
; 305  :         /* distance table */
; 306  :         sym = 0;
; 307  :         while (sym < 32) state->lens[sym++] = 5;
; 308  :         distfix = next;
; 309  :         bits = 5;
; 310  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 311  : 
; 312  :         /* do this just once */
; 313  :         virgin = 0;
; 314  :     }
; 315  : #else /* !BUILDFIXED */
; 316  : #   include "inffixed.h"
; 317  : #endif /* BUILDFIXED */
; 318  :     state->lencode = lenfix;

  00000	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], OFFSET ?lenfix@?1??fixedtables@@9@9

; 319  :     state->lenbits = 9;

  00007	c7 41 58 09 00
	00 00		 mov	 DWORD PTR [ecx+88], 9

; 320  :     state->distcode = distfix;

  0000e	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], OFFSET ?distfix@?1??fixedtables@@9@9

; 321  :     state->distbits = 5;

  00015	c7 41 5c 05 00
	00 00		 mov	 DWORD PTR [ecx+92], 5

; 322  : }

  0001c	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _updatewindow
_TEXT	SEGMENT
$T1 = -4						; size = 4
_copy$ = 8						; size = 4
_updatewindow PROC					; COMDAT
; _strm$ = ecx
; _end$ = edx

; 403  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b da		 mov	 ebx, edx
  00007	8b d1		 mov	 edx, ecx
  00009	56		 push	 esi

; 404  :     struct inflate_state FAR *state;
; 405  :     unsigned dist;
; 406  : 
; 407  :     state = (struct inflate_state FAR *)strm->state;

  0000a	8b 72 1c	 mov	 esi, DWORD PTR [edx+28]

; 408  : 
; 409  :     /* if it hasn't been done already, allocate space for the window */
; 410  :     if (state->window == Z_NULL) {

  0000d	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00010	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  00013	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00016	85 c0		 test	 eax, eax
  00018	75 2f		 jne	 SHORT $LN16@updatewind

; 411  :         state->window = (unsigned char FAR *)

  0001a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001c	b8 01 00 00 00	 mov	 eax, 1
  00021	d3 e0		 shl	 eax, cl
  00023	6a 01		 push	 1
  00025	50		 push	 eax
  00026	ff 72 28	 push	 DWORD PTR [edx+40]
  00029	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0002c	ff d0		 call	 eax
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00031	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00034	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 412  :                         ZALLOC(strm, 1U << state->wbits,
; 413  :                                sizeof(unsigned char));
; 414  :         if (state->window == Z_NULL) return 1;

  00037	85 c0		 test	 eax, eax
  00039	75 0b		 jne	 SHORT $LN17@updatewind
  0003b	5e		 pop	 esi
  0003c	b8 01 00 00 00	 mov	 eax, 1

; 447  : }

  00041	5b		 pop	 ebx
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
$LN17@updatewind:

; 412  :                         ZALLOC(strm, 1U << state->wbits,
; 413  :                                sizeof(unsigned char));
; 414  :         if (state->window == Z_NULL) return 1;

  00046	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
$LN16@updatewind:
  00049	57		 push	 edi

; 415  :     }
; 416  : 
; 417  :     /* if window not in use yet, initialize */
; 418  :     if (state->wsize == 0) {

  0004a	8b 7e 2c	 mov	 edi, DWORD PTR [esi+44]
  0004d	85 ff		 test	 edi, edi
  0004f	75 1a		 jne	 SHORT $LN15@updatewind

; 419  :         state->wsize = 1U << state->wbits;

  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	bf 01 00 00 00	 mov	 edi, 1
  00058	d3 e7		 shl	 edi, cl
  0005a	89 7e 2c	 mov	 DWORD PTR [esi+44], edi

; 420  :         state->wnext = 0;

  0005d	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0

; 421  :         state->whave = 0;

  00064	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
$LN15@updatewind:

; 422  :     }
; 423  : 
; 424  :     /* copy state->wsize or less output bytes into the circular window */
; 425  :     if (copy >= state->wsize) {

  0006b	8b 55 08	 mov	 edx, DWORD PTR _copy$[ebp]
  0006e	3b d7		 cmp	 edx, edi
  00070	72 23		 jb	 SHORT $LN5@updatewind

; 426  :         zmemcpy(state->window, end - state->wsize, state->wsize);

  00072	57		 push	 edi
  00073	2b df		 sub	 ebx, edi
  00075	53		 push	 ebx
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _memcpy

; 427  :         state->wnext = 0;
; 428  :         state->whave = state->wsize;

  0007c	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 444  :         }
; 445  :     }
; 446  :     return 0;

  00082	89 46 30	 mov	 DWORD PTR [esi+48], eax
  00085	33 c0		 xor	 eax, eax
  00087	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi

; 447  : }

  00090	5b		 pop	 ebx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
$LN5@updatewind:

; 429  :     }
; 430  :     else {
; 431  :         dist = state->wsize - state->wnext;

  00095	2b 7e 34	 sub	 edi, DWORD PTR [esi+52]

; 432  :         if (dist > copy) dist = copy;
; 433  :         zmemcpy(state->window + state->wnext, end - copy, dist);

  00098	8b c3		 mov	 eax, ebx
  0009a	3b fa		 cmp	 edi, edx
  0009c	0f 47 fa	 cmova	 edi, edx
  0009f	2b c2		 sub	 eax, edx
  000a1	57		 push	 edi
  000a2	50		 push	 eax
  000a3	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  000a6	03 46 34	 add	 eax, DWORD PTR [esi+52]
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 _memcpy

; 434  :         copy -= dist;

  000af	8b 45 08	 mov	 eax, DWORD PTR _copy$[ebp]
  000b2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b5	2b c7		 sub	 eax, edi
  000b7	89 45 08	 mov	 DWORD PTR _copy$[ebp], eax

; 435  :         if (copy) {

  000ba	74 24		 je	 SHORT $LN8@updatewind

; 436  :             zmemcpy(state->window, end - copy, copy);

  000bc	50		 push	 eax
  000bd	2b d8		 sub	 ebx, eax
  000bf	53		 push	 ebx
  000c0	ff 76 38	 push	 DWORD PTR [esi+56]
  000c3	e8 00 00 00 00	 call	 _memcpy

; 437  :             state->wnext = copy;
; 438  :             state->whave = state->wsize;

  000c8	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ce	8b 55 08	 mov	 edx, DWORD PTR _copy$[ebp]

; 444  :         }
; 445  :     }
; 446  :     return 0;

  000d1	89 46 30	 mov	 DWORD PTR [esi+48], eax
  000d4	33 c0		 xor	 eax, eax
  000d6	89 56 34	 mov	 DWORD PTR [esi+52], edx
  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi

; 447  : }

  000db	5b		 pop	 ebx
  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c3		 ret	 0
$LN8@updatewind:

; 439  :         }
; 440  :         else {
; 441  :             state->wnext += dist;

  000e0	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]

; 442  :             if (state->wnext == state->wsize) state->wnext = 0;

  000e3	33 d2		 xor	 edx, edx
  000e5	03 cf		 add	 ecx, edi
  000e7	3b 4e 2c	 cmp	 ecx, DWORD PTR [esi+44]
  000ea	0f 44 ca	 cmove	 ecx, edx
  000ed	89 4e 34	 mov	 DWORD PTR [esi+52], ecx

; 443  :             if (state->whave < state->wsize) state->whave += dist;

  000f0	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  000f3	3b 4e 2c	 cmp	 ecx, DWORD PTR [esi+44]
  000f6	73 06		 jae	 SHORT $LN11@updatewind
  000f8	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]

; 444  :         }
; 445  :     }
; 446  :     return 0;

  000fb	89 46 30	 mov	 DWORD PTR [esi+48], eax
$LN11@updatewind:
  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi
  00100	33 c0		 xor	 eax, eax

; 447  : }

  00102	5b		 pop	 ebx
  00103	8b e5		 mov	 esp, ebp
  00105	5d		 pop	 ebp
  00106	c3		 ret	 0
_updatewindow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateGetDictionary@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateGetDictionary@12 PROC				; COMDAT

; 1322 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 :     struct inflate_state FAR *state;
; 1324 : 
; 1325 :     /* check state */
; 1326 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateGet
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1339 : }

  00014	5d		 pop	 ebp
  00015	c2 0c 00	 ret	 12			; 0000000cH
$LN2@inflateGet:
  00018	56		 push	 esi

; 1327 :     state = (struct inflate_state FAR *)strm->state;

  00019	8b 71 1c	 mov	 esi, DWORD PTR [ecx+28]

; 1328 : 
; 1329 :     /* copy dictionary */
; 1330 :     if (state->whave && dictionary != Z_NULL) {

  0001c	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0001f	85 c0		 test	 eax, eax
  00021	74 31		 je	 SHORT $LN3@inflateGet
  00023	57		 push	 edi
  00024	8b 7d 0c	 mov	 edi, DWORD PTR _dictionary$[ebp]
  00027	85 ff		 test	 edi, edi
  00029	74 28		 je	 SHORT $LN6@inflateGet

; 1331 :         zmemcpy(dictionary, state->window + state->wnext,

  0002b	2b 46 34	 sub	 eax, DWORD PTR [esi+52]
  0002e	50		 push	 eax
  0002f	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00032	03 46 34	 add	 eax, DWORD PTR [esi+52]
  00035	50		 push	 eax
  00036	57		 push	 edi
  00037	e8 00 00 00 00	 call	 _memcpy

; 1332 :                 state->whave - state->wnext);
; 1333 :         zmemcpy(dictionary + state->whave - state->wnext,

  0003c	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  0003f	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00042	51		 push	 ecx
  00043	ff 76 38	 push	 DWORD PTR [esi+56]
  00046	2b c1		 sub	 eax, ecx
  00048	03 c7		 add	 eax, edi
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 _memcpy
  00050	83 c4 18	 add	 esp, 24			; 00000018H
$LN6@inflateGet:
  00053	5f		 pop	 edi
$LN3@inflateGet:

; 1334 :                 state->window, state->wnext);
; 1335 :     }
; 1336 :     if (dictLength != Z_NULL)

  00054	8b 4d 10	 mov	 ecx, DWORD PTR _dictLength$[ebp]
  00057	85 c9		 test	 ecx, ecx
  00059	74 05		 je	 SHORT $LN4@inflateGet

; 1337 :         *dictLength = state->whave;

  0005b	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0005e	89 01		 mov	 DWORD PTR [ecx], eax
$LN4@inflateGet:

; 1338 :     return Z_OK;

  00060	33 c0		 xor	 eax, eax
  00062	5e		 pop	 esi

; 1339 : }

  00063	5d		 pop	 ebp
  00064	c2 0c 00	 ret	 12			; 0000000cH
_inflateGetDictionary@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateSetDictionary@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateSetDictionary@12 PROC				; COMDAT

; 1345 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1346 :     struct inflate_state FAR *state;
; 1347 :     unsigned long dictid;
; 1348 :     int ret;
; 1349 : 
; 1350 :     /* check state */
; 1351 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _strm$[ebp]
  00007	8b cb		 mov	 ecx, ebx
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	e8 00 00 00 00	 call	 _inflateStateCheck
  00010	85 c0		 test	 eax, eax
  00012	75 7d		 jne	 SHORT $LN10@inflateSet

; 1352 :     state = (struct inflate_state FAR *)strm->state;

  00014	8b 7b 1c	 mov	 edi, DWORD PTR [ebx+28]

; 1353 :     if (state->wrap != 0 && state->mode != DICT)

  00017	39 47 0c	 cmp	 DWORD PTR [edi+12], eax
  0001a	74 09		 je	 SHORT $LN9@inflateSet
  0001c	81 7f 04 3e 3f
	00 00		 cmp	 DWORD PTR [edi+4], 16190 ; 00003f3eH
  00023	75 6c		 jne	 SHORT $LN10@inflateSet
$LN9@inflateSet:

; 1354 :         return Z_STREAM_ERROR;
; 1355 : 
; 1356 :     /* check for correct dictionary identifier */
; 1357 :     if (state->mode == DICT) {

  00025	81 7f 04 3e 3f
	00 00		 cmp	 DWORD PTR [edi+4], 16190 ; 00003f3eH
  0002c	75 28		 jne	 SHORT $LN5@inflateSet

; 1358 :         dictid = adler32(0L, Z_NULL, 0);

  0002e	6a 00		 push	 0
  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	e8 00 00 00 00	 call	 _adler32@12

; 1359 :         dictid = adler32(dictid, dictionary, dictLength);

  00039	ff 75 10	 push	 DWORD PTR _dictLength$[ebp]
  0003c	ff 75 0c	 push	 DWORD PTR _dictionary$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _adler32@12

; 1360 :         if (dictid != state->check)

  00045	3b 47 1c	 cmp	 eax, DWORD PTR [edi+28]
  00048	74 0c		 je	 SHORT $LN5@inflateSet

; 1374 : }

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00051	5b		 pop	 ebx
  00052	5d		 pop	 ebp
  00053	c2 0c 00	 ret	 12			; 0000000cH
$LN5@inflateSet:

; 1361 :             return Z_DATA_ERROR;
; 1362 :     }
; 1363 : 
; 1364 :     /* copy dictionary to window using updatewindow(), which will amend the
; 1365 :        existing dictionary if appropriate */
; 1366 :     ret = updatewindow(strm, dictionary + dictLength, dictLength);

  00056	8b 45 10	 mov	 eax, DWORD PTR _dictLength$[ebp]
  00059	8b cb		 mov	 ecx, ebx
  0005b	8b 55 0c	 mov	 edx, DWORD PTR _dictionary$[ebp]
  0005e	50		 push	 eax
  0005f	8d 14 02	 lea	 edx, DWORD PTR [edx+eax]
  00062	e8 00 00 00 00	 call	 _updatewindow
  00067	83 c4 04	 add	 esp, 4

; 1367 :     if (ret) {

  0006a	85 c0		 test	 eax, eax
  0006c	74 13		 je	 SHORT $LN6@inflateSet

; 1368 :         state->mode = MEM;

  0006e	c7 47 04 52 3f
	00 00		 mov	 DWORD PTR [edi+4], 16210 ; 00003f52H

; 1369 :         return Z_MEM_ERROR;

  00075	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0007a	5f		 pop	 edi

; 1374 : }

  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	5d		 pop	 ebp
  0007e	c2 0c 00	 ret	 12			; 0000000cH
$LN6@inflateSet:

; 1370 :     }
; 1371 :     state->havedict = 1;

  00081	c7 47 10 01 00
	00 00		 mov	 DWORD PTR [edi+16], 1

; 1372 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1373 :     return Z_OK;

  00088	33 c0		 xor	 eax, eax
  0008a	5f		 pop	 edi

; 1374 : }

  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx
  0008d	5d		 pop	 ebp
  0008e	c2 0c 00	 ret	 12			; 0000000cH
$LN10@inflateSet:
  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00098	5b		 pop	 ebx
  00099	5d		 pop	 ebp
  0009a	c2 0c 00	 ret	 12			; 0000000cH
_inflateSetDictionary@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateGetHeader@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_head$ = 12						; size = 4
_inflateGetHeader@8 PROC				; COMDAT

; 1379 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1380 :     struct inflate_state FAR *state;
; 1381 : 
; 1382 :     /* check state */
; 1383 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	75 1c		 jne	 SHORT $LN5@inflateGet

; 1384 :     state = (struct inflate_state FAR *)strm->state;

  0000f	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]

; 1385 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00012	f6 41 0c 02	 test	 BYTE PTR [ecx+12], 2
  00016	74 13		 je	 SHORT $LN5@inflateGet

; 1386 : 
; 1387 :     /* save header structure */
; 1388 :     state->head = head;

  00018	8b 45 0c	 mov	 eax, DWORD PTR _head$[ebp]
  0001b	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 1389 :     head->done = 0;

  0001e	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 1390 :     return Z_OK;

  00025	33 c0		 xor	 eax, eax

; 1391 : }

  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
$LN5@inflateGet:

; 1385 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  0002b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1391 : }

  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
_inflateGetHeader@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _syncsearch
_TEXT	SEGMENT
_buf$1$ = -8						; size = 4
_have$1$ = -4						; size = 4
_len$ = 8						; size = 4
_syncsearch PROC					; COMDAT
; _have$ = ecx
; _buf$ = edx

; 1408 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1409 :     unsigned got;
; 1410 :     unsigned next;
; 1411 : 
; 1412 :     got = *have;

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	56		 push	 esi
  00009	57		 push	 edi

; 1413 :     next = 0;
; 1414 :     while (next < len && got < 4) {

  0000a	8b 7d 08	 mov	 edi, DWORD PTR _len$[ebp]
  0000d	33 f6		 xor	 esi, esi
  0000f	89 55 f8	 mov	 DWORD PTR _buf$1$[ebp], edx
  00012	89 4d fc	 mov	 DWORD PTR _have$1$[ebp], ecx
  00015	85 ff		 test	 edi, edi
  00017	74 50		 je	 SHORT $LN13@syncsearch
  00019	53		 push	 ebx
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL2@syncsearch:
  00020	83 f8 04	 cmp	 eax, 4
  00023	73 36		 jae	 SHORT $LN14@syncsearch

; 1415 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  00025	8a 1c 16	 mov	 bl, BYTE PTR [esi+edx]
  00028	83 f8 02	 cmp	 eax, 2
  0002b	0f b6 cb	 movzx	 ecx, bl
  0002e	1b d2		 sbb	 edx, edx
  00030	81 e2 01 ff ff
	ff		 and	 edx, -255		; ffffff01H
  00036	81 c2 ff 00 00
	00		 add	 edx, 255		; 000000ffH
  0003c	3b ca		 cmp	 ecx, edx
  0003e	75 03		 jne	 SHORT $LN4@syncsearch

; 1416 :             got++;

  00040	40		 inc	 eax
  00041	eb 10		 jmp	 SHORT $LN7@syncsearch
$LN4@syncsearch:

; 1417 :         else if (buf[next])
; 1418 :             got = 0;
; 1419 :         else
; 1420 :             got = 4 - got;

  00043	b9 04 00 00 00	 mov	 ecx, 4
  00048	33 d2		 xor	 edx, edx
  0004a	2b c8		 sub	 ecx, eax
  0004c	84 db		 test	 bl, bl
  0004e	8b c1		 mov	 eax, ecx
  00050	0f 45 c2	 cmovne	 eax, edx
$LN7@syncsearch:

; 1421 :         next++;

  00053	8b 55 f8	 mov	 edx, DWORD PTR _buf$1$[ebp]
  00056	46		 inc	 esi
  00057	3b f7		 cmp	 esi, edi
  00059	72 c5		 jb	 SHORT $LL2@syncsearch
$LN14@syncsearch:

; 1422 :     }
; 1423 :     *have = got;

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _have$1$[ebp]
  0005e	5b		 pop	 ebx
  0005f	5f		 pop	 edi
  00060	89 01		 mov	 DWORD PTR [ecx], eax

; 1424 :     return next;

  00062	8b c6		 mov	 eax, esi

; 1425 : }

  00064	5e		 pop	 esi
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
$LN13@syncsearch:

; 1422 :     }
; 1423 :     *have = got;

  00069	89 01		 mov	 DWORD PTR [ecx], eax

; 1424 :     return next;

  0006b	8b c6		 mov	 eax, esi
  0006d	5f		 pop	 edi

; 1425 : }

  0006e	5e		 pop	 esi
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_syncsearch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateSync@4
_TEXT	SEGMENT
tv433 = -8						; size = 4
_state$1$ = -8						; size = 4
tv443 = -4						; size = 4
_buf$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateSync@4 PROC					; COMDAT

; 1429 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 1430 :     unsigned len;               /* number of bytes to look at or looked at */
; 1431 :     int flags;                  /* temporary to save header status */
; 1432 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1433 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1434 :     struct inflate_state FAR *state;
; 1435 : 
; 1436 :     /* check parameters */
; 1437 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00007	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  0000a	8b ce		 mov	 ecx, esi
  0000c	e8 00 00 00 00	 call	 _inflateStateCheck
  00011	85 c0		 test	 eax, eax
  00013	74 0c		 je	 SHORT $LN4@inflateSyn
  00015	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0001a	5e		 pop	 esi

; 1475 : }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
$LN4@inflateSyn:

; 1438 :     state = (struct inflate_state FAR *)strm->state;
; 1439 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  00021	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00025	53		 push	 ebx
  00026	8b 5e 1c	 mov	 ebx, DWORD PTR [esi+28]
  00029	57		 push	 edi
  0002a	89 5d f8	 mov	 DWORD PTR _state$1$[ebp], ebx
  0002d	8d 7b 40	 lea	 edi, DWORD PTR [ebx+64]
  00030	75 13		 jne	 SHORT $LN17@inflateSyn
  00032	83 3f 08	 cmp	 DWORD PTR [edi], 8
  00035	73 0e		 jae	 SHORT $LN17@inflateSyn
  00037	5f		 pop	 edi
  00038	5b		 pop	 ebx
  00039	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  0003e	5e		 pop	 esi

; 1475 : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN17@inflateSyn:

; 1440 : 
; 1441 :     /* if first time, start search in bit buffer */
; 1442 :     if (state->mode != SYNC) {

  00045	81 7b 04 53 3f
	00 00		 cmp	 DWORD PTR [ebx+4], 16211 ; 00003f53H
  0004c	74 59		 je	 SHORT $LN15@inflateSyn

; 1443 :         state->mode = SYNC;
; 1444 :         state->hold <<= state->bits & 7;

  0004e	8b 17		 mov	 edx, DWORD PTR [edi]
  00050	8b ca		 mov	 ecx, edx
  00052	8b 43 3c	 mov	 eax, DWORD PTR [ebx+60]
  00055	83 e1 07	 and	 ecx, 7
  00058	d3 e0		 shl	 eax, cl

; 1445 :         state->bits -= state->bits & 7;

  0005a	2b d1		 sub	 edx, ecx

; 1446 :         len = 0;

  0005c	33 c9		 xor	 ecx, ecx
  0005e	c7 43 04 53 3f
	00 00		 mov	 DWORD PTR [ebx+4], 16211 ; 00003f53H
  00065	89 45 fc	 mov	 DWORD PTR tv443[ebp], eax
  00068	89 43 3c	 mov	 DWORD PTR [ebx+60], eax
  0006b	89 17		 mov	 DWORD PTR [edi], edx

; 1447 :         while (state->bits >= 8) {

  0006d	83 fa 08	 cmp	 edx, 8
  00070	72 1c		 jb	 SHORT $LN3@inflateSyn
  00072	8b d8		 mov	 ebx, eax
$LL2@inflateSyn:

; 1448 :             buf[len++] = (unsigned char)(state->hold);

  00074	88 5c 0d fc	 mov	 BYTE PTR _buf$[ebp+ecx], bl

; 1449 :             state->hold >>= 8;
; 1450 :             state->bits -= 8;

  00078	83 ea 08	 sub	 edx, 8
  0007b	c1 e8 08	 shr	 eax, 8
  0007e	41		 inc	 ecx
  0007f	8a d8		 mov	 bl, al
  00081	83 fa 08	 cmp	 edx, 8
  00084	73 ee		 jae	 SHORT $LL2@inflateSyn
  00086	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
  00089	89 17		 mov	 DWORD PTR [edi], edx
  0008b	89 43 3c	 mov	 DWORD PTR [ebx+60], eax
$LN3@inflateSyn:

; 1451 :         }
; 1452 :         state->have = 0;

  0008e	8d 7b 6c	 lea	 edi, DWORD PTR [ebx+108]

; 1453 :         syncsearch(&(state->have), buf, len);

  00091	8d 55 fc	 lea	 edx, DWORD PTR _buf$[ebp]
  00094	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  0009a	51		 push	 ecx
  0009b	8b cf		 mov	 ecx, edi
  0009d	e8 00 00 00 00	 call	 _syncsearch
  000a2	83 c4 04	 add	 esp, 4
  000a5	eb 03		 jmp	 SHORT $LN6@inflateSyn
$LN15@inflateSyn:
  000a7	8d 7b 6c	 lea	 edi, DWORD PTR [ebx+108]
$LN6@inflateSyn:

; 1454 :     }
; 1455 : 
; 1456 :     /* search available input */
; 1457 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  000aa	ff 76 04	 push	 DWORD PTR [esi+4]
  000ad	8b 16		 mov	 edx, DWORD PTR [esi]
  000af	8b cf		 mov	 ecx, edi
  000b1	e8 00 00 00 00	 call	 _syncsearch

; 1458 :     strm->avail_in -= len;

  000b6	29 46 04	 sub	 DWORD PTR [esi+4], eax
  000b9	83 c4 04	 add	 esp, 4

; 1459 :     strm->next_in += len;

  000bc	01 06		 add	 DWORD PTR [esi], eax

; 1460 :     strm->total_in += len;

  000be	01 46 08	 add	 DWORD PTR [esi+8], eax

; 1461 : 
; 1462 :     /* return no joy or set up to restart inflate() on a new block */
; 1463 :     if (state->have != 4) return Z_DATA_ERROR;

  000c1	83 3f 04	 cmp	 DWORD PTR [edi], 4
  000c4	74 0e		 je	 SHORT $LN7@inflateSyn
  000c6	5f		 pop	 edi
  000c7	5b		 pop	 ebx
  000c8	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  000cd	5e		 pop	 esi

; 1475 : }

  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c2 04 00	 ret	 4
$LN7@inflateSyn:

; 1464 :     if (state->flags == -1)

  000d4	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  000d7	89 45 f8	 mov	 DWORD PTR tv433[ebp], eax
  000da	83 f8 ff	 cmp	 eax, -1
  000dd	75 09		 jne	 SHORT $LN8@inflateSyn

; 1465 :         state->wrap = 0;    /* if no header yet, treat as raw */

  000df	c7 43 0c 00 00
	00 00		 mov	 DWORD PTR [ebx+12], 0
  000e6	eb 04		 jmp	 SHORT $LN9@inflateSyn
$LN8@inflateSyn:

; 1466 :     else
; 1467 :         state->wrap &= ~4;  /* no point in computing a check value now */

  000e8	83 63 0c fb	 and	 DWORD PTR [ebx+12], -5	; fffffffbH
$LN9@inflateSyn:

; 1468 :     flags = state->flags;
; 1469 :     in = strm->total_in;  out = strm->total_out;

  000ec	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]

; 1470 :     inflateReset(strm);

  000ef	ff 75 08	 push	 DWORD PTR _strm$[ebp]
  000f2	8b 76 14	 mov	 esi, DWORD PTR [esi+20]
  000f5	e8 00 00 00 00	 call	 _inflateReset@4

; 1471 :     strm->total_in = in;  strm->total_out = out;

  000fa	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  000fd	89 78 08	 mov	 DWORD PTR [eax+8], edi
  00100	89 70 14	 mov	 DWORD PTR [eax+20], esi

; 1472 :     state->flags = flags;

  00103	8b 45 f8	 mov	 eax, DWORD PTR tv433[ebp]
  00106	5f		 pop	 edi
  00107	89 43 14	 mov	 DWORD PTR [ebx+20], eax

; 1473 :     state->mode = TYPE;
; 1474 :     return Z_OK;

  0010a	33 c0		 xor	 eax, eax
  0010c	c7 43 04 3f 3f
	00 00		 mov	 DWORD PTR [ebx+4], 16191 ; 00003f3fH
  00113	5b		 pop	 ebx
  00114	5e		 pop	 esi

; 1475 : }

  00115	8b e5		 mov	 esp, ebp
  00117	5d		 pop	 ebp
  00118	c2 04 00	 ret	 4
_inflateSync@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateSyncPoint@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateSyncPoint@4 PROC				; COMDAT

; 1487 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1488 :     struct inflate_state FAR *state;
; 1489 : 
; 1490 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateSyn
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1493 : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN2@inflateSyn:

; 1491 :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 1492 :     return state->mode == STORED && state->bits == 0;

  0001b	81 78 04 41 3f
	00 00		 cmp	 DWORD PTR [eax+4], 16193 ; 00003f41H
  00022	75 0f		 jne	 SHORT $LN4@inflateSyn
  00024	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00028	75 09		 jne	 SHORT $LN4@inflateSyn
  0002a	b8 01 00 00 00	 mov	 eax, 1

; 1493 : }

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
$LN4@inflateSyn:

; 1492 :     return state->mode == STORED && state->bits == 0;

  00033	33 c0		 xor	 eax, eax

; 1493 : }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
_inflateSyncPoint@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateCopy@8
_TEXT	SEGMENT
$T1 = -4						; size = 4
_dest$ = 8						; size = 4
_window$1$ = 12						; size = 4
_source$ = 12						; size = 4
_inflateCopy@8 PROC					; COMDAT

; 1498 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 1499 :     struct inflate_state FAR *state;
; 1500 :     struct inflate_state FAR *copy;
; 1501 :     unsigned char FAR *window;
; 1502 :     unsigned wsize;
; 1503 : 
; 1504 :     /* check input */
; 1505 :     if (inflateStateCheck(source) || dest == Z_NULL)

  00005	8b 7d 0c	 mov	 edi, DWORD PTR _source$[ebp]
  00008	8b cf		 mov	 ecx, edi
  0000a	e8 00 00 00 00	 call	 _inflateStateCheck
  0000f	85 c0		 test	 eax, eax
  00011	0f 85 3c 01 00
	00		 jne	 $LN3@inflateCop
  00017	39 45 08	 cmp	 DWORD PTR _dest$[ebp], eax
  0001a	0f 84 33 01 00
	00		 je	 $LN3@inflateCop

; 1507 :     state = (struct inflate_state FAR *)source->state;
; 1508 : 
; 1509 :     /* allocate space */
; 1510 :     copy = (struct inflate_state FAR *)

  00020	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00023	53		 push	 ebx
  00024	8b 5f 1c	 mov	 ebx, DWORD PTR [edi+28]
  00027	56		 push	 esi
  00028	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  0002d	6a 01		 push	 1
  0002f	ff 77 28	 push	 DWORD PTR [edi+40]
  00032	ff d0		 call	 eax
  00034	8b f0		 mov	 esi, eax
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1511 :            ZALLOC(source, 1, sizeof(struct inflate_state));
; 1512 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  00039	85 f6		 test	 esi, esi
  0003b	74 3d		 je	 SHORT $LN15@inflateCop

; 1513 :     window = Z_NULL;
; 1514 :     if (state->window != Z_NULL) {

  0003d	83 7b 38 00	 cmp	 DWORD PTR [ebx+56], 0
  00041	8d 4b 28	 lea	 ecx, DWORD PTR [ebx+40]
  00044	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _window$1$[ebp], 0
  0004b	89 4d fc	 mov	 DWORD PTR $T1[ebp], ecx
  0004e	74 38		 je	 SHORT $LN11@inflateCop

; 1515 :         window = (unsigned char FAR *)

  00050	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00052	b8 01 00 00 00	 mov	 eax, 1
  00057	d3 e0		 shl	 eax, cl
  00059	6a 01		 push	 1
  0005b	50		 push	 eax
  0005c	ff 77 28	 push	 DWORD PTR [edi+40]
  0005f	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00062	ff d0		 call	 eax
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH
  00067	89 45 0c	 mov	 DWORD PTR _window$1$[ebp], eax

; 1516 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
; 1517 :         if (window == Z_NULL) {

  0006a	85 c0		 test	 eax, eax
  0006c	75 1d		 jne	 SHORT $LN12@inflateCop

; 1518 :             ZFREE(source, copy);

  0006e	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  00071	56		 push	 esi
  00072	ff 77 28	 push	 DWORD PTR [edi+40]
  00075	ff d0		 call	 eax
  00077	83 c4 08	 add	 esp, 8
$LN15@inflateCop:

; 1519 :             return Z_MEM_ERROR;

  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00081	5f		 pop	 edi

; 1540 : }

  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 08 00	 ret	 8
$LN11@inflateCop:
  00088	89 4d fc	 mov	 DWORD PTR $T1[ebp], ecx
$LN12@inflateCop:

; 1520 :         }
; 1521 :     }
; 1522 : 
; 1523 :     /* copy state */
; 1524 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  0008b	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  0008e	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]

; 1525 :     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));

  00091	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  00096	53		 push	 ebx
  00097	56		 push	 esi
  00098	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  0009b	0f 10 47 10	 movups	 xmm0, XMMWORD PTR [edi+16]
  0009f	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0
  000a3	0f 10 47 20	 movups	 xmm0, XMMWORD PTR [edi+32]
  000a7	0f 11 40 20	 movups	 XMMWORD PTR [eax+32], xmm0
  000ab	f3 0f 7e 47 30	 movq	 xmm0, QWORD PTR [edi+48]
  000b0	66 0f d6 40 30	 movq	 QWORD PTR [eax+48], xmm0
  000b5	e8 00 00 00 00	 call	 _memcpy

; 1526 :     copy->strm = dest;

  000ba	8b 7d 08	 mov	 edi, DWORD PTR _dest$[ebp]

; 1527 :     if (state->lencode >= state->codes &&

  000bd	8d 83 34 05 00
	00		 lea	 eax, DWORD PTR [ebx+1332]
  000c3	89 3e		 mov	 DWORD PTR [esi], edi
  000c5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c8	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
  000cb	3b c8		 cmp	 ecx, eax
  000cd	72 38		 jb	 SHORT $LN7@inflateCop
  000cf	8d 83 c0 1b 00
	00		 lea	 eax, DWORD PTR [ebx+7104]
  000d5	3b c8		 cmp	 ecx, eax
  000d7	77 2e		 ja	 SHORT $LN7@inflateCop

; 1528 :         state->lencode <= state->codes + ENOUGH - 1) {
; 1529 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  000d9	2b cb		 sub	 ecx, ebx
  000db	8d 81 cc fa ff
	ff		 lea	 eax, DWORD PTR [ecx-1332]
  000e1	c1 f8 02	 sar	 eax, 2
  000e4	05 4d 01 00 00	 add	 eax, 333		; 0000014dH
  000e9	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  000ec	89 46 50	 mov	 DWORD PTR [esi+80], eax

; 1530 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  000ef	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  000f2	2b c3		 sub	 eax, ebx
  000f4	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  000f9	c1 f8 02	 sar	 eax, 2
  000fc	05 4d 01 00 00	 add	 eax, 333		; 0000014dH
  00101	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  00104	89 46 54	 mov	 DWORD PTR [esi+84], eax
$LN7@inflateCop:

; 1531 :     }
; 1532 :     copy->next = copy->codes + (state->next - state->codes);

  00107	8b 43 70	 mov	 eax, DWORD PTR [ebx+112]
  0010a	2b c3		 sub	 eax, ebx
  0010c	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  00111	c1 f8 02	 sar	 eax, 2
  00114	05 4d 01 00 00	 add	 eax, 333		; 0000014dH
  00119	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  0011c	89 46 70	 mov	 DWORD PTR [esi+112], eax

; 1533 :     if (window != Z_NULL) {

  0011f	8b 45 0c	 mov	 eax, DWORD PTR _window$1$[ebp]
  00122	85 c0		 test	 eax, eax
  00124	74 1c		 je	 SHORT $LN8@inflateCop

; 1534 :         wsize = 1U << state->wbits;

  00126	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00129	ba 01 00 00 00	 mov	 edx, 1
  0012e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00130	d3 e2		 shl	 edx, cl

; 1535 :         zmemcpy(window, state->window, wsize);

  00132	52		 push	 edx
  00133	ff 73 38	 push	 DWORD PTR [ebx+56]
  00136	50		 push	 eax
  00137	e8 00 00 00 00	 call	 _memcpy
  0013c	8b 45 0c	 mov	 eax, DWORD PTR _window$1$[ebp]
  0013f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@inflateCop:

; 1536 :     }
; 1537 :     copy->window = window;

  00142	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 1538 :     dest->state = (struct internal_state FAR *)copy;
; 1539 :     return Z_OK;

  00145	33 c0		 xor	 eax, eax
  00147	89 77 1c	 mov	 DWORD PTR [edi+28], esi
  0014a	5e		 pop	 esi
  0014b	5b		 pop	 ebx
  0014c	5f		 pop	 edi

; 1540 : }

  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c2 08 00	 ret	 8
$LN3@inflateCop:

; 1506 :         return Z_STREAM_ERROR;

  00153	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00158	5f		 pop	 edi

; 1540 : }

  00159	8b e5		 mov	 esp, ebp
  0015b	5d		 pop	 ebp
  0015c	c2 08 00	 ret	 8
_inflateCopy@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateUndermine@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_subvert$ = 12						; size = 4
_inflateUndermine@8 PROC				; COMDAT

; 1545 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1546 :     struct inflate_state FAR *state;
; 1547 : 
; 1548 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateUnd
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1557 : #endif
; 1558 : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
$LN2@inflateUnd:

; 1549 :     state = (struct inflate_state FAR *)strm->state;
; 1550 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1551 :     state->sane = !subvert;
; 1552 :     return Z_OK;
; 1553 : #else
; 1554 :     (void)subvert;
; 1555 :     state->sane = 1;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0001b	c7 80 c4 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+7108], 1

; 1556 :     return Z_DATA_ERROR;

  00025	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 1557 : #endif
; 1558 : }

  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
_inflateUndermine@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateValidate@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_check$ = 12						; size = 4
_inflateValidate@8 PROC					; COMDAT

; 1563 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1564 :     struct inflate_state FAR *state;
; 1565 : 
; 1566 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateVal
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1573 : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
$LN2@inflateVal:

; 1567 :     state = (struct inflate_state FAR *)strm->state;
; 1568 :     if (check && state->wrap)

  00018	83 7d 0c 00	 cmp	 DWORD PTR _check$[ebp], 0
  0001c	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0001f	74 13		 je	 SHORT $LN6@inflateVal
  00021	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00024	85 c9		 test	 ecx, ecx
  00026	74 0c		 je	 SHORT $LN6@inflateVal

; 1569 :         state->wrap |= 4;

  00028	83 c9 04	 or	 ecx, 4
  0002b	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 1572 :     return Z_OK;

  0002e	33 c0		 xor	 eax, eax

; 1573 : }

  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
$LN6@inflateVal:

; 1570 :     else
; 1571 :         state->wrap &= ~4;

  00034	83 60 0c fb	 and	 DWORD PTR [eax+12], -5	; fffffffbH

; 1572 :     return Z_OK;

  00038	33 c0		 xor	 eax, eax

; 1573 : }

  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
_inflateValidate@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateMark@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateMark@4 PROC					; COMDAT

; 1577 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1578 :     struct inflate_state FAR *state;
; 1579 : 
; 1580 :     if (inflateStateCheck(strm))

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateMar

; 1581 :         return -(1L << 16);

  0000f	b8 00 00 ff ff	 mov	 eax, -65536		; ffff0000H

; 1584 :         (state->mode == COPY ? state->length :
; 1585 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1586 : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN2@inflateMar:

; 1582 :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 1583 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	81 f9 43 3f 00
	00		 cmp	 ecx, 16195		; 00003f43H
  00024	75 12		 jne	 SHORT $LN6@inflateMar
  00026	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00029	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  0002f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00032	03 c1		 add	 eax, ecx

; 1584 :         (state->mode == COPY ? state->length :
; 1585 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1586 : }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN6@inflateMar:

; 1583 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  00038	81 f9 4c 3f 00
	00		 cmp	 ecx, 16204		; 00003f4cH
  0003e	75 18		 jne	 SHORT $LN4@inflateMar
  00040	8b 88 cc 1b 00
	00		 mov	 ecx, DWORD PTR [eax+7116]
  00046	2b 48 44	 sub	 ecx, DWORD PTR [eax+68]
  00049	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  0004f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00052	03 c1		 add	 eax, ecx

; 1584 :         (state->mode == COPY ? state->length :
; 1585 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1586 : }

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
$LN4@inflateMar:

; 1583 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  00058	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  0005e	33 c9		 xor	 ecx, ecx
  00060	c1 e0 10	 shl	 eax, 16			; 00000010H
  00063	03 c1		 add	 eax, ecx

; 1584 :         (state->mode == COPY ? state->length :
; 1585 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1586 : }

  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
_inflateMark@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\zlib\inflate.c
;	COMDAT _inflateCodesUsed@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateCodesUsed@4 PROC				; COMDAT

; 1590 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1591 :     struct inflate_state FAR *state;
; 1592 :     if (inflateStateCheck(strm)) return (unsigned long)-1;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 07		 je	 SHORT $LN2@inflateCod
  0000f	83 c8 ff	 or	 eax, -1

; 1595 : }

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
$LN2@inflateCod:

; 1593 :     state = (struct inflate_state FAR *)strm->state;

  00016	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]

; 1594 :     return (unsigned long)(state->next - state->codes);

  00019	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  0001c	2b c1		 sub	 eax, ecx
  0001e	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  00023	c1 f8 02	 sar	 eax, 2

; 1595 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
_inflateCodesUsed@4 ENDP
_TEXT	ENDS
END
