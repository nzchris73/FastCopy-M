; Listing generated by Microsoft (R) Optimizing Compiler Version 19.36.32537.0 

	TITLE	c:\users\chris\documents\github\fastcopy-m\external\zlib\contrib\vstudio\vc14\x86\zlibdllrelease\tmp\iowin32.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__CreateFileW@28:PROC
EXTRN	__imp__SetFilePointer@16:PROC
EXTRN	__imp__WriteFile@20:PROC
EXTRN	__imp__ReadFile@20:PROC
PUBLIC	_fill_win32_filefunc64W
PUBLIC	_fill_win32_filefunc64A
PUBLIC	_fill_win32_filefunc64
PUBLIC	_fill_win32_filefunc
PUBLIC	_win32_error_file_func
PUBLIC	_win32_close_file_func
PUBLIC	_win32_seek64_file_func
PUBLIC	_win32_seek_file_func
PUBLIC	_win32_tell64_file_func
PUBLIC	_win32_tell_file_func
PUBLIC	_win32_write_file_func
PUBLIC	_win32_read_file_func
PUBLIC	_win32_open_file_func
PUBLIC	_win32_open64_file_funcW
PUBLIC	_win32_open64_file_funcA
PUBLIC	_win32_open64_file_func
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\iowin32.c
;	COMDAT _win32_translate_open_mode
_TEXT	SEGMENT
_lpdwCreationDisposition$ = 8				; size = 4
_lpdwShareMode$ = 12					; size = 4
_lpdwFlagsAndAttributes$ = 16				; size = 4
_win32_translate_open_mode PROC				; COMDAT
; _mode$ = ecx
; _lpdwDesiredAccess$ = edx

; 52   :                                       DWORD* lpdwFlagsAndAttributes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 53   :     *lpdwDesiredAccess = *lpdwShareMode = *lpdwFlagsAndAttributes = *lpdwCreationDisposition = 0;

  00003	8b 45 10	 mov	 eax, DWORD PTR _lpdwFlagsAndAttributes$[ebp]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR _lpdwCreationDisposition$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR _lpdwShareMode$[ebp]
  0000e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 54   : 
; 55   :     if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)

  00014	8b c1		 mov	 eax, ecx
  00016	24 03		 and	 al, 3
  00018	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0001e	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00024	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  0002a	3c 01		 cmp	 al, 1
  0002c	75 16		 jne	 SHORT $LN2@win32_tran

; 56   :     {
; 57   :         *lpdwDesiredAccess = GENERIC_READ;
; 58   :         *lpdwCreationDisposition = OPEN_EXISTING;
; 59   :         *lpdwShareMode = FILE_SHARE_READ;

  0002e	c7 07 01 00 00
	00		 mov	 DWORD PTR [edi], 1
  00034	5f		 pop	 edi
  00035	c7 06 03 00 00
	00		 mov	 DWORD PTR [esi], 3
  0003b	c7 02 00 00 00
	80		 mov	 DWORD PTR [edx], -2147483648 ; 80000000H

; 70   :     }
; 71   : }

  00041	5e		 pop	 esi
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
$LN2@win32_tran:

; 60   :     }
; 61   :     else if (mode & ZLIB_FILEFUNC_MODE_EXISTING)

  00044	f6 c1 04	 test	 cl, 4
  00047	74 10		 je	 SHORT $LN4@win32_tran

; 62   :     {
; 63   :         *lpdwDesiredAccess = GENERIC_WRITE | GENERIC_READ;
; 64   :         *lpdwCreationDisposition = OPEN_EXISTING;

  00049	5f		 pop	 edi
  0004a	c7 06 03 00 00
	00		 mov	 DWORD PTR [esi], 3

; 70   :     }
; 71   : }

  00050	c7 02 00 00 00
	c0		 mov	 DWORD PTR [edx], -1073741824 ; c0000000H
  00056	5e		 pop	 esi
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN4@win32_tran:

; 65   :     }
; 66   :     else if (mode & ZLIB_FILEFUNC_MODE_CREATE)

  00059	f6 c1 08	 test	 cl, 8
  0005c	74 0c		 je	 SHORT $LN6@win32_tran

; 67   :     {
; 68   :         *lpdwDesiredAccess = GENERIC_WRITE | GENERIC_READ;
; 69   :         *lpdwCreationDisposition = CREATE_ALWAYS;

  0005e	c7 06 02 00 00
	00		 mov	 DWORD PTR [esi], 2

; 70   :     }
; 71   : }

  00064	c7 02 00 00 00
	c0		 mov	 DWORD PTR [edx], -1073741824 ; c0000000H
$LN6@win32_tran:
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
_win32_translate_open_mode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\iowin32.c
;	COMDAT _win32_build_iowin
_TEXT	SEGMENT
_win32_build_iowin PROC					; COMDAT
; _hFile$ = ecx

; 73   : static voidpf win32_build_iowin(HANDLE hFile) {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 74   :     voidpf ret=NULL;
; 75   : 
; 76   :     if ((hFile != NULL) && (hFile != INVALID_HANDLE_VALUE))

  00003	85 f6		 test	 esi, esi
  00005	74 2e		 je	 SHORT $LN7@win32_buil
  00007	83 fe ff	 cmp	 esi, -1
  0000a	74 29		 je	 SHORT $LN7@win32_buil

; 77   :     {
; 78   :         WIN32FILE_IOWIN w32fiow;
; 79   :         w32fiow.hf = hFile;
; 80   :         w32fiow.error = 0;
; 81   :         ret = malloc(sizeof(WIN32FILE_IOWIN));

  0000c	57		 push	 edi
  0000d	6a 08		 push	 8
  0000f	e8 00 00 00 00	 call	 _malloc
  00014	8b f8		 mov	 edi, eax
  00016	83 c4 04	 add	 esp, 4

; 82   : 
; 83   :         if (ret==NULL)

  00019	85 ff		 test	 edi, edi
  0001b	75 0c		 jne	 SHORT $LN3@win32_buil

; 84   :             CloseHandle(hFile);

  0001d	56		 push	 esi
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 87   :     }
; 88   :     return ret;

  00024	8b c7		 mov	 eax, edi
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi

; 89   : }

  00028	c3		 ret	 0
$LN3@win32_buil:

; 85   :         else
; 86   :             *((WIN32FILE_IOWIN*)ret) = w32fiow;

  00029	89 37		 mov	 DWORD PTR [edi], esi
  0002b	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi

; 89   : }

  00034	c3		 ret	 0
$LN7@win32_buil:
  00035	33 c0		 xor	 eax, eax
  00037	5e		 pop	 esi
  00038	c3		 ret	 0
_win32_build_iowin ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\iowin32.c
;	COMDAT _win32_open64_file_func
_TEXT	SEGMENT
_dwShareMode$ = -16					; size = 4
_dwCreationDisposition$ = -12				; size = 4
_dwFlagsAndAttributes$ = -8				; size = 4
_dwDesiredAccess$ = -4					; size = 4
_opaque$ = 8						; size = 4
_filename$ = 12						; size = 4
_mode$ = 16						; size = 4
_win32_open64_file_func PROC				; COMDAT

; 91   : voidpf ZCALLBACK win32_open64_file_func(voidpf opaque, const void* filename, int mode) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 92   :     const char* mode_fopen = NULL;
; 93   :     DWORD dwDesiredAccess,dwCreationDisposition,dwShareMode,dwFlagsAndAttributes ;
; 94   :     HANDLE hFile = NULL;
; 95   : 
; 96   :     win32_translate_open_mode(mode,&dwDesiredAccess,&dwCreationDisposition,&dwShareMode,&dwFlagsAndAttributes);

  00003	8b 4d 10	 mov	 ecx, DWORD PTR _mode$[ebp]
  00006	8d 45 f8	 lea	 eax, DWORD PTR _dwFlagsAndAttributes$[ebp]
  00009	83 ec 10	 sub	 esp, 16			; 00000010H
  0000c	8d 55 fc	 lea	 edx, DWORD PTR _dwDesiredAccess$[ebp]
  0000f	56		 push	 esi
  00010	50		 push	 eax
  00011	8d 45 f0	 lea	 eax, DWORD PTR _dwShareMode$[ebp]
  00014	33 f6		 xor	 esi, esi
  00016	50		 push	 eax
  00017	8d 45 f4	 lea	 eax, DWORD PTR _dwCreationDisposition$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _win32_translate_open_mode

; 97   : 
; 98   : #ifdef IOWIN32_USING_WINRT_API
; 99   : #ifdef UNICODE
; 100  :     if ((filename!=NULL) && (dwDesiredAccess != 0))
; 101  :         hFile = CreateFile2((LPCTSTR)filename, dwDesiredAccess, dwShareMode, dwCreationDisposition, NULL);
; 102  : #else
; 103  :     if ((filename!=NULL) && (dwDesiredAccess != 0))
; 104  :     {
; 105  :         WCHAR filenameW[FILENAME_MAX + 0x200 + 1];
; 106  :         MultiByteToWideChar(CP_ACP,0,(const char*)filename,-1,filenameW,FILENAME_MAX + 0x200);
; 107  :         hFile = CreateFile2(filenameW, dwDesiredAccess, dwShareMode, dwCreationDisposition, NULL);
; 108  :     }
; 109  : #endif
; 110  : #else
; 111  :     if ((filename!=NULL) && (dwDesiredAccess != 0))

  00020	8b 4d 0c	 mov	 ecx, DWORD PTR _filename$[ebp]
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	85 c9		 test	 ecx, ecx
  00028	74 1c		 je	 SHORT $LN2@win32_open
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _dwDesiredAccess$[ebp]
  0002d	85 c0		 test	 eax, eax
  0002f	74 15		 je	 SHORT $LN2@win32_open

; 112  :         hFile = CreateFile((LPCTSTR)filename, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);

  00031	56		 push	 esi
  00032	ff 75 f8	 push	 DWORD PTR _dwFlagsAndAttributes$[ebp]
  00035	ff 75 f4	 push	 DWORD PTR _dwCreationDisposition$[ebp]
  00038	56		 push	 esi
  00039	ff 75 f0	 push	 DWORD PTR _dwShareMode$[ebp]
  0003c	50		 push	 eax
  0003d	51		 push	 ecx
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00044	8b f0		 mov	 esi, eax
$LN2@win32_open:

; 113  : #endif
; 114  : 
; 115  :     return win32_build_iowin(hFile);

  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 _win32_build_iowin
  0004d	5e		 pop	 esi

; 116  : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
_win32_open64_file_func ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\iowin32.c
;	COMDAT _win32_open64_file_funcA
_TEXT	SEGMENT
_dwShareMode$ = -16					; size = 4
_dwCreationDisposition$ = -12				; size = 4
_dwFlagsAndAttributes$ = -8				; size = 4
_dwDesiredAccess$ = -4					; size = 4
_opaque$ = 8						; size = 4
_filename$ = 12						; size = 4
_mode$ = 16						; size = 4
_win32_open64_file_funcA PROC				; COMDAT

; 119  : voidpf ZCALLBACK win32_open64_file_funcA(voidpf opaque, const void* filename, int mode) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 120  :     const char* mode_fopen = NULL;
; 121  :     DWORD dwDesiredAccess,dwCreationDisposition,dwShareMode,dwFlagsAndAttributes ;
; 122  :     HANDLE hFile = NULL;
; 123  : 
; 124  :     win32_translate_open_mode(mode,&dwDesiredAccess,&dwCreationDisposition,&dwShareMode,&dwFlagsAndAttributes);

  00003	8b 4d 10	 mov	 ecx, DWORD PTR _mode$[ebp]
  00006	8d 45 f8	 lea	 eax, DWORD PTR _dwFlagsAndAttributes$[ebp]
  00009	83 ec 10	 sub	 esp, 16			; 00000010H
  0000c	8d 55 fc	 lea	 edx, DWORD PTR _dwDesiredAccess$[ebp]
  0000f	56		 push	 esi
  00010	50		 push	 eax
  00011	8d 45 f0	 lea	 eax, DWORD PTR _dwShareMode$[ebp]
  00014	33 f6		 xor	 esi, esi
  00016	50		 push	 eax
  00017	8d 45 f4	 lea	 eax, DWORD PTR _dwCreationDisposition$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _win32_translate_open_mode

; 125  : 
; 126  : #ifdef IOWIN32_USING_WINRT_API
; 127  :     if ((filename!=NULL) && (dwDesiredAccess != 0))
; 128  :     {
; 129  :         WCHAR filenameW[FILENAME_MAX + 0x200 + 1];
; 130  :         MultiByteToWideChar(CP_ACP,0,(const char*)filename,-1,filenameW,FILENAME_MAX + 0x200);
; 131  :         hFile = CreateFile2(filenameW, dwDesiredAccess, dwShareMode, dwCreationDisposition, NULL);
; 132  :     }
; 133  : #else
; 134  :     if ((filename!=NULL) && (dwDesiredAccess != 0))

  00020	8b 4d 0c	 mov	 ecx, DWORD PTR _filename$[ebp]
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	85 c9		 test	 ecx, ecx
  00028	74 1c		 je	 SHORT $LN2@win32_open
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _dwDesiredAccess$[ebp]
  0002d	85 c0		 test	 eax, eax
  0002f	74 15		 je	 SHORT $LN2@win32_open

; 135  :         hFile = CreateFileA((LPCSTR)filename, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);

  00031	56		 push	 esi
  00032	ff 75 f8	 push	 DWORD PTR _dwFlagsAndAttributes$[ebp]
  00035	ff 75 f4	 push	 DWORD PTR _dwCreationDisposition$[ebp]
  00038	56		 push	 esi
  00039	ff 75 f0	 push	 DWORD PTR _dwShareMode$[ebp]
  0003c	50		 push	 eax
  0003d	51		 push	 ecx
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00044	8b f0		 mov	 esi, eax
$LN2@win32_open:

; 136  : #endif
; 137  : 
; 138  :     return win32_build_iowin(hFile);

  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 _win32_build_iowin
  0004d	5e		 pop	 esi

; 139  : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
_win32_open64_file_funcA ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\iowin32.c
;	COMDAT _win32_open64_file_funcW
_TEXT	SEGMENT
_dwShareMode$ = -16					; size = 4
_dwCreationDisposition$ = -12				; size = 4
_dwFlagsAndAttributes$ = -8				; size = 4
_dwDesiredAccess$ = -4					; size = 4
_opaque$ = 8						; size = 4
_filename$ = 12						; size = 4
_mode$ = 16						; size = 4
_win32_open64_file_funcW PROC				; COMDAT

; 142  : voidpf ZCALLBACK win32_open64_file_funcW(voidpf opaque, const void* filename, int mode) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 143  :     const char* mode_fopen = NULL;
; 144  :     DWORD dwDesiredAccess,dwCreationDisposition,dwShareMode,dwFlagsAndAttributes ;
; 145  :     HANDLE hFile = NULL;
; 146  : 
; 147  :     win32_translate_open_mode(mode,&dwDesiredAccess,&dwCreationDisposition,&dwShareMode,&dwFlagsAndAttributes);

  00003	8b 4d 10	 mov	 ecx, DWORD PTR _mode$[ebp]
  00006	8d 45 f8	 lea	 eax, DWORD PTR _dwFlagsAndAttributes$[ebp]
  00009	83 ec 10	 sub	 esp, 16			; 00000010H
  0000c	8d 55 fc	 lea	 edx, DWORD PTR _dwDesiredAccess$[ebp]
  0000f	56		 push	 esi
  00010	50		 push	 eax
  00011	8d 45 f0	 lea	 eax, DWORD PTR _dwShareMode$[ebp]
  00014	33 f6		 xor	 esi, esi
  00016	50		 push	 eax
  00017	8d 45 f4	 lea	 eax, DWORD PTR _dwCreationDisposition$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _win32_translate_open_mode

; 148  : 
; 149  : #ifdef IOWIN32_USING_WINRT_API
; 150  :     if ((filename!=NULL) && (dwDesiredAccess != 0))
; 151  :         hFile = CreateFile2((LPCWSTR)filename, dwDesiredAccess, dwShareMode, dwCreationDisposition,NULL);
; 152  : #else
; 153  :     if ((filename!=NULL) && (dwDesiredAccess != 0))

  00020	8b 4d 0c	 mov	 ecx, DWORD PTR _filename$[ebp]
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	85 c9		 test	 ecx, ecx
  00028	74 1c		 je	 SHORT $LN2@win32_open
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _dwDesiredAccess$[ebp]
  0002d	85 c0		 test	 eax, eax
  0002f	74 15		 je	 SHORT $LN2@win32_open

; 154  :         hFile = CreateFileW((LPCWSTR)filename, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);

  00031	56		 push	 esi
  00032	ff 75 f8	 push	 DWORD PTR _dwFlagsAndAttributes$[ebp]
  00035	ff 75 f4	 push	 DWORD PTR _dwCreationDisposition$[ebp]
  00038	56		 push	 esi
  00039	ff 75 f0	 push	 DWORD PTR _dwShareMode$[ebp]
  0003c	50		 push	 eax
  0003d	51		 push	 ecx
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileW@28
  00044	8b f0		 mov	 esi, eax
$LN2@win32_open:

; 155  : #endif
; 156  : 
; 157  :     return win32_build_iowin(hFile);

  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 _win32_build_iowin
  0004d	5e		 pop	 esi

; 158  : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
_win32_open64_file_funcW ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\iowin32.c
;	COMDAT _win32_open_file_func
_TEXT	SEGMENT
_dwShareMode$ = -16					; size = 4
_dwCreationDisposition$ = -12				; size = 4
_dwFlagsAndAttributes$ = -8				; size = 4
_dwDesiredAccess$ = -4					; size = 4
_opaque$ = 8						; size = 4
_filename$ = 12						; size = 4
_mode$ = 16						; size = 4
_win32_open_file_func PROC				; COMDAT

; 161  : voidpf ZCALLBACK win32_open_file_func(voidpf opaque, const char* filename, int mode) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 162  :     const char* mode_fopen = NULL;
; 163  :     DWORD dwDesiredAccess,dwCreationDisposition,dwShareMode,dwFlagsAndAttributes ;
; 164  :     HANDLE hFile = NULL;
; 165  : 
; 166  :     win32_translate_open_mode(mode,&dwDesiredAccess,&dwCreationDisposition,&dwShareMode,&dwFlagsAndAttributes);

  00003	8b 4d 10	 mov	 ecx, DWORD PTR _mode$[ebp]
  00006	8d 45 f8	 lea	 eax, DWORD PTR _dwFlagsAndAttributes$[ebp]
  00009	83 ec 10	 sub	 esp, 16			; 00000010H
  0000c	8d 55 fc	 lea	 edx, DWORD PTR _dwDesiredAccess$[ebp]
  0000f	56		 push	 esi
  00010	50		 push	 eax
  00011	8d 45 f0	 lea	 eax, DWORD PTR _dwShareMode$[ebp]
  00014	33 f6		 xor	 esi, esi
  00016	50		 push	 eax
  00017	8d 45 f4	 lea	 eax, DWORD PTR _dwCreationDisposition$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _win32_translate_open_mode

; 167  : 
; 168  : #ifdef IOWIN32_USING_WINRT_API
; 169  : #ifdef UNICODE
; 170  :     if ((filename!=NULL) && (dwDesiredAccess != 0))
; 171  :         hFile = CreateFile2((LPCTSTR)filename, dwDesiredAccess, dwShareMode, dwCreationDisposition, NULL);
; 172  : #else
; 173  :     if ((filename!=NULL) && (dwDesiredAccess != 0))
; 174  :     {
; 175  :         WCHAR filenameW[FILENAME_MAX + 0x200 + 1];
; 176  :         MultiByteToWideChar(CP_ACP,0,(const char*)filename,-1,filenameW,FILENAME_MAX + 0x200);
; 177  :         hFile = CreateFile2(filenameW, dwDesiredAccess, dwShareMode, dwCreationDisposition, NULL);
; 178  :     }
; 179  : #endif
; 180  : #else
; 181  :     if ((filename!=NULL) && (dwDesiredAccess != 0))

  00020	8b 4d 0c	 mov	 ecx, DWORD PTR _filename$[ebp]
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	85 c9		 test	 ecx, ecx
  00028	74 1c		 je	 SHORT $LN2@win32_open
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _dwDesiredAccess$[ebp]
  0002d	85 c0		 test	 eax, eax
  0002f	74 15		 je	 SHORT $LN2@win32_open

; 182  :         hFile = CreateFile((LPCTSTR)filename, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);

  00031	56		 push	 esi
  00032	ff 75 f8	 push	 DWORD PTR _dwFlagsAndAttributes$[ebp]
  00035	ff 75 f4	 push	 DWORD PTR _dwCreationDisposition$[ebp]
  00038	56		 push	 esi
  00039	ff 75 f0	 push	 DWORD PTR _dwShareMode$[ebp]
  0003c	50		 push	 eax
  0003d	51		 push	 ecx
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00044	8b f0		 mov	 esi, eax
$LN2@win32_open:

; 183  : #endif
; 184  : 
; 185  :     return win32_build_iowin(hFile);

  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 _win32_build_iowin
  0004d	5e		 pop	 esi

; 186  : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
_win32_open_file_func ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\iowin32.c
;	COMDAT _win32_read_file_func
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_opaque$ = 8						; size = 4
_stream$ = 12						; size = 4
_buf$ = 16						; size = 4
_size$ = 20						; size = 4
_win32_read_file_func PROC				; COMDAT

; 189  : uLong ZCALLBACK win32_read_file_func(voidpf opaque, voidpf stream, void* buf,uLong size) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 190  :     uLong ret=0;
; 191  :     HANDLE hFile = NULL;
; 192  :     if (stream!=NULL)

  00005	8b 75 0c	 mov	 esi, DWORD PTR _stream$[ebp]
  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0
  0000f	85 f6		 test	 esi, esi
  00011	74 36		 je	 SHORT $LN9@win32_read

; 193  :         hFile = ((WIN32FILE_IOWIN*)stream) -> hf;

  00013	8b 06		 mov	 eax, DWORD PTR [esi]

; 194  : 
; 195  :     if (hFile != NULL)

  00015	85 c0		 test	 eax, eax
  00017	74 30		 je	 SHORT $LN9@win32_read

; 196  :     {
; 197  :         if (!ReadFile(hFile, buf, size, &ret, NULL))

  00019	6a 00		 push	 0
  0001b	8d 4d fc	 lea	 ecx, DWORD PTR _ret$[ebp]
  0001e	51		 push	 ecx
  0001f	ff 75 14	 push	 DWORD PTR _size$[ebp]
  00022	ff 75 10	 push	 DWORD PTR _buf$[ebp]
  00025	50		 push	 eax
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  0002c	85 c0		 test	 eax, eax
  0002e	75 11		 jne	 SHORT $LN7@win32_read

; 198  :         {
; 199  :             DWORD dwErr = GetLastError();

  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 200  :             if (dwErr == ERROR_HANDLE_EOF)

  00036	33 c9		 xor	 ecx, ecx
  00038	83 f8 26	 cmp	 eax, 38			; 00000026H
  0003b	0f 44 c1	 cmove	 eax, ecx

; 201  :                 dwErr = 0;
; 202  :             ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;

  0003e	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN7@win32_read:

; 203  :         }
; 204  :     }
; 205  : 
; 206  :     return ret;
; 207  : }

  00041	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]
  00044	5e		 pop	 esi
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
$LN9@win32_read:
  00049	33 c0		 xor	 eax, eax
  0004b	5e		 pop	 esi
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_win32_read_file_func ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\iowin32.c
;	COMDAT _win32_write_file_func
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_opaque$ = 8						; size = 4
_stream$ = 12						; size = 4
_buf$ = 16						; size = 4
_size$ = 20						; size = 4
_win32_write_file_func PROC				; COMDAT

; 210  : uLong ZCALLBACK win32_write_file_func(voidpf opaque, voidpf stream, const void* buf, uLong size) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 211  :     uLong ret=0;
; 212  :     HANDLE hFile = NULL;
; 213  :     if (stream!=NULL)

  00005	8b 75 0c	 mov	 esi, DWORD PTR _stream$[ebp]
  00008	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0
  0000f	85 f6		 test	 esi, esi
  00011	74 36		 je	 SHORT $LN9@win32_writ

; 214  :         hFile = ((WIN32FILE_IOWIN*)stream) -> hf;

  00013	8b 06		 mov	 eax, DWORD PTR [esi]

; 215  : 
; 216  :     if (hFile != NULL)

  00015	85 c0		 test	 eax, eax
  00017	74 30		 je	 SHORT $LN9@win32_writ

; 217  :     {
; 218  :         if (!WriteFile(hFile, buf, size, &ret, NULL))

  00019	6a 00		 push	 0
  0001b	8d 4d fc	 lea	 ecx, DWORD PTR _ret$[ebp]
  0001e	51		 push	 ecx
  0001f	ff 75 14	 push	 DWORD PTR _size$[ebp]
  00022	ff 75 10	 push	 DWORD PTR _buf$[ebp]
  00025	50		 push	 eax
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  0002c	85 c0		 test	 eax, eax
  0002e	75 11		 jne	 SHORT $LN7@win32_writ

; 219  :         {
; 220  :             DWORD dwErr = GetLastError();

  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 221  :             if (dwErr == ERROR_HANDLE_EOF)

  00036	33 c9		 xor	 ecx, ecx
  00038	83 f8 26	 cmp	 eax, 38			; 00000026H
  0003b	0f 44 c1	 cmove	 eax, ecx

; 222  :                 dwErr = 0;
; 223  :             ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;

  0003e	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN7@win32_writ:

; 224  :         }
; 225  :     }
; 226  : 
; 227  :     return ret;
; 228  : }

  00041	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]
  00044	5e		 pop	 esi
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
$LN9@win32_writ:
  00049	33 c0		 xor	 eax, eax
  0004b	5e		 pop	 esi
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_win32_write_file_func ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\iowin32.c
;	COMDAT _MySetFilePointerEx
_TEXT	SEGMENT
_lHigh$ = -4						; size = 4
_pos$ = 8						; size = 8
_dwMoveMethod$ = 16					; size = 4
_MySetFilePointerEx PROC				; COMDAT
; _hFile$ = ecx
; _newPos$ = edx

; 230  : static BOOL MySetFilePointerEx(HANDLE hFile, LARGE_INTEGER pos, LARGE_INTEGER *newPos, DWORD dwMoveMethod) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 231  : #ifdef IOWIN32_USING_WINRT_API
; 232  :     return SetFilePointerEx(hFile, pos, newPos, dwMoveMethod);
; 233  : #else
; 234  :     LONG lHigh = pos.HighPart;

  00004	8b 45 0c	 mov	 eax, DWORD PTR _pos$[ebp+4]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi

; 235  :     DWORD dwNewPos = SetFilePointer(hFile, pos.LowPart, &lHigh, dwMoveMethod);

  0000a	ff 75 10	 push	 DWORD PTR _dwMoveMethod$[ebp]
  0000d	89 45 fc	 mov	 DWORD PTR _lHigh$[ebp], eax
  00010	8b fa		 mov	 edi, edx
  00012	8d 45 fc	 lea	 eax, DWORD PTR _lHigh$[ebp]
  00015	50		 push	 eax
  00016	ff 75 08	 push	 DWORD PTR _pos$[ebp]
  00019	51		 push	 ecx
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointer@16
  00020	8b d8		 mov	 ebx, eax

; 236  :     BOOL fOk = TRUE;

  00022	be 01 00 00 00	 mov	 esi, 1

; 237  :     if (dwNewPos == 0xFFFFFFFF)

  00027	83 fb ff	 cmp	 ebx, -1
  0002a	75 0d		 jne	 SHORT $LN3@MySetFileP

; 238  :         if (GetLastError() != NO_ERROR)

  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00032	33 c9		 xor	 ecx, ecx
  00034	85 c0		 test	 eax, eax
  00036	0f 45 f1	 cmovne	 esi, ecx
$LN3@MySetFileP:

; 239  :             fOk = FALSE;
; 240  :     if ((newPos != NULL) && (fOk))

  00039	8b c6		 mov	 eax, esi
  0003b	85 ff		 test	 edi, edi
  0003d	74 0c		 je	 SHORT $LN4@MySetFileP
  0003f	85 f6		 test	 esi, esi
  00041	74 08		 je	 SHORT $LN4@MySetFileP

; 241  :     {
; 242  :         newPos->LowPart = dwNewPos;
; 243  :         newPos->HighPart = lHigh;

  00043	8b 4d fc	 mov	 ecx, DWORD PTR _lHigh$[ebp]
  00046	89 1f		 mov	 DWORD PTR [edi], ebx
  00048	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
$LN4@MySetFileP:

; 244  :     }
; 245  :     return fOk;
; 246  : #endif
; 247  : }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
_MySetFilePointerEx ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\iowin32.c
;	COMDAT _win32_tell_file_func
_TEXT	SEGMENT
_pos$1 = -8						; size = 8
_opaque$ = 8						; size = 4
_stream$ = 12						; size = 4
_win32_tell_file_func PROC				; COMDAT

; 249  : long ZCALLBACK win32_tell_file_func(voidpf opaque, voidpf stream) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 250  :     long ret=-1;
; 251  :     HANDLE hFile = NULL;
; 252  :     if (stream!=NULL)

  00007	8b 75 0c	 mov	 esi, DWORD PTR _stream$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	74 2e		 je	 SHORT $LN8@win32_tell

; 253  :         hFile = ((WIN32FILE_IOWIN*)stream) -> hf;

  0000e	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 254  :     if (hFile != NULL)

  00010	85 c9		 test	 ecx, ecx
  00012	74 28		 je	 SHORT $LN8@win32_tell

; 255  :     {
; 256  :         LARGE_INTEGER pos;
; 257  :         pos.QuadPart = 0;
; 258  : 
; 259  :         if (!MySetFilePointerEx(hFile, pos, &pos, FILE_CURRENT))

  00014	0f 57 c0	 xorps	 xmm0, xmm0
  00017	8d 55 f8	 lea	 edx, DWORD PTR _pos$1[ebp]
  0001a	66 0f 13 45 f8	 movlpd	 QWORD PTR _pos$1[ebp], xmm0
  0001f	6a 01		 push	 1
  00021	ff 75 fc	 push	 DWORD PTR _pos$1[ebp+4]
  00024	ff 75 f8	 push	 DWORD PTR _pos$1[ebp]
  00027	e8 00 00 00 00	 call	 _MySetFilePointerEx
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	85 c0		 test	 eax, eax
  00031	75 11		 jne	 SHORT $LN4@win32_tell

; 260  :         {
; 261  :             DWORD dwErr = GetLastError();

  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 262  :             ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;

  00039	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN8@win32_tell:

; 269  : }

  0003c	83 c8 ff	 or	 eax, -1
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
$LN4@win32_tell:

; 263  :             ret = -1;
; 264  :         }
; 265  :         else
; 266  :             ret=(long)pos.LowPart;
; 267  :     }
; 268  :     return ret;

  00044	8b 45 f8	 mov	 eax, DWORD PTR _pos$1[ebp]
  00047	5e		 pop	 esi

; 269  : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_win32_tell_file_func ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\iowin32.c
;	COMDAT _win32_tell64_file_func
_TEXT	SEGMENT
_pos$1 = -8						; size = 8
_opaque$ = 8						; size = 4
_stream$ = 12						; size = 4
_win32_tell64_file_func PROC				; COMDAT

; 271  : ZPOS64_T ZCALLBACK win32_tell64_file_func(voidpf opaque, voidpf stream) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	56		 push	 esi

; 272  :     ZPOS64_T ret= (ZPOS64_T)-1;
; 273  :     HANDLE hFile = NULL;
; 274  :     if (stream!=NULL)

  0000a	8b 75 0c	 mov	 esi, DWORD PTR _stream$[ebp]
  0000d	85 f6		 test	 esi, esi
  0000f	74 32		 je	 SHORT $LN8@win32_tell

; 275  :         hFile = ((WIN32FILE_IOWIN*)stream)->hf;

  00011	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 276  : 
; 277  :     if (hFile)

  00013	85 c9		 test	 ecx, ecx
  00015	74 2c		 je	 SHORT $LN8@win32_tell

; 278  :     {
; 279  :         LARGE_INTEGER pos;
; 280  :         pos.QuadPart = 0;
; 281  : 
; 282  :         if (!MySetFilePointerEx(hFile, pos, &pos, FILE_CURRENT))

  00017	0f 57 c0	 xorps	 xmm0, xmm0
  0001a	8d 54 24 08	 lea	 edx, DWORD PTR _pos$1[esp+16]
  0001e	66 0f 13 44 24
	08		 movlpd	 QWORD PTR _pos$1[esp+16], xmm0
  00024	6a 01		 push	 1
  00026	ff 74 24 10	 push	 DWORD PTR _pos$1[esp+24]
  0002a	ff 74 24 10	 push	 DWORD PTR _pos$1[esp+24]
  0002e	e8 00 00 00 00	 call	 _MySetFilePointerEx
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	85 c0		 test	 eax, eax
  00038	75 14		 jne	 SHORT $LN4@win32_tell

; 283  :         {
; 284  :             DWORD dwErr = GetLastError();

  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 285  :             ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;

  00040	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN8@win32_tell:

; 292  : }

  00043	83 c8 ff	 or	 eax, -1
  00046	83 ca ff	 or	 edx, -1
  00049	5e		 pop	 esi
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
$LN4@win32_tell:

; 286  :             ret = (ZPOS64_T)-1;
; 287  :         }
; 288  :         else
; 289  :             ret=pos.QuadPart;
; 290  :     }
; 291  :     return ret;

  0004e	8b 44 24 08	 mov	 eax, DWORD PTR _pos$1[esp+16]
  00052	8b 54 24 0c	 mov	 edx, DWORD PTR _pos$1[esp+20]

; 292  : }

  00056	5e		 pop	 esi
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_win32_tell64_file_func ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\iowin32.c
;	COMDAT _win32_seek_file_func
_TEXT	SEGMENT
_opaque$ = 8						; size = 4
_stream$ = 12						; size = 4
_offset$ = 16						; size = 4
_origin$ = 20						; size = 4
_win32_seek_file_func PROC				; COMDAT

; 295  : long ZCALLBACK win32_seek_file_func(voidpf opaque, voidpf stream, uLong offset, int origin) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 296  :     DWORD dwMoveMethod=0xFFFFFFFF;
; 297  :     HANDLE hFile = NULL;
; 298  : 
; 299  :     long ret=-1;
; 300  :     if (stream!=NULL)

  00004	8b 75 0c	 mov	 esi, DWORD PTR _stream$[ebp]
  00007	83 c9 ff	 or	 ecx, -1
  0000a	57		 push	 edi
  0000b	33 ff		 xor	 edi, edi
  0000d	85 f6		 test	 esi, esi
  0000f	74 02		 je	 SHORT $LN4@win32_seek

; 301  :         hFile = ((WIN32FILE_IOWIN*)stream) -> hf;

  00011	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN4@win32_seek:

; 302  :     switch (origin)

  00013	8b 45 14	 mov	 eax, DWORD PTR _origin$[ebp]
  00016	83 e8 00	 sub	 eax, 0
  00019	74 1f		 je	 SHORT $LN7@win32_seek
  0001b	83 e8 01	 sub	 eax, 1
  0001e	74 13		 je	 SHORT $LN5@win32_seek
  00020	83 e8 01	 sub	 eax, 1
  00023	74 07		 je	 SHORT $LN6@win32_seek

; 312  :         break;
; 313  :     default: return -1;

  00025	5f		 pop	 edi
  00026	83 c8 ff	 or	 eax, -1

; 330  : }

  00029	5e		 pop	 esi
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN6@win32_seek:

; 307  :     case ZLIB_FILEFUNC_SEEK_END :
; 308  :         dwMoveMethod = FILE_END;

  0002c	b8 02 00 00 00	 mov	 eax, 2

; 309  :         break;

  00031	eb 09		 jmp	 SHORT $LN2@win32_seek
$LN5@win32_seek:

; 303  :     {
; 304  :     case ZLIB_FILEFUNC_SEEK_CUR :
; 305  :         dwMoveMethod = FILE_CURRENT;

  00033	b8 01 00 00 00	 mov	 eax, 1

; 306  :         break;

  00038	eb 02		 jmp	 SHORT $LN2@win32_seek
$LN7@win32_seek:

; 310  :     case ZLIB_FILEFUNC_SEEK_SET :
; 311  :         dwMoveMethod = FILE_BEGIN;

  0003a	33 c0		 xor	 eax, eax
$LN2@win32_seek:

; 314  :     }
; 315  : 
; 316  :     if (hFile != NULL)

  0003c	85 ff		 test	 edi, edi
  0003e	74 2a		 je	 SHORT $LN11@win32_seek

; 317  :     {
; 318  :         LARGE_INTEGER pos;
; 319  :         pos.QuadPart = offset;
; 320  :         if (!MySetFilePointerEx(hFile, pos, NULL, dwMoveMethod))

  00040	50		 push	 eax
  00041	6a 00		 push	 0
  00043	ff 75 10	 push	 DWORD PTR _offset$[ebp]
  00046	33 d2		 xor	 edx, edx
  00048	8b cf		 mov	 ecx, edi
  0004a	e8 00 00 00 00	 call	 _MySetFilePointerEx
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00052	85 c0		 test	 eax, eax
  00054	75 12		 jne	 SHORT $LN10@win32_seek

; 321  :         {
; 322  :             DWORD dwErr = GetLastError();

  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 323  :             ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;

  0005c	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 324  :             ret = -1;

  0005f	83 c9 ff	 or	 ecx, -1
  00062	5f		 pop	 edi

; 328  :     }
; 329  :     return ret;

  00063	8b c1		 mov	 eax, ecx

; 330  : }

  00065	5e		 pop	 esi
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
$LN10@win32_seek:

; 325  :         }
; 326  :         else
; 327  :             ret=0;

  00068	33 c9		 xor	 ecx, ecx
$LN11@win32_seek:
  0006a	5f		 pop	 edi

; 328  :     }
; 329  :     return ret;

  0006b	8b c1		 mov	 eax, ecx

; 330  : }

  0006d	5e		 pop	 esi
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
_win32_seek_file_func ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\iowin32.c
;	COMDAT _win32_seek64_file_func
_TEXT	SEGMENT
_opaque$ = 8						; size = 4
_stream$ = 12						; size = 4
_offset$ = 16						; size = 8
_origin$ = 24						; size = 4
_win32_seek64_file_func PROC				; COMDAT

; 332  : long ZCALLBACK win32_seek64_file_func(voidpf opaque, voidpf stream, ZPOS64_T offset, int origin) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 333  :     DWORD dwMoveMethod=0xFFFFFFFF;
; 334  :     HANDLE hFile = NULL;
; 335  :     long ret=-1;
; 336  : 
; 337  :     if (stream!=NULL)

  00004	8b 75 0c	 mov	 esi, DWORD PTR _stream$[ebp]
  00007	83 c9 ff	 or	 ecx, -1
  0000a	57		 push	 edi
  0000b	33 ff		 xor	 edi, edi
  0000d	85 f6		 test	 esi, esi
  0000f	74 02		 je	 SHORT $LN4@win32_seek

; 338  :         hFile = ((WIN32FILE_IOWIN*)stream)->hf;

  00011	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN4@win32_seek:

; 339  : 
; 340  :     switch (origin)

  00013	8b 45 18	 mov	 eax, DWORD PTR _origin$[ebp]
  00016	83 e8 00	 sub	 eax, 0
  00019	74 1f		 je	 SHORT $LN7@win32_seek
  0001b	83 e8 01	 sub	 eax, 1
  0001e	74 13		 je	 SHORT $LN5@win32_seek
  00020	83 e8 01	 sub	 eax, 1
  00023	74 07		 je	 SHORT $LN6@win32_seek

; 350  :             break;
; 351  :         default: return -1;

  00025	5f		 pop	 edi
  00026	83 c8 ff	 or	 eax, -1

; 368  : }

  00029	5e		 pop	 esi
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN6@win32_seek:

; 345  :         case ZLIB_FILEFUNC_SEEK_END :
; 346  :             dwMoveMethod = FILE_END;

  0002c	b8 02 00 00 00	 mov	 eax, 2

; 347  :             break;

  00031	eb 09		 jmp	 SHORT $LN2@win32_seek
$LN5@win32_seek:

; 341  :     {
; 342  :         case ZLIB_FILEFUNC_SEEK_CUR :
; 343  :             dwMoveMethod = FILE_CURRENT;

  00033	b8 01 00 00 00	 mov	 eax, 1

; 344  :             break;

  00038	eb 02		 jmp	 SHORT $LN2@win32_seek
$LN7@win32_seek:

; 348  :         case ZLIB_FILEFUNC_SEEK_SET :
; 349  :             dwMoveMethod = FILE_BEGIN;

  0003a	33 c0		 xor	 eax, eax
$LN2@win32_seek:

; 352  :     }
; 353  : 
; 354  :     if (hFile)

  0003c	85 ff		 test	 edi, edi
  0003e	74 2b		 je	 SHORT $LN11@win32_seek

; 355  :     {
; 356  :         LARGE_INTEGER pos;
; 357  :         pos.QuadPart = offset;
; 358  :         if (!MySetFilePointerEx(hFile, pos, NULL, dwMoveMethod))

  00040	50		 push	 eax
  00041	ff 75 14	 push	 DWORD PTR _offset$[ebp+4]
  00044	33 d2		 xor	 edx, edx
  00046	8b cf		 mov	 ecx, edi
  00048	ff 75 10	 push	 DWORD PTR _offset$[ebp]
  0004b	e8 00 00 00 00	 call	 _MySetFilePointerEx
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	85 c0		 test	 eax, eax
  00055	75 12		 jne	 SHORT $LN10@win32_seek

; 359  :         {
; 360  :             DWORD dwErr = GetLastError();

  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 361  :             ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;

  0005d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 362  :             ret = -1;

  00060	83 c9 ff	 or	 ecx, -1
  00063	5f		 pop	 edi

; 366  :     }
; 367  :     return ret;

  00064	8b c1		 mov	 eax, ecx

; 368  : }

  00066	5e		 pop	 esi
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
$LN10@win32_seek:

; 363  :         }
; 364  :         else
; 365  :             ret=0;

  00069	33 c9		 xor	 ecx, ecx
$LN11@win32_seek:
  0006b	5f		 pop	 edi

; 366  :     }
; 367  :     return ret;

  0006c	8b c1		 mov	 eax, ecx

; 368  : }

  0006e	5e		 pop	 esi
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_win32_seek64_file_func ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\iowin32.c
;	COMDAT _win32_close_file_func
_TEXT	SEGMENT
_opaque$ = 8						; size = 4
_stream$ = 12						; size = 4
_win32_close_file_func PROC				; COMDAT

; 370  : int ZCALLBACK win32_close_file_func(voidpf opaque, voidpf stream) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 371  :     int ret=-1;
; 372  : 
; 373  :     if (stream!=NULL)

  00005	8b 7d 0c	 mov	 edi, DWORD PTR _stream$[ebp]
  00008	83 ce ff	 or	 esi, -1
  0000b	85 ff		 test	 edi, edi
  0000d	74 18		 je	 SHORT $LN5@win32_clos

; 374  :     {
; 375  :         HANDLE hFile;
; 376  :         hFile = ((WIN32FILE_IOWIN*)stream) -> hf;

  0000f	8b 07		 mov	 eax, DWORD PTR [edi]

; 377  :         if (hFile != NULL)

  00011	85 c0		 test	 eax, eax
  00013	74 09		 je	 SHORT $LN3@win32_clos

; 378  :         {
; 379  :             CloseHandle(hFile);

  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 380  :             ret=0;

  0001c	33 f6		 xor	 esi, esi
$LN3@win32_clos:

; 381  :         }
; 382  :         free(stream);

  0001e	57		 push	 edi
  0001f	e8 00 00 00 00	 call	 _free
  00024	83 c4 04	 add	 esp, 4
$LN5@win32_clos:

; 383  :     }
; 384  :     return ret;
; 385  : }

  00027	5f		 pop	 edi
  00028	8b c6		 mov	 eax, esi
  0002a	5e		 pop	 esi
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
_win32_close_file_func ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\iowin32.c
;	COMDAT _win32_error_file_func
_TEXT	SEGMENT
_opaque$ = 8						; size = 4
_stream$ = 12						; size = 4
_win32_error_file_func PROC				; COMDAT

; 387  : int ZCALLBACK win32_error_file_func(voidpf opaque, voidpf stream) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 388  :     int ret=-1;
; 389  :     if (stream!=NULL)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _stream$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 05		 je	 SHORT $LN4@win32_erro

; 390  :     {
; 391  :         ret = ((WIN32FILE_IOWIN*)stream) -> error;
; 392  :     }
; 393  :     return ret;

  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 394  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
$LN4@win32_erro:

; 390  :     {
; 391  :         ret = ((WIN32FILE_IOWIN*)stream) -> error;
; 392  :     }
; 393  :     return ret;

  0000f	83 c8 ff	 or	 eax, -1

; 394  : }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
_win32_error_file_func ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\iowin32.c
;	COMDAT _fill_win32_filefunc
_TEXT	SEGMENT
_pzlib_filefunc_def$ = 8				; size = 4
_fill_win32_filefunc PROC				; COMDAT

; 396  : void fill_win32_filefunc(zlib_filefunc_def* pzlib_filefunc_def) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 397  :     pzlib_filefunc_def->zopen_file = win32_open_file_func;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pzlib_filefunc_def$[ebp]
  00006	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET _win32_open_file_func

; 398  :     pzlib_filefunc_def->zread_file = win32_read_file_func;

  0000c	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET _win32_read_file_func

; 399  :     pzlib_filefunc_def->zwrite_file = win32_write_file_func;

  00013	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _win32_write_file_func

; 400  :     pzlib_filefunc_def->ztell_file = win32_tell_file_func;

  0001a	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], OFFSET _win32_tell_file_func

; 401  :     pzlib_filefunc_def->zseek_file = win32_seek_file_func;

  00021	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], OFFSET _win32_seek_file_func

; 402  :     pzlib_filefunc_def->zclose_file = win32_close_file_func;

  00028	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], OFFSET _win32_close_file_func

; 403  :     pzlib_filefunc_def->zerror_file = win32_error_file_func;

  0002f	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET _win32_error_file_func

; 404  :     pzlib_filefunc_def->opaque = NULL;

  00036	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 405  : }

  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
_fill_win32_filefunc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\iowin32.c
;	COMDAT _fill_win32_filefunc64
_TEXT	SEGMENT
_pzlib_filefunc_def$ = 8				; size = 4
_fill_win32_filefunc64 PROC				; COMDAT

; 407  : void fill_win32_filefunc64(zlib_filefunc64_def* pzlib_filefunc_def) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 408  :     pzlib_filefunc_def->zopen64_file = win32_open64_file_func;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pzlib_filefunc_def$[ebp]
  00006	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET _win32_open64_file_func

; 409  :     pzlib_filefunc_def->zread_file = win32_read_file_func;

  0000c	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET _win32_read_file_func

; 410  :     pzlib_filefunc_def->zwrite_file = win32_write_file_func;

  00013	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _win32_write_file_func

; 411  :     pzlib_filefunc_def->ztell64_file = win32_tell64_file_func;

  0001a	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], OFFSET _win32_tell64_file_func

; 412  :     pzlib_filefunc_def->zseek64_file = win32_seek64_file_func;

  00021	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], OFFSET _win32_seek64_file_func

; 413  :     pzlib_filefunc_def->zclose_file = win32_close_file_func;

  00028	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], OFFSET _win32_close_file_func

; 414  :     pzlib_filefunc_def->zerror_file = win32_error_file_func;

  0002f	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET _win32_error_file_func

; 415  :     pzlib_filefunc_def->opaque = NULL;

  00036	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 416  : }

  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
_fill_win32_filefunc64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\iowin32.c
;	COMDAT _fill_win32_filefunc64A
_TEXT	SEGMENT
_pzlib_filefunc_def$ = 8				; size = 4
_fill_win32_filefunc64A PROC				; COMDAT

; 419  : void fill_win32_filefunc64A(zlib_filefunc64_def* pzlib_filefunc_def) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 420  :     pzlib_filefunc_def->zopen64_file = win32_open64_file_funcA;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pzlib_filefunc_def$[ebp]
  00006	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET _win32_open64_file_funcA

; 421  :     pzlib_filefunc_def->zread_file = win32_read_file_func;

  0000c	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET _win32_read_file_func

; 422  :     pzlib_filefunc_def->zwrite_file = win32_write_file_func;

  00013	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _win32_write_file_func

; 423  :     pzlib_filefunc_def->ztell64_file = win32_tell64_file_func;

  0001a	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], OFFSET _win32_tell64_file_func

; 424  :     pzlib_filefunc_def->zseek64_file = win32_seek64_file_func;

  00021	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], OFFSET _win32_seek64_file_func

; 425  :     pzlib_filefunc_def->zclose_file = win32_close_file_func;

  00028	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], OFFSET _win32_close_file_func

; 426  :     pzlib_filefunc_def->zerror_file = win32_error_file_func;

  0002f	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET _win32_error_file_func

; 427  :     pzlib_filefunc_def->opaque = NULL;

  00036	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 428  : }

  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
_fill_win32_filefunc64A ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\iowin32.c
;	COMDAT _fill_win32_filefunc64W
_TEXT	SEGMENT
_pzlib_filefunc_def$ = 8				; size = 4
_fill_win32_filefunc64W PROC				; COMDAT

; 431  : void fill_win32_filefunc64W(zlib_filefunc64_def* pzlib_filefunc_def) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 432  :     pzlib_filefunc_def->zopen64_file = win32_open64_file_funcW;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pzlib_filefunc_def$[ebp]
  00006	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET _win32_open64_file_funcW

; 433  :     pzlib_filefunc_def->zread_file = win32_read_file_func;

  0000c	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET _win32_read_file_func

; 434  :     pzlib_filefunc_def->zwrite_file = win32_write_file_func;

  00013	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET _win32_write_file_func

; 435  :     pzlib_filefunc_def->ztell64_file = win32_tell64_file_func;

  0001a	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], OFFSET _win32_tell64_file_func

; 436  :     pzlib_filefunc_def->zseek64_file = win32_seek64_file_func;

  00021	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], OFFSET _win32_seek64_file_func

; 437  :     pzlib_filefunc_def->zclose_file = win32_close_file_func;

  00028	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], OFFSET _win32_close_file_func

; 438  :     pzlib_filefunc_def->zerror_file = win32_error_file_func;

  0002f	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET _win32_error_file_func

; 439  :     pzlib_filefunc_def->opaque = NULL;

  00036	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 440  : }

  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
_fill_win32_filefunc64W ENDP
_TEXT	ENDS
END
