; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type@		; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@	; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@ ; `string'
PUBLIC	??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@ ; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code@	; `string'
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@ ; `string'
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@ DB 'invalid distanc'
	DB	'e too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code@ DB 'invalid distance code', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@ DB 'invalid literal/le'
	DB	'ngth code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set@ DB 'invalid distances set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@ DB 'invalid literal/le'
	DB	'ngths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@
CONST	SEGMENT
??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@ DB 'invalid c'
	DB	'ode -- missing end-of-block', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@ DB 'invalid bit length r'
	DB	'epeat', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@ DB 'invalid code lengths '
	DB	'set', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@ DB 'too many len'
	DB	'gth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@ DB 'invalid stored bl'
	DB	'ock lengths', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type@ DB 'invalid block type', 00H ; `string'
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflateBack@@9@9 DW 010H			; `inflateBack'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	inflateBackEnd
PUBLIC	inflateBack
PUBLIC	inflateBackInit_
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBackEnd DD imagerel $LN6
	DD	imagerel $LN6+65
	DD	imagerel $unwind$inflateBackEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBack DD imagerel $LN512
	DD	imagerel $LN512+64
	DD	imagerel $unwind$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$inflateBack DD imagerel $LN512+64
	DD	imagerel $LN512+95
	DD	imagerel $chain$2$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateBack DD imagerel $LN512+95
	DD	imagerel $LN512+3614
	DD	imagerel $chain$3$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateBack DD imagerel $LN512+3614
	DD	imagerel $LN512+3681
	DD	imagerel $chain$4$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$inflateBack DD imagerel $LN512+3681
	DD	imagerel $LN512+3776
	DD	imagerel $chain$5$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBackInit_ DD imagerel $LN13
	DD	imagerel $LN13+87
	DD	imagerel $unwind$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$inflateBackInit_ DD imagerel $LN13+87
	DD	imagerel $LN13+188
	DD	imagerel $chain$0$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$inflateBackInit_ DD imagerel $LN13+188
	DD	imagerel $LN13+236
	DD	imagerel $chain$2$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateBackInit_ DD imagerel $LN13+236
	DD	imagerel $LN13+278
	DD	imagerel $chain$3$inflateBackInit_
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateBackInit_ DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+87
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$inflateBackInit_ DD 020021H
	DD	065400H
	DD	imagerel $LN13
	DD	imagerel $LN13+87
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$inflateBackInit_ DD 020521H
	DD	065405H
	DD	imagerel $LN13
	DD	imagerel $LN13+87
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackInit_ DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$inflateBack DD 021H
	DD	imagerel $LN512
	DD	imagerel $LN512+64
	DD	imagerel $unwind$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateBack DD 021H
	DD	imagerel $LN512+64
	DD	imagerel $LN512+95
	DD	imagerel $chain$2$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateBack DD 020421H
	DD	0be404H
	DD	imagerel $LN512+64
	DD	imagerel $LN512+95
	DD	imagerel $chain$2$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$inflateBack DD 060f21H
	DD	0c740fH
	DD	0d640bH
	DD	0e3404H
	DD	imagerel $LN512
	DD	imagerel $LN512+64
	DD	imagerel $unwind$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBack DD 052101H
	DD	0f01ae221H
	DD	0c016d018H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackEnd DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\infback.c
;	COMDAT inflateBackInit_
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
window$ = 64
version$ = 72
stream_size$ = 80
inflateBackInit_ PROC					; COMDAT

; 34   : {

$LN13:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f0	 mov	 rsi, r8
  00012	8b fa		 mov	 edi, edx
  00014	48 8b d9	 mov	 rbx, rcx

; 35   :     struct inflate_state FAR *state;
; 36   : 
; 37   :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  00017	4d 85 c9	 test	 r9, r9
  0001a	0f 84 e1 00 00
	00		 je	 $LN3@inflateBac
  00020	41 80 39 31	 cmp	 BYTE PTR [r9], 49	; 00000031H
  00024	0f 85 d7 00 00
	00		 jne	 $LN3@inflateBac
  0002a	83 7c 24 50 58	 cmp	 DWORD PTR stream_size$[rsp], 88 ; 00000058H
  0002f	0f 85 cc 00 00
	00		 jne	 $LN3@inflateBac

; 38   :         stream_size != (int)(sizeof(z_stream)))
; 39   :         return Z_VERSION_ERROR;
; 40   :     if (strm == Z_NULL || window == Z_NULL ||
; 41   :         windowBits < 8 || windowBits > 15)

  00035	48 85 c9	 test	 rcx, rcx
  00038	0f 84 ae 00 00
	00		 je	 $LN5@inflateBac
  0003e	4d 85 c0	 test	 r8, r8
  00041	0f 84 a5 00 00
	00		 je	 $LN5@inflateBac
  00047	8d 42 f8	 lea	 eax, DWORD PTR [rdx-8]
  0004a	83 f8 07	 cmp	 eax, 7
  0004d	0f 87 99 00 00
	00		 ja	 $LN5@inflateBac

; 43   :     strm->msg = Z_NULL;                 /* in case we return an error */
; 44   :     if (strm->zalloc == (alloc_func)0) {

  00053	48 8b 41 30	 mov	 rax, QWORD PTR [rcx+48]
  00057	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0005c	33 ed		 xor	 ebp, ebp
  0005e	48 89 69 20	 mov	 QWORD PTR [rcx+32], rbp
  00062	48 85 c0	 test	 rax, rax
  00065	75 13		 jne	 SHORT $LN10@inflateBac

; 45   : #ifdef Z_SOLO
; 46   :         return Z_STREAM_ERROR;
; 47   : #else
; 48   :         strm->zalloc = zcalloc;

  00067	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc

; 49   :         strm->opaque = (voidpf)0;

  0006e	48 89 69 40	 mov	 QWORD PTR [rcx+64], rbp
  00072	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
  00076	8b cd		 mov	 ecx, ebp
  00078	eb 04		 jmp	 SHORT $LN6@inflateBac
$LN10@inflateBac:
  0007a	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
$LN6@inflateBac:

; 50   : #endif
; 51   :     }
; 52   :     if (strm->zfree == (free_func)0)

  0007e	48 39 6b 38	 cmp	 QWORD PTR [rbx+56], rbp
  00082	75 0b		 jne	 SHORT $LN7@inflateBac

; 53   : #ifdef Z_SOLO
; 54   :         return Z_STREAM_ERROR;
; 55   : #else
; 56   :     strm->zfree = zcfree;

  00084	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:zcfree
  0008b	48 89 53 38	 mov	 QWORD PTR [rbx+56], rdx
$LN7@inflateBac:

; 57   : #endif
; 58   :     state = (struct inflate_state FAR *)ZALLOC(strm, 1,

  0008f	ba 01 00 00 00	 mov	 edx, 1
  00094	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  0009a	ff d0		 call	 rax
  0009c	48 8b d0	 mov	 rdx, rax

; 59   :                                                sizeof(struct inflate_state));
; 60   :     if (state == Z_NULL) return Z_MEM_ERROR;

  0009f	48 85 c0	 test	 rax, rax
  000a2	75 18		 jne	 SHORT $LN8@inflateBac
  000a4	8d 42 fc	 lea	 eax, QWORD PTR [rdx-4]
$LN11@inflateBac:
  000a7	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 71   : }

  000ac	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000b1	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000b6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ba	5f		 pop	 rdi
  000bb	c3		 ret	 0
$LN8@inflateBac:

; 61   :     Tracev((stderr, "inflate: allocated\n"));
; 62   :     strm->state = (struct internal_state FAR *)state;

  000bc	48 89 53 28	 mov	 QWORD PTR [rbx+40], rdx

; 63   :     state->dmax = 32768U;
; 64   :     state->wbits = (uInt)windowBits;
; 65   :     state->wsize = 1U << windowBits;

  000c0	8b cf		 mov	 ecx, edi
  000c2	c7 40 1c 00 80
	00 00		 mov	 DWORD PTR [rax+28], 32768 ; 00008000H
  000c9	89 78 30	 mov	 DWORD PTR [rax+48], edi
  000cc	b8 01 00 00 00	 mov	 eax, 1
  000d1	d3 e0		 shl	 eax, cl
  000d3	89 42 34	 mov	 DWORD PTR [rdx+52], eax

; 66   :     state->window = window;
; 67   :     state->wnext = 0;
; 68   :     state->whave = 0;
; 69   :     state->sane = 1;
; 70   :     return Z_OK;

  000d6	33 c0		 xor	 eax, eax
  000d8	48 89 72 40	 mov	 QWORD PTR [rdx+64], rsi
  000dc	48 89 6a 38	 mov	 QWORD PTR [rdx+56], rbp
  000e0	c7 82 e0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rdx+7136], 1
  000ea	eb bb		 jmp	 SHORT $LN11@inflateBac
$LN5@inflateBac:

; 42   :         return Z_STREAM_ERROR;

  000ec	b8 fe ff ff ff	 mov	 eax, -2

; 71   : }

  000f1	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000f6	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000fb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ff	5f		 pop	 rdi
  00100	c3		 ret	 0
$LN3@inflateBac:
  00101	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00106	b8 fa ff ff ff	 mov	 eax, -6
  0010b	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00110	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00114	5f		 pop	 rdi
  00115	c3		 ret	 0
inflateBackInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\infback.c
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 8
fixedtables PROC					; COMDAT

; 86   : #ifdef BUILDFIXED
; 87   :     static int virgin = 1;
; 88   :     static code *lenfix, *distfix;
; 89   :     static code fixed[544];
; 90   : 
; 91   :     /* build fixed huffman tables if first call (may not be thread safe) */
; 92   :     if (virgin) {
; 93   :         unsigned sym, bits;
; 94   :         static code *next;
; 95   : 
; 96   :         /* literal/length table */
; 97   :         sym = 0;
; 98   :         while (sym < 144) state->lens[sym++] = 8;
; 99   :         while (sym < 256) state->lens[sym++] = 9;
; 100  :         while (sym < 280) state->lens[sym++] = 7;
; 101  :         while (sym < 288) state->lens[sym++] = 8;
; 102  :         next = fixed;
; 103  :         lenfix = next;
; 104  :         bits = 9;
; 105  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 106  : 
; 107  :         /* distance table */
; 108  :         sym = 0;
; 109  :         while (sym < 32) state->lens[sym++] = 5;
; 110  :         distfix = next;
; 111  :         bits = 5;
; 112  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 113  : 
; 114  :         /* do this just once */
; 115  :         virgin = 0;
; 116  :     }
; 117  : #else /* !BUILDFIXED */
; 118  : #   include "inffixed.h"
; 119  : #endif /* BUILDFIXED */
; 120  :     state->lencode = lenfix;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9

; 121  :     state->lenbits = 9;

  00007	c7 41 70 09 00
	00 00		 mov	 DWORD PTR [rcx+112], 9
  0000e	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 122  :     state->distcode = distfix;

  00012	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  00019	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 123  :     state->distbits = 5;

  0001d	c7 41 74 05 00
	00 00		 mov	 DWORD PTR [rcx+116], 5

; 124  : }

  00024	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\infback.c
;	COMDAT inflateBack
_TEXT	SEGMENT
left$1$ = 48
here$ = 52
next$ = 56
put$1$ = 64
strm$ = 160
in$ = 168
in_desc$ = 176
out$ = 184
out_desc$ = 192
inflateBack PROC					; COMDAT

; 257  : {

$LN512:
  00000	48 8b c4	 mov	 rax, rsp
  00003	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  00007	4c 89 40 18	 mov	 QWORD PTR [rax+24], r8
  0000b	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx
  0000f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00013	55		 push	 rbp
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 57		 push	 r15
  0001a	48 8b ec	 mov	 rbp, rsp
  0001d	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00021	4d 8b e8	 mov	 r13, r8
  00024	4c 8b e2	 mov	 r12, rdx
  00027	4c 8b c9	 mov	 r9, rcx

; 258  :     struct inflate_state FAR *state;
; 259  :     z_const unsigned char FAR *next;    /* next input */
; 260  :     unsigned char FAR *put;     /* next output */
; 261  :     unsigned have, left;        /* available input and output */
; 262  :     unsigned long hold;         /* bit buffer */
; 263  :     unsigned bits;              /* bits in bit buffer */
; 264  :     unsigned copy;              /* number of stored or match bytes to copy */
; 265  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 266  :     code here;                  /* current decoding table entry */
; 267  :     code last;                  /* parent table entry */
; 268  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 269  :     int ret;                    /* return code */
; 270  :     static const unsigned short order[19] = /* permutation of code lengths */
; 271  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 272  : 
; 273  :     /* Check that the strm exists and that the state was initialized */
; 274  :     if (strm == Z_NULL || strm->state == Z_NULL)

  0002a	48 85 c9	 test	 rcx, rcx
  0002d	0f 84 2e 0e 00
	00		 je	 $LN254@inflateBac
  00033	4c 8b 79 28	 mov	 r15, QWORD PTR [rcx+40]
  00037	4d 85 ff	 test	 r15, r15
  0003a	0f 84 21 0e 00
	00		 je	 $LN254@inflateBac

; 276  :     state = (struct inflate_state FAR *)strm->state;
; 277  : 
; 278  :     /* Reset the state */
; 279  :     strm->msg = Z_NULL;

  00040	48 89 58 d8	 mov	 QWORD PTR [rax-40], rbx
  00044	45 33 d2	 xor	 r10d, r10d
  00047	48 89 70 d0	 mov	 QWORD PTR [rax-48], rsi
  0004b	48 89 78 c8	 mov	 QWORD PTR [rax-56], rdi
  0004f	4c 89 51 20	 mov	 QWORD PTR [rcx+32], r10

; 280  :     state->mode = TYPE;

  00053	49 c7 47 08 3f
	3f 00 00	 mov	 QWORD PTR [r15+8], 16191 ; 00003f3fH

; 281  :     state->last = 0;
; 282  :     state->whave = 0;

  0005b	45 89 57 38	 mov	 DWORD PTR [r15+56], r10d
  0005f	4c 89 70 c0	 mov	 QWORD PTR [rax-64], r14

; 283  :     next = strm->next_in;

  00063	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00066	48 89 45 c0	 mov	 QWORD PTR next$[rbp-120], rax
  0006a	48 85 c0	 test	 rax, rax

; 284  :     have = next != Z_NULL ? strm->avail_in : 0;

  0006d	74 05		 je	 SHORT $LN343@inflateBac
  0006f	8b 59 08	 mov	 ebx, DWORD PTR [rcx+8]
  00072	eb 03		 jmp	 SHORT $LN344@inflateBac
$LN343@inflateBac:
  00074	41 8b da	 mov	 ebx, r10d
$LN344@inflateBac:

; 285  :     hold = 0;
; 286  :     bits = 0;
; 287  :     put = state->window;
; 288  :     left = state->wsize;
; 289  : 
; 290  :     /* Inflate until end of block marked as last */
; 291  :     for (;;)
; 292  :         switch (state->mode) {

  00077	41 8b 47 08	 mov	 eax, DWORD PTR [r15+8]
  0007b	45 8b f2	 mov	 r14d, r10d
  0007e	49 8b 7f 40	 mov	 rdi, QWORD PTR [r15+64]
  00082	2d 3f 3f 00 00	 sub	 eax, 16191		; 00003f3fH
  00087	45 8b 47 34	 mov	 r8d, DWORD PTR [r15+52]
  0008b	41 8b f2	 mov	 esi, r10d
  0008e	48 89 7d c8	 mov	 QWORD PTR put$1$[rbp-120], rdi
  00092	44 89 45 b8	 mov	 DWORD PTR left$1$[rbp-120], r8d
  00096	83 f8 12	 cmp	 eax, 18
  00099	0f 87 5f 0d 00
	00		 ja	 $LN339@inflateBac
$LN505@inflateBac:
  0009f	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:__ImageBase
  000a6	48 98		 cdqe
  000a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type@
  000af	41 8b 8c 83 00
	00 00 00	 mov	 ecx, DWORD PTR $LN481@inflateBac[r11+rax*4]
  000b7	49 03 cb	 add	 rcx, r11
  000ba	ff e1		 jmp	 rcx
$LN255@inflateBac:

; 293  :         case TYPE:
; 294  :             /* determine and dispatch block type */
; 295  :             if (state->last) {

  000bc	41 83 7f 0c 00	 cmp	 DWORD PTR [r15+12], 0
  000c1	74 17		 je	 SHORT $LN12@inflateBac

; 296  :                 BYTEBITS();

  000c3	8b ce		 mov	 ecx, esi

; 297  :                 state->mode = DONE;

  000c5	41 c7 47 08 50
	3f 00 00	 mov	 DWORD PTR [r15+8], 16208 ; 00003f50H
  000cd	83 e1 07	 and	 ecx, 7
  000d0	41 d3 ee	 shr	 r14d, cl
  000d3	2b f1		 sub	 esi, ecx

; 298  :                 break;

  000d5	e9 ec 0c 00 00	 jmp	 $LN489@inflateBac
$LN12@inflateBac:

; 299  :             }
; 300  :             NEEDBITS(3);

  000da	83 fe 03	 cmp	 esi, 3
  000dd	73 47		 jae	 SHORT $LN10@inflateBac
  000df	90		 npad	 1
$LL13@inflateBac:
  000e0	85 db		 test	 ebx, ebx
  000e2	75 14		 jne	 SHORT $LN18@inflateBac
  000e4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  000e8	49 8b cd	 mov	 rcx, r13
  000eb	41 ff d4	 call	 r12
  000ee	8b d8		 mov	 ebx, eax
  000f0	85 c0		 test	 eax, eax
  000f2	0f 84 e9 0c 00
	00		 je	 $LN369@inflateBac
$LN18@inflateBac:
  000f8	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  000fc	8b ce		 mov	 ecx, esi
  000fe	ff cb		 dec	 ebx
  00100	83 c6 08	 add	 esi, 8
  00103	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00106	48 ff 45 c0	 inc	 QWORD PTR next$[rbp-120]
  0010a	d3 e0		 shl	 eax, cl
  0010c	44 03 f0	 add	 r14d, eax
  0010f	83 fe 03	 cmp	 esi, 3
  00112	72 cc		 jb	 SHORT $LL13@inflateBac
  00114	44 8b 45 b8	 mov	 r8d, DWORD PTR left$1$[rbp-120]
  00118	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type@
  0011f	4c 8b 4d 28	 mov	 r9, QWORD PTR strm$[rbp-120]
  00123	45 33 d2	 xor	 r10d, r10d
$LN10@inflateBac:

; 301  :             state->last = BITS(1);

  00126	41 8b c6	 mov	 eax, r14d

; 302  :             DROPBITS(1);

  00129	41 d1 ee	 shr	 r14d, 1
  0012c	83 e0 01	 and	 eax, 1
  0012f	41 89 47 0c	 mov	 DWORD PTR [r15+12], eax

; 303  :             switch (BITS(2)) {

  00133	41 8b c6	 mov	 eax, r14d
  00136	83 e0 03	 and	 eax, 3
  00139	74 57		 je	 SHORT $LN259@inflateBac
  0013b	83 e8 01	 sub	 eax, 1
  0013e	74 36		 je	 SHORT $LN260@inflateBac
  00140	83 e8 01	 sub	 eax, 1
  00143	74 1d		 je	 SHORT $LN261@inflateBac
  00145	83 f8 01	 cmp	 eax, 1
  00148	75 50		 jne	 SHORT $LN28@inflateBac

; 311  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 312  :                         state->last ? " (last)" : ""));
; 313  :                 state->mode = LEN;              /* decode codes */
; 314  :                 break;
; 315  :             case 2:                             /* dynamic block */
; 316  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 317  :                         state->last ? " (last)" : ""));
; 318  :                 state->mode = TABLE;
; 319  :                 break;
; 320  :             case 3:
; 321  :                 strm->msg = (char *)"invalid block type";
; 322  :                 state->mode = BAD;
; 323  :             }
; 324  :             DROPBITS(2);

  0014a	41 c1 ee 02	 shr	 r14d, 2
  0014e	49 89 51 20	 mov	 QWORD PTR [r9+32], rdx
  00152	83 c6 fd	 add	 esi, -3			; fffffffdH
  00155	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H

; 325  :             break;

  0015d	e9 64 0c 00 00	 jmp	 $LN489@inflateBac
$LN261@inflateBac:

; 311  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 312  :                         state->last ? " (last)" : ""));
; 313  :                 state->mode = LEN;              /* decode codes */
; 314  :                 break;
; 315  :             case 2:                             /* dynamic block */
; 316  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 317  :                         state->last ? " (last)" : ""));
; 318  :                 state->mode = TABLE;
; 319  :                 break;
; 320  :             case 3:
; 321  :                 strm->msg = (char *)"invalid block type";
; 322  :                 state->mode = BAD;
; 323  :             }
; 324  :             DROPBITS(2);

  00162	41 c1 ee 02	 shr	 r14d, 2
  00166	83 c6 fd	 add	 esi, -3			; fffffffdH
  00169	41 c7 47 08 44
	3f 00 00	 mov	 DWORD PTR [r15+8], 16196 ; 00003f44H

; 325  :             break;

  00171	e9 50 0c 00 00	 jmp	 $LN489@inflateBac
$LN260@inflateBac:

; 308  :                 break;
; 309  :             case 1:                             /* fixed block */
; 310  :                 fixedtables(state);

  00176	49 8b cf	 mov	 rcx, r15
  00179	e8 00 00 00 00	 call	 fixedtables

; 311  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 312  :                         state->last ? " (last)" : ""));
; 313  :                 state->mode = LEN;              /* decode codes */
; 314  :                 break;
; 315  :             case 2:                             /* dynamic block */
; 316  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 317  :                         state->last ? " (last)" : ""));
; 318  :                 state->mode = TABLE;
; 319  :                 break;
; 320  :             case 3:
; 321  :                 strm->msg = (char *)"invalid block type";
; 322  :                 state->mode = BAD;
; 323  :             }
; 324  :             DROPBITS(2);

  0017e	41 c1 ee 02	 shr	 r14d, 2
  00182	83 c6 fd	 add	 esi, -3			; fffffffdH
  00185	41 c7 47 08 48
	3f 00 00	 mov	 DWORD PTR [r15+8], 16200 ; 00003f48H

; 325  :             break;

  0018d	e9 34 0c 00 00	 jmp	 $LN489@inflateBac
$LN259@inflateBac:

; 304  :             case 0:                             /* stored block */
; 305  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 306  :                         state->last ? " (last)" : ""));
; 307  :                 state->mode = STORED;

  00192	41 c7 47 08 41
	3f 00 00	 mov	 DWORD PTR [r15+8], 16193 ; 00003f41H
$LN28@inflateBac:

; 311  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 312  :                         state->last ? " (last)" : ""));
; 313  :                 state->mode = LEN;              /* decode codes */
; 314  :                 break;
; 315  :             case 2:                             /* dynamic block */
; 316  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 317  :                         state->last ? " (last)" : ""));
; 318  :                 state->mode = TABLE;
; 319  :                 break;
; 320  :             case 3:
; 321  :                 strm->msg = (char *)"invalid block type";
; 322  :                 state->mode = BAD;
; 323  :             }
; 324  :             DROPBITS(2);

  0019a	41 c1 ee 02	 shr	 r14d, 2
  0019e	83 c6 fd	 add	 esi, -3			; fffffffdH

; 325  :             break;

  001a1	e9 20 0c 00 00	 jmp	 $LN489@inflateBac
$LN31@inflateBac:

; 326  : 
; 327  :         case STORED:
; 328  :             /* get and verify stored block length */
; 329  :             BYTEBITS();                         /* go to byte boundary */

  001a6	8b ce		 mov	 ecx, esi
  001a8	83 e1 07	 and	 ecx, 7
  001ab	41 d3 ee	 shr	 r14d, cl
  001ae	2b f1		 sub	 esi, ecx

; 330  :             NEEDBITS(32);

  001b0	83 fe 20	 cmp	 esi, 32			; 00000020H
  001b3	73 3f		 jae	 SHORT $LN32@inflateBac
$LL35@inflateBac:
  001b5	85 db		 test	 ebx, ebx
  001b7	75 14		 jne	 SHORT $LN40@inflateBac
  001b9	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  001bd	49 8b cd	 mov	 rcx, r13
  001c0	41 ff d4	 call	 r12
  001c3	8b d8		 mov	 ebx, eax
  001c5	85 c0		 test	 eax, eax
  001c7	0f 84 14 0c 00
	00		 je	 $LN369@inflateBac
$LN40@inflateBac:
  001cd	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  001d1	8b ce		 mov	 ecx, esi
  001d3	ff cb		 dec	 ebx
  001d5	83 c6 08	 add	 esi, 8
  001d8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001db	48 ff 45 c0	 inc	 QWORD PTR next$[rbp-120]
  001df	d3 e0		 shl	 eax, cl
  001e1	44 03 f0	 add	 r14d, eax
  001e4	83 fe 20	 cmp	 esi, 32			; 00000020H
  001e7	72 cc		 jb	 SHORT $LL35@inflateBac
  001e9	44 8b 45 b8	 mov	 r8d, DWORD PTR left$1$[rbp-120]
  001ed	45 33 d2	 xor	 r10d, r10d
  001f0	4c 8b 4d 28	 mov	 r9, QWORD PTR strm$[rbp-120]
$LN32@inflateBac:

; 331  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  001f4	41 8b c6	 mov	 eax, r14d
  001f7	41 0f b7 fe	 movzx	 edi, r14w
  001fb	f7 d0		 not	 eax
  001fd	c1 e8 10	 shr	 eax, 16
  00200	3b f8		 cmp	 edi, eax
  00202	74 1c		 je	 SHORT $LN266@inflateBac

; 332  :                 strm->msg = (char *)"invalid stored block lengths";
; 333  :                 state->mode = BAD;
; 334  :                 break;

  00204	48 8b 7d c8	 mov	 rdi, QWORD PTR put$1$[rbp-120]
  00208	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@
  0020f	49 89 41 20	 mov	 QWORD PTR [r9+32], rax
  00213	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H
  0021b	e9 a6 0b 00 00	 jmp	 $LN489@inflateBac
$LN266@inflateBac:

; 335  :             }
; 336  :             state->length = (unsigned)hold & 0xffff;

  00220	41 89 7f 50	 mov	 DWORD PTR [r15+80], edi

; 337  :             Tracev((stderr, "inflate:       stored length %u\n",
; 338  :                     state->length));
; 339  :             INITBITS();

  00224	45 8b f2	 mov	 r14d, r10d
  00227	41 8b f2	 mov	 esi, r10d

; 340  : 
; 341  :             /* copy stored block from input to output */
; 342  :             while (state->length != 0) {

  0022a	85 ff		 test	 edi, edi
  0022c	0f 84 90 00 00
	00		 je	 $LN47@inflateBac
$LL46@inflateBac:

; 343  :                 copy = state->length;
; 344  :                 PULL();

  00232	85 db		 test	 ebx, ebx
  00234	75 14		 jne	 SHORT $LN48@inflateBac
  00236	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  0023a	49 8b cd	 mov	 rcx, r13
  0023d	41 ff d4	 call	 r12
  00240	8b d8		 mov	 ebx, eax
  00242	85 c0		 test	 eax, eax
  00244	0f 84 97 0b 00
	00		 je	 $LN369@inflateBac
$LN48@inflateBac:

; 345  :                 ROOM();

  0024a	8b 55 b8	 mov	 edx, DWORD PTR left$1$[rbp-120]
  0024d	85 d2		 test	 edx, edx
  0024f	75 2b		 jne	 SHORT $LN51@inflateBac
  00251	41 8b 4f 34	 mov	 ecx, DWORD PTR [r15+52]
  00255	44 8b c1	 mov	 r8d, ecx
  00258	49 8b 47 40	 mov	 rax, QWORD PTR [r15+64]
  0025c	89 4d b8	 mov	 DWORD PTR left$1$[rbp-120], ecx
  0025f	48 8b d0	 mov	 rdx, rax
  00262	41 89 4f 38	 mov	 DWORD PTR [r15+56], ecx
  00266	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  0026a	48 89 45 c8	 mov	 QWORD PTR put$1$[rbp-120], rax
  0026e	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00271	85 c0		 test	 eax, eax
  00273	0f 85 6e 0b 00
	00		 jne	 $LN372@inflateBac
  00279	8b 55 b8	 mov	 edx, DWORD PTR left$1$[rbp-120]
$LN51@inflateBac:

; 346  :                 if (copy > have) copy = have;
; 347  :                 if (copy > left) copy = left;

  0027c	3b fb		 cmp	 edi, ebx

; 348  :                 zmemcpy(put, next, copy);

  0027e	8b c2		 mov	 eax, edx
  00280	8b cb		 mov	 ecx, ebx
  00282	0f 46 cf	 cmovbe	 ecx, edi
  00285	3b ca		 cmp	 ecx, edx
  00287	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  0028b	0f 46 c1	 cmovbe	 eax, ecx
  0028e	48 8b 4d c8	 mov	 rcx, QWORD PTR put$1$[rbp-120]
  00292	44 8b c0	 mov	 r8d, eax
  00295	8b f8		 mov	 edi, eax
  00297	e8 00 00 00 00	 call	 memcpy

; 349  :                 have -= copy;
; 350  :                 next += copy;
; 351  :                 left -= copy;

  0029c	44 8b 45 b8	 mov	 r8d, DWORD PTR left$1$[rbp-120]
  002a0	2b df		 sub	 ebx, edi
  002a2	48 01 7d c0	 add	 QWORD PTR next$[rbp-120], rdi
  002a6	44 2b c7	 sub	 r8d, edi

; 352  :                 put += copy;

  002a9	48 01 7d c8	 add	 QWORD PTR put$1$[rbp-120], rdi

; 353  :                 state->length -= copy;

  002ad	41 29 7f 50	 sub	 DWORD PTR [r15+80], edi
  002b1	41 8b 7f 50	 mov	 edi, DWORD PTR [r15+80]
  002b5	44 89 45 b8	 mov	 DWORD PTR left$1$[rbp-120], r8d
  002b9	0f 85 73 ff ff
	ff		 jne	 $LL46@inflateBac
  002bf	45 33 d2	 xor	 r10d, r10d
$LN47@inflateBac:

; 354  :             }
; 355  :             Tracev((stderr, "inflate:       stored end\n"));
; 356  :             state->mode = TYPE;
; 357  :             break;

  002c2	48 8b 7d c8	 mov	 rdi, QWORD PTR put$1$[rbp-120]
  002c6	41 c7 47 08 3f
	3f 00 00	 mov	 DWORD PTR [r15+8], 16191 ; 00003f3fH
  002ce	e9 ef 0a 00 00	 jmp	 $LN500@inflateBac
$LN56@inflateBac:

; 358  : 
; 359  :         case TABLE:
; 360  :             /* get dynamic table entries descriptor */
; 361  :             NEEDBITS(14);

  002d3	83 fe 0e	 cmp	 esi, 14
  002d6	73 42		 jae	 SHORT $LN54@inflateBac
$LL57@inflateBac:
  002d8	85 db		 test	 ebx, ebx
  002da	75 14		 jne	 SHORT $LN62@inflateBac
  002dc	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  002e0	49 8b cd	 mov	 rcx, r13
  002e3	41 ff d4	 call	 r12
  002e6	8b d8		 mov	 ebx, eax
  002e8	85 c0		 test	 eax, eax
  002ea	0f 84 f1 0a 00
	00		 je	 $LN369@inflateBac
$LN62@inflateBac:
  002f0	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  002f4	8b ce		 mov	 ecx, esi
  002f6	ff cb		 dec	 ebx
  002f8	83 c6 08	 add	 esi, 8
  002fb	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002fe	48 ff 45 c0	 inc	 QWORD PTR next$[rbp-120]
  00302	d3 e0		 shl	 eax, cl
  00304	44 03 f0	 add	 r14d, eax
  00307	83 fe 0e	 cmp	 esi, 14
  0030a	72 cc		 jb	 SHORT $LL57@inflateBac
  0030c	4c 8b 4d 28	 mov	 r9, QWORD PTR strm$[rbp-120]
  00310	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:__ImageBase
  00317	45 33 d2	 xor	 r10d, r10d
$LN54@inflateBac:

; 362  :             state->nlen = BITS(5) + 257;

  0031a	41 8b ce	 mov	 ecx, r14d

; 363  :             DROPBITS(5);
; 364  :             state->ndist = BITS(5) + 1;
; 365  :             DROPBITS(5);
; 366  :             state->ncode = BITS(4) + 4;
; 367  :             DROPBITS(4);

  0031d	83 c6 f2	 add	 esi, -14		; fffffff2H
  00320	41 c1 ee 05	 shr	 r14d, 5
  00324	83 e1 1f	 and	 ecx, 31
  00327	41 8b d6	 mov	 edx, r14d
  0032a	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  00330	41 c1 ee 05	 shr	 r14d, 5
  00334	83 e2 1f	 and	 edx, 31
  00337	45 8b c6	 mov	 r8d, r14d
  0033a	41 89 4f 7c	 mov	 DWORD PTR [r15+124], ecx
  0033e	41 83 e0 0f	 and	 r8d, 15
  00342	41 c1 ee 04	 shr	 r14d, 4
  00346	41 83 c0 04	 add	 r8d, 4
  0034a	ff c2		 inc	 edx
  0034c	41 89 97 80 00
	00 00		 mov	 DWORD PTR [r15+128], edx
  00353	45 89 47 78	 mov	 DWORD PTR [r15+120], r8d

; 368  : #ifndef PKZIP_BUG_WORKAROUND
; 369  :             if (state->nlen > 286 || state->ndist > 30) {

  00357	81 f9 1e 01 00
	00		 cmp	 ecx, 286		; 0000011eH
  0035d	0f 87 87 05 00
	00		 ja	 $LN277@inflateBac
  00363	83 fa 1e	 cmp	 edx, 30
  00366	0f 87 7e 05 00
	00		 ja	 $LN277@inflateBac

; 373  :             }
; 374  : #endif
; 375  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 376  : 
; 377  :             /* get code length code lengths (not a typo) */
; 378  :             state->have = 0;

  0036c	45 89 97 84 00
	00 00		 mov	 DWORD PTR [r15+132], r10d
  00373	41 8b c2	 mov	 eax, r10d

; 379  :             while (state->have < state->ncode) {

  00376	45 85 c0	 test	 r8d, r8d
  00379	0f 84 92 00 00
	00		 je	 $LN472@inflateBac
  0037f	90		 npad	 1
$LL74@inflateBac:

; 380  :                 NEEDBITS(3);

  00380	83 fe 03	 cmp	 esi, 3
  00383	73 49		 jae	 SHORT $LN76@inflateBac
  00385	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  00389	0f 1f 80 00 00
	00 00		 npad	 7
$LL79@inflateBac:
  00390	85 db		 test	 ebx, ebx
  00392	75 18		 jne	 SHORT $LN84@inflateBac
  00394	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00398	49 8b cd	 mov	 rcx, r13
  0039b	41 ff d4	 call	 r12
  0039e	8b d8		 mov	 ebx, eax
  003a0	85 c0		 test	 eax, eax
  003a2	0f 84 39 0a 00
	00		 je	 $LN369@inflateBac
  003a8	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN84@inflateBac:
  003ac	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  003af	8b ce		 mov	 ecx, esi
  003b1	d3 e0		 shl	 eax, cl
  003b3	48 ff c2	 inc	 rdx
  003b6	44 03 f0	 add	 r14d, eax
  003b9	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  003bd	ff cb		 dec	 ebx
  003bf	83 c6 08	 add	 esi, 8
  003c2	83 fe 03	 cmp	 esi, 3
  003c5	72 c9		 jb	 SHORT $LL79@inflateBac
  003c7	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:__ImageBase
$LN76@inflateBac:

; 381  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  003ce	41 8b 87 84 00
	00 00		 mov	 eax, DWORD PTR [r15+132]
  003d5	41 0f b7 ce	 movzx	 ecx, r14w
  003d9	66 83 e1 07	 and	 cx, 7

; 382  :                 DROPBITS(3);

  003dd	41 c1 ee 03	 shr	 r14d, 3
  003e1	83 c6 fd	 add	 esi, -3			; fffffffdH
  003e4	41 0f b7 84 43
	00 00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[r11+rax*2]
  003ed	66 41 89 8c 47
	90 00 00 00	 mov	 WORD PTR [r15+rax*2+144], cx
  003f6	41 ff 87 84 00
	00 00		 inc	 DWORD PTR [r15+132]
  003fd	41 8b 87 84 00
	00 00		 mov	 eax, DWORD PTR [r15+132]
  00404	41 3b 47 78	 cmp	 eax, DWORD PTR [r15+120]
  00408	0f 82 72 ff ff
	ff		 jb	 $LL74@inflateBac
  0040e	45 33 d2	 xor	 r10d, r10d
$LN472@inflateBac:

; 383  :             }
; 384  :             while (state->have < 19)

  00411	83 f8 13	 cmp	 eax, 19
  00414	73 27		 jae	 SHORT $LN91@inflateBac
$LL90@inflateBac:

; 385  :                 state->lens[order[state->have++]] = 0;

  00416	41 0f b7 84 43
	00 00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[r11+rax*2]
  0041f	66 45 89 94 47
	90 00 00 00	 mov	 WORD PTR [r15+rax*2+144], r10w
  00428	41 8b 87 84 00
	00 00		 mov	 eax, DWORD PTR [r15+132]
  0042f	ff c0		 inc	 eax
  00431	41 89 87 84 00
	00 00		 mov	 DWORD PTR [r15+132], eax
  00438	83 f8 13	 cmp	 eax, 19
  0043b	72 d9		 jb	 SHORT $LL90@inflateBac
$LN91@inflateBac:

; 386  :             state->next = state->codes;

  0043d	49 8d 87 50 05
	00 00		 lea	 rax, QWORD PTR [r15+1360]

; 387  :             state->lencode = (code const FAR *)(state->next);
; 388  :             state->lenbits = 7;

  00444	41 c7 47 70 07
	00 00 00	 mov	 DWORD PTR [r15+112], 7

; 389  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  0044c	49 8d 97 10 03
	00 00		 lea	 rdx, QWORD PTR [r15+784]
  00453	49 89 87 88 00
	00 00		 mov	 QWORD PTR [r15+136], rax
  0045a	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  0045f	4d 8d 8f 88 00
	00 00		 lea	 r9, QWORD PTR [r15+136]
  00466	49 89 47 60	 mov	 QWORD PTR [r15+96], rax
  0046a	49 8d 97 90 00
	00 00		 lea	 rdx, QWORD PTR [r15+144]
  00471	49 8d 47 70	 lea	 rax, QWORD PTR [r15+112]
  00475	41 b8 13 00 00
	00		 mov	 r8d, 19
  0047b	33 c9		 xor	 ecx, ecx
  0047d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00482	e8 00 00 00 00	 call	 inflate_table

; 390  :                                 &(state->lenbits), state->work);
; 391  :             if (ret) {

  00487	85 c0		 test	 eax, eax
  00489	74 23		 je	 SHORT $LN280@inflateBac

; 392  :                 strm->msg = (char *)"invalid code lengths set";

  0048b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@
$LN509@inflateBac:

; 285  :     hold = 0;
; 286  :     bits = 0;
; 287  :     put = state->window;
; 288  :     left = state->wsize;
; 289  : 
; 290  :     /* Inflate until end of block marked as last */
; 291  :     for (;;)
; 292  :         switch (state->mode) {

  00492	4c 8b 4d 28	 mov	 r9, QWORD PTR strm$[rbp-120]
$LN502@inflateBac:
  00496	49 89 41 20	 mov	 QWORD PTR [r9+32], rax
  0049a	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H
$LN504@inflateBac:
  004a2	44 8b 45 b8	 mov	 r8d, DWORD PTR left$1$[rbp-120]
  004a6	45 33 d2	 xor	 r10d, r10d
  004a9	e9 18 09 00 00	 jmp	 $LN489@inflateBac
$LN280@inflateBac:

; 393  :                 state->mode = BAD;
; 394  :                 break;
; 395  :             }
; 396  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 397  : 
; 398  :             /* get length and distance code code lengths */
; 399  :             state->have = 0;
; 400  :             while (state->have < state->nlen + state->ndist) {

  004ae	41 8b 87 80 00
	00 00		 mov	 eax, DWORD PTR [r15+128]
  004b5	41 c7 87 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [r15+132], 0
  004c0	41 03 47 7c	 add	 eax, DWORD PTR [r15+124]
  004c4	0f 84 89 02 00
	00		 je	 $LN499@inflateBac
  004ca	49 8d 7f 70	 lea	 rdi, QWORD PTR [r15+112]
  004ce	66 90		 npad	 2
$LL92@inflateBac:

; 401  :                 for (;;) {
; 402  :                     here = state->lencode[BITS(state->lenbits)];

  004d0	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  004d2	b8 01 00 00 00	 mov	 eax, 1

; 403  :                     if ((unsigned)(here.bits) <= bits) break;

  004d7	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
  004db	d3 e0		 shl	 eax, cl
  004dd	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  004e0	41 8b c6	 mov	 eax, r14d
  004e3	48 23 c8	 and	 rcx, rax
  004e6	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  004ea	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  004ed	8b d0		 mov	 edx, eax
  004ef	c1 ea 08	 shr	 edx, 8
  004f2	44 8b c8	 mov	 r9d, eax
  004f5	0f b6 ca	 movzx	 ecx, dl
  004f8	41 c1 e9 10	 shr	 r9d, 16
  004fc	89 45 bc	 mov	 DWORD PTR here$[rbp-120], eax
  004ff	3b ce		 cmp	 ecx, esi
  00501	76 62		 jbe	 SHORT $LN375@inflateBac
$LL94@inflateBac:

; 404  :                     PULLBYTE();

  00503	85 db		 test	 ebx, ebx
  00505	75 18		 jne	 SHORT $LN100@inflateBac
  00507	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  0050b	49 8b cd	 mov	 rcx, r13
  0050e	41 ff d4	 call	 r12
  00511	8b d8		 mov	 ebx, eax
  00513	85 c0		 test	 eax, eax
  00515	0f 84 c6 08 00
	00		 je	 $LN369@inflateBac
  0051b	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN100@inflateBac:
  0051f	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00523	8b ce		 mov	 ecx, esi
  00525	d3 e0		 shl	 eax, cl
  00527	49 ff c0	 inc	 r8
  0052a	44 03 f0	 add	 r14d, eax
  0052d	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  00531	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  00533	b8 01 00 00 00	 mov	 eax, 1
  00538	d3 e0		 shl	 eax, cl
  0053a	ff cb		 dec	 ebx
  0053c	41 8b d6	 mov	 edx, r14d
  0053f	83 c6 08	 add	 esi, 8
  00542	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00545	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  00549	48 23 ca	 and	 rcx, rdx
  0054c	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0054f	8b d0		 mov	 edx, eax
  00551	c1 ea 08	 shr	 edx, 8
  00554	44 8b c8	 mov	 r9d, eax
  00557	0f b6 ca	 movzx	 ecx, dl
  0055a	41 c1 e9 10	 shr	 r9d, 16
  0055e	89 45 bc	 mov	 DWORD PTR here$[rbp-120], eax
  00561	3b ce		 cmp	 ecx, esi
  00563	77 9e		 ja	 SHORT $LL94@inflateBac
$LN375@inflateBac:

; 405  :                 }
; 406  :                 if (here.val < 16) {

  00565	66 41 83 f9 10	 cmp	 r9w, 16
  0056a	73 35		 jae	 SHORT $LN284@inflateBac

; 407  :                     DROPBITS(here.bits);

  0056c	8b ca		 mov	 ecx, edx
  0056e	41 d3 ee	 shr	 r14d, cl
  00571	8b c8		 mov	 ecx, eax
  00573	c1 e9 08	 shr	 ecx, 8
  00576	0f b6 c9	 movzx	 ecx, cl
  00579	2b f1		 sub	 esi, ecx

; 408  :                     state->lens[state->have++] = here.val;

  0057b	c1 e8 10	 shr	 eax, 16
  0057e	41 8b 8f 84 00
	00 00		 mov	 ecx, DWORD PTR [r15+132]
  00585	66 41 89 84 4f
	90 00 00 00	 mov	 WORD PTR [r15+rcx*2+144], ax
  0058e	41 ff 87 84 00
	00 00		 inc	 DWORD PTR [r15+132]
  00595	45 8b 87 84 00
	00 00		 mov	 r8d, DWORD PTR [r15+132]

; 409  :                 }

  0059c	e9 9a 01 00 00	 jmp	 $LN406@inflateBac
$LN284@inflateBac:

; 410  :                 else {
; 411  :                     if (here.val == 16) {

  005a1	0f b6 fa	 movzx	 edi, dl
  005a4	75 7d		 jne	 SHORT $LN286@inflateBac

; 412  :                         NEEDBITS(here.bits + 2);

  005a6	c1 e8 08	 shr	 eax, 8
  005a9	83 c7 02	 add	 edi, 2
  005ac	44 0f b6 e0	 movzx	 r12d, al
  005b0	3b f7		 cmp	 esi, edi
  005b2	73 37		 jae	 SHORT $LN106@inflateBac
$LL109@inflateBac:
  005b4	85 db		 test	 ebx, ebx
  005b6	75 18		 jne	 SHORT $LN114@inflateBac
  005b8	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  005bc	49 8b cd	 mov	 rcx, r13
  005bf	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  005c2	8b d8		 mov	 ebx, eax
  005c4	85 c0		 test	 eax, eax
  005c6	0f 84 15 08 00
	00		 je	 $LN369@inflateBac
  005cc	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN114@inflateBac:
  005d0	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  005d4	8b ce		 mov	 ecx, esi
  005d6	d3 e0		 shl	 eax, cl
  005d8	49 ff c0	 inc	 r8
  005db	44 03 f0	 add	 r14d, eax
  005de	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  005e2	ff cb		 dec	 ebx
  005e4	83 c6 08	 add	 esi, 8
  005e7	3b f7		 cmp	 esi, edi
  005e9	72 c9		 jb	 SHORT $LL109@inflateBac
$LN106@inflateBac:

; 413  :                         DROPBITS(here.bits);
; 414  :                         if (state->have == 0) {

  005eb	41 8b 87 84 00
	00 00		 mov	 eax, DWORD PTR [r15+132]
  005f2	41 8b cc	 mov	 ecx, r12d
  005f5	41 d3 ee	 shr	 r14d, cl
  005f8	41 2b f4	 sub	 esi, r12d
  005fb	85 c0		 test	 eax, eax
  005fd	0f 84 79 01 00
	00		 je	 $LN380@inflateBac

; 415  :                             strm->msg = (char *)"invalid bit length repeat";
; 416  :                             state->mode = BAD;
; 417  :                             break;
; 418  :                         }
; 419  :                         len = (unsigned)(state->lens[state->have - 1]);
; 420  :                         copy = 3 + BITS(2);

  00603	41 8b d6	 mov	 edx, r14d

; 421  :                         DROPBITS(2);

  00606	83 c6 fe	 add	 esi, -2			; fffffffeH
  00609	83 e2 03	 and	 edx, 3
  0060c	41 c1 ee 02	 shr	 r14d, 2
  00610	83 c2 03	 add	 edx, 3
  00613	ff c8		 dec	 eax
  00615	45 0f b7 8c 47
	90 00 00 00	 movzx	 r9d, WORD PTR [r15+rax*2+144]

; 422  :                     }

  0061e	e9 cf 00 00 00	 jmp	 $LN155@inflateBac
$LN286@inflateBac:

; 423  :                     else if (here.val == 17) {

  00623	44 0f b6 65 bd	 movzx	 r12d, BYTE PTR here$[rbp-119]
  00628	66 41 83 f9 11	 cmp	 r9w, 17
  0062d	75 62		 jne	 SHORT $LN142@inflateBac

; 424  :                         NEEDBITS(here.bits + 3);

  0062f	83 c7 03	 add	 edi, 3
  00632	3b f7		 cmp	 esi, edi
  00634	73 37		 jae	 SHORT $LN123@inflateBac
$LL126@inflateBac:
  00636	85 db		 test	 ebx, ebx
  00638	75 18		 jne	 SHORT $LN131@inflateBac
  0063a	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  0063e	49 8b cd	 mov	 rcx, r13
  00641	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00644	8b d8		 mov	 ebx, eax
  00646	85 c0		 test	 eax, eax
  00648	0f 84 93 07 00
	00		 je	 $LN369@inflateBac
  0064e	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN131@inflateBac:
  00652	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00656	8b ce		 mov	 ecx, esi
  00658	d3 e0		 shl	 eax, cl
  0065a	49 ff c0	 inc	 r8
  0065d	44 03 f0	 add	 r14d, eax
  00660	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  00664	ff cb		 dec	 ebx
  00666	83 c6 08	 add	 esi, 8
  00669	3b f7		 cmp	 esi, edi
  0066b	72 c9		 jb	 SHORT $LL126@inflateBac
$LN123@inflateBac:

; 425  :                         DROPBITS(here.bits);
; 426  :                         len = 0;
; 427  :                         copy = 3 + BITS(3);
; 428  :                         DROPBITS(3);

  0066d	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00672	41 8b cc	 mov	 ecx, r12d
  00675	41 d3 ee	 shr	 r14d, cl
  00678	41 2b c4	 sub	 eax, r12d
  0067b	41 8b d6	 mov	 edx, r14d
  0067e	03 f0		 add	 esi, eax
  00680	83 e2 07	 and	 edx, 7
  00683	41 c1 ee 03	 shr	 r14d, 3
  00687	83 c2 03	 add	 edx, 3
  0068a	33 c0		 xor	 eax, eax
  0068c	44 8b c8	 mov	 r9d, eax

; 429  :                     }

  0068f	eb 61		 jmp	 SHORT $LN155@inflateBac
$LN142@inflateBac:

; 430  :                     else {
; 431  :                         NEEDBITS(here.bits + 7);

  00691	83 c7 07	 add	 edi, 7
  00694	3b f7		 cmp	 esi, edi
  00696	73 37		 jae	 SHORT $LN140@inflateBac
$LL143@inflateBac:
  00698	85 db		 test	 ebx, ebx
  0069a	75 18		 jne	 SHORT $LN148@inflateBac
  0069c	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  006a0	49 8b cd	 mov	 rcx, r13
  006a3	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  006a6	8b d8		 mov	 ebx, eax
  006a8	85 c0		 test	 eax, eax
  006aa	0f 84 31 07 00
	00		 je	 $LN369@inflateBac
  006b0	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN148@inflateBac:
  006b4	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  006b8	8b ce		 mov	 ecx, esi
  006ba	d3 e0		 shl	 eax, cl
  006bc	49 ff c0	 inc	 r8
  006bf	44 03 f0	 add	 r14d, eax
  006c2	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  006c6	ff cb		 dec	 ebx
  006c8	83 c6 08	 add	 esi, 8
  006cb	3b f7		 cmp	 esi, edi
  006cd	72 c9		 jb	 SHORT $LL143@inflateBac
$LN140@inflateBac:

; 432  :                         DROPBITS(here.bits);
; 433  :                         len = 0;
; 434  :                         copy = 11 + BITS(7);
; 435  :                         DROPBITS(7);

  006cf	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
  006d4	41 8b cc	 mov	 ecx, r12d
  006d7	41 d3 ee	 shr	 r14d, cl
  006da	41 2b c4	 sub	 eax, r12d
  006dd	41 8b d6	 mov	 edx, r14d
  006e0	03 f0		 add	 esi, eax
  006e2	83 e2 7f	 and	 edx, 127		; 0000007fH
  006e5	41 c1 ee 07	 shr	 r14d, 7
  006e9	83 c2 0b	 add	 edx, 11
  006ec	33 c0		 xor	 eax, eax
  006ee	44 0f b7 c8	 movzx	 r9d, ax
$LN155@inflateBac:

; 436  :                     }
; 437  :                     if (state->have + copy > state->nlen + state->ndist) {

  006f2	45 8b 87 84 00
	00 00		 mov	 r8d, DWORD PTR [r15+132]
  006f9	41 8b 8f 80 00
	00 00		 mov	 ecx, DWORD PTR [r15+128]
  00700	41 03 4f 7c	 add	 ecx, DWORD PTR [r15+124]
  00704	41 8d 04 10	 lea	 eax, DWORD PTR [r8+rdx]
  00708	3b c1		 cmp	 eax, ecx
  0070a	77 70		 ja	 SHORT $LN380@inflateBac
  0070c	0f 1f 40 00	 npad	 4
$LL157@inflateBac:

; 438  :                         strm->msg = (char *)"invalid bit length repeat";
; 439  :                         state->mode = BAD;
; 440  :                         break;
; 441  :                     }
; 442  :                     while (copy--)
; 443  :                         state->lens[state->have++] = (unsigned short)len;

  00710	41 8b c0	 mov	 eax, r8d
  00713	66 45 89 8c 47
	90 00 00 00	 mov	 WORD PTR [r15+rax*2+144], r9w
  0071c	45 8b 87 84 00
	00 00		 mov	 r8d, DWORD PTR [r15+132]
  00723	45 8d 40 01	 lea	 r8d, DWORD PTR [r8+1]
  00727	45 89 87 84 00
	00 00		 mov	 DWORD PTR [r15+132], r8d
  0072e	83 c2 ff	 add	 edx, -1			; ffffffffH
  00731	75 dd		 jne	 SHORT $LL157@inflateBac

; 404  :                     PULLBYTE();

  00733	4c 8b 65 30	 mov	 r12, QWORD PTR in$[rbp-120]
  00737	49 8d 7f 70	 lea	 rdi, QWORD PTR [r15+112]
$LN406@inflateBac:

; 393  :                 state->mode = BAD;
; 394  :                 break;
; 395  :             }
; 396  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 397  : 
; 398  :             /* get length and distance code code lengths */
; 399  :             state->have = 0;
; 400  :             while (state->have < state->nlen + state->ndist) {

  0073b	41 8b 87 80 00
	00 00		 mov	 eax, DWORD PTR [r15+128]
  00742	41 03 47 7c	 add	 eax, DWORD PTR [r15+124]
  00746	44 3b c0	 cmp	 r8d, eax
  00749	0f 82 81 fd ff
	ff		 jb	 $LL92@inflateBac
  0074f	48 8b 7d c8	 mov	 rdi, QWORD PTR put$1$[rbp-120]
$LN499@inflateBac:

; 444  :                 }
; 445  :             }
; 446  : 
; 447  :             /* handle error breaks in while */
; 448  :             if (state->mode == BAD) break;

  00753	4c 8b 4d 28	 mov	 r9, QWORD PTR strm$[rbp-120]
$LN93@inflateBac:
  00757	41 81 7f 08 51
	3f 00 00	 cmp	 DWORD PTR [r15+8], 16209 ; 00003f51H
  0075f	0f 84 3d fd ff
	ff		 je	 $LN504@inflateBac

; 449  : 
; 450  :             /* check for end-of-block code (better have one) */
; 451  :             if (state->lens[256] == 0) {

  00765	66 41 83 bf 90
	02 00 00 00	 cmp	 WORD PTR [r15+656], 0
  0076e	75 29		 jne	 SHORT $LN299@inflateBac

; 452  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00770	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@

; 453  :                 state->mode = BAD;
; 454  :                 break;

  00777	e9 1a fd ff ff	 jmp	 $LN502@inflateBac
$LN380@inflateBac:

; 444  :                 }
; 445  :             }
; 446  : 
; 447  :             /* handle error breaks in while */
; 448  :             if (state->mode == BAD) break;

  0077c	4c 8b 4d 28	 mov	 r9, QWORD PTR strm$[rbp-120]
  00780	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
  00787	48 8b 7d c8	 mov	 rdi, QWORD PTR put$1$[rbp-120]
  0078b	49 89 41 20	 mov	 QWORD PTR [r9+32], rax
  0078f	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H
  00797	eb be		 jmp	 SHORT $LN93@inflateBac
$LN299@inflateBac:

; 455  :             }
; 456  : 
; 457  :             /* build code tables -- note: do not change the lenbits or distbits
; 458  :                values here (9 and 6) without reading the comments in inftrees.h
; 459  :                concerning the ENOUGH constants, which depend on those values */
; 460  :             state->next = state->codes;
; 461  :             state->lencode = (code const FAR *)(state->next);
; 462  :             state->lenbits = 9;
; 463  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  00799	45 8b 47 7c	 mov	 r8d, DWORD PTR [r15+124]
  0079d	49 8d 87 50 05
	00 00		 lea	 rax, QWORD PTR [r15+1360]
  007a4	49 8d 8f 10 03
	00 00		 lea	 rcx, QWORD PTR [r15+784]
  007ab	49 89 87 88 00
	00 00		 mov	 QWORD PTR [r15+136], rax
  007b2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007b7	4d 8d 8f 88 00
	00 00		 lea	 r9, QWORD PTR [r15+136]
  007be	49 89 47 60	 mov	 QWORD PTR [r15+96], rax
  007c2	49 8d 97 90 00
	00 00		 lea	 rdx, QWORD PTR [r15+144]
  007c9	49 8d 47 70	 lea	 rax, QWORD PTR [r15+112]
  007cd	b9 01 00 00 00	 mov	 ecx, 1
  007d2	c7 00 09 00 00
	00		 mov	 DWORD PTR [rax], 9
  007d8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007dd	e8 00 00 00 00	 call	 inflate_table

; 464  :                                 &(state->lenbits), state->work);
; 465  :             if (ret) {

  007e2	85 c0		 test	 eax, eax
  007e4	74 0c		 je	 SHORT $LN300@inflateBac

; 466  :                 strm->msg = (char *)"invalid literal/lengths set";

  007e6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@

; 467  :                 state->mode = BAD;
; 468  :                 break;

  007ed	e9 a0 fc ff ff	 jmp	 $LN509@inflateBac
$LN300@inflateBac:

; 469  :             }
; 470  :             state->distcode = (code const FAR *)(state->next);

  007f2	49 8b 87 88 00
	00 00		 mov	 rax, QWORD PTR [r15+136]

; 471  :             state->distbits = 6;

  007f9	49 8d 4f 74	 lea	 rcx, QWORD PTR [r15+116]

; 472  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  007fd	45 8b 87 80 00
	00 00		 mov	 r8d, DWORD PTR [r15+128]
  00804	4d 8d 8f 88 00
	00 00		 lea	 r9, QWORD PTR [r15+136]
  0080b	49 89 47 68	 mov	 QWORD PTR [r15+104], rax
  0080f	41 8b 47 7c	 mov	 eax, DWORD PTR [r15+124]
  00813	48 83 c0 48	 add	 rax, 72			; 00000048H
  00817	c7 01 06 00 00
	00		 mov	 DWORD PTR [rcx], 6
  0081d	49 8d 14 47	 lea	 rdx, QWORD PTR [r15+rax*2]
  00821	49 8d 87 10 03
	00 00		 lea	 rax, QWORD PTR [r15+784]
  00828	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0082d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00832	b9 02 00 00 00	 mov	 ecx, 2
  00837	e8 00 00 00 00	 call	 inflate_table

; 473  :                             &(state->next), &(state->distbits), state->work);
; 474  :             if (ret) {

  0083c	4c 8b 4d 28	 mov	 r9, QWORD PTR strm$[rbp-120]
  00840	44 8b 45 b8	 mov	 r8d, DWORD PTR left$1$[rbp-120]
  00844	85 c0		 test	 eax, eax
  00846	74 1b		 je	 SHORT $LN301@inflateBac

; 475  :                 strm->msg = (char *)"invalid distances set";

  00848	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set@
  0084f	45 33 d2	 xor	 r10d, r10d
  00852	49 89 41 20	 mov	 QWORD PTR [r9+32], rax

; 476  :                 state->mode = BAD;

  00856	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H
  0085e	e9 63 05 00 00	 jmp	 $LN489@inflateBac
$LN301@inflateBac:

; 477  :                 break;
; 478  :             }
; 479  :             Tracev((stderr, "inflate:       codes ok\n"));
; 480  :             state->mode = LEN;

  00863	4c 8b 65 30	 mov	 r12, QWORD PTR in$[rbp-120]
  00867	41 c7 47 08 48
	3f 00 00	 mov	 DWORD PTR [r15+8], 16200 ; 00003f48H
$LN302@inflateBac:

; 481  :                 /* fallthrough */
; 482  : 
; 483  :         case LEN:
; 484  :             /* use inflate_fast() if we have enough input and output */
; 485  :             if (have >= 6 && left >= 258) {

  0086f	83 fb 06	 cmp	 ebx, 6
  00872	0f 82 8e 00 00
	00		 jb	 $LN303@inflateBac
  00878	41 81 f8 02 01
	00 00		 cmp	 r8d, 258		; 00000102H
  0087f	0f 82 81 00 00
	00		 jb	 $LN303@inflateBac

; 486  :                 RESTORE();

  00885	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  00889	49 89 01	 mov	 QWORD PTR [r9], rax
  0088c	49 89 79 10	 mov	 QWORD PTR [r9+16], rdi
  00890	45 89 41 18	 mov	 DWORD PTR [r9+24], r8d
  00894	41 89 59 08	 mov	 DWORD PTR [r9+8], ebx

; 487  :                 if (state->whave < state->wsize)

  00898	41 8b 57 34	 mov	 edx, DWORD PTR [r15+52]
  0089c	45 89 77 48	 mov	 DWORD PTR [r15+72], r14d
  008a0	41 89 77 4c	 mov	 DWORD PTR [r15+76], esi
  008a4	41 39 57 38	 cmp	 DWORD PTR [r15+56], edx
  008a8	73 09		 jae	 SHORT $LN304@inflateBac

; 488  :                     state->whave = state->wsize - left;

  008aa	8b c2		 mov	 eax, edx
  008ac	41 2b c0	 sub	 eax, r8d
  008af	41 89 47 38	 mov	 DWORD PTR [r15+56], eax
$LN304@inflateBac:

; 489  :                 inflate_fast(strm, state->wsize);

  008b3	49 8b c9	 mov	 rcx, r9
  008b6	e8 00 00 00 00	 call	 inflate_fast

; 490  :                 LOAD();

  008bb	4c 8b 4d 28	 mov	 r9, QWORD PTR strm$[rbp-120]
  008bf	45 33 d2	 xor	 r10d, r10d
  008c2	49 8b 01	 mov	 rax, QWORD PTR [r9]
  008c5	49 8b 79 10	 mov	 rdi, QWORD PTR [r9+16]
  008c9	45 8b 41 18	 mov	 r8d, DWORD PTR [r9+24]
  008cd	41 8b 59 08	 mov	 ebx, DWORD PTR [r9+8]
  008d1	48 89 45 c0	 mov	 QWORD PTR next$[rbp-120], rax
  008d5	45 8b 77 48	 mov	 r14d, DWORD PTR [r15+72]
  008d9	41 8b 77 4c	 mov	 esi, DWORD PTR [r15+76]
  008dd	48 89 7d c8	 mov	 QWORD PTR put$1$[rbp-120], rdi
  008e1	44 89 45 b8	 mov	 DWORD PTR left$1$[rbp-120], r8d
  008e5	e9 dc 04 00 00	 jmp	 $LN489@inflateBac
$LN277@inflateBac:

; 370  :                 strm->msg = (char *)"too many length or distance symbols";
; 371  :                 state->mode = BAD;
; 372  :                 break;

  008ea	44 8b 45 b8	 mov	 r8d, DWORD PTR left$1$[rbp-120]
  008ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@
  008f5	49 89 41 20	 mov	 QWORD PTR [r9+32], rax
  008f9	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H
  00901	e9 c0 04 00 00	 jmp	 $LN489@inflateBac
$LN303@inflateBac:

; 491  :                 break;
; 492  :             }
; 493  : 
; 494  :             /* get a literal, length, or end-of-block code */
; 495  :             for (;;) {
; 496  :                 here = state->lencode[BITS(state->lenbits)];

  00906	41 8b 4f 70	 mov	 ecx, DWORD PTR [r15+112]
  0090a	bf 01 00 00 00	 mov	 edi, 1
  0090f	4d 8b 47 60	 mov	 r8, QWORD PTR [r15+96]
  00913	8b c7		 mov	 eax, edi
  00915	d3 e0		 shl	 eax, cl
  00917	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  0091a	41 8b c6	 mov	 eax, r14d
  0091d	48 23 c8	 and	 rcx, rax
  00920	41 8b 04 88	 mov	 eax, DWORD PTR [r8+rcx*4]
  00924	8b c8		 mov	 ecx, eax
  00926	c1 e9 08	 shr	 ecx, 8
  00929	0f b6 c9	 movzx	 ecx, cl

; 497  :                 if ((unsigned)(here.bits) <= bits) break;

  0092c	3b ce		 cmp	 ecx, esi
  0092e	76 53		 jbe	 SHORT $LN382@inflateBac
$LL165@inflateBac:

; 498  :                 PULLBYTE();

  00930	85 db		 test	 ebx, ebx
  00932	75 14		 jne	 SHORT $LN171@inflateBac
  00934	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00938	49 8b cd	 mov	 rcx, r13
  0093b	41 ff d4	 call	 r12
  0093e	8b d8		 mov	 ebx, eax
  00940	85 c0		 test	 eax, eax
  00942	0f 84 99 04 00
	00		 je	 $LN369@inflateBac
$LN171@inflateBac:
  00948	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  0094c	8b ce		 mov	 ecx, esi
  0094e	ff cb		 dec	 ebx
  00950	83 c6 08	 add	 esi, 8
  00953	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00956	48 ff 45 c0	 inc	 QWORD PTR next$[rbp-120]
  0095a	4d 8b 47 60	 mov	 r8, QWORD PTR [r15+96]
  0095e	d3 e0		 shl	 eax, cl
  00960	41 8b 4f 70	 mov	 ecx, DWORD PTR [r15+112]
  00964	44 03 f0	 add	 r14d, eax
  00967	8b c7		 mov	 eax, edi
  00969	41 8b d6	 mov	 edx, r14d
  0096c	d3 e0		 shl	 eax, cl
  0096e	ff c8		 dec	 eax
  00970	48 23 c2	 and	 rax, rdx
  00973	41 8b 04 80	 mov	 eax, DWORD PTR [r8+rax*4]
  00977	8b c8		 mov	 ecx, eax
  00979	c1 e9 08	 shr	 ecx, 8
  0097c	0f b6 c9	 movzx	 ecx, cl
  0097f	3b ce		 cmp	 ecx, esi
  00981	77 ad		 ja	 SHORT $LL165@inflateBac
$LN382@inflateBac:

; 499  :             }
; 500  :             if (here.op && (here.op & 0xf0) == 0) {

  00983	84 c0		 test	 al, al
  00985	0f 84 a9 00 00
	00		 je	 $LN184@inflateBac
  0098b	a8 f0		 test	 al, 240			; 000000f0H
  0098d	0f 85 a1 00 00
	00		 jne	 $LN184@inflateBac

; 501  :                 last = here;

  00993	8b c8		 mov	 ecx, eax

; 502  :                 for (;;) {
; 503  :                     here = state->lencode[last.val +

  00995	44 8b e0	 mov	 r12d, eax
  00998	c1 e9 08	 shr	 ecx, 8
  0099b	41 bd 01 00 00
	00		 mov	 r13d, 1
  009a1	0f b6 f9	 movzx	 edi, cl
  009a4	0f b6 c8	 movzx	 ecx, al
  009a7	03 cf		 add	 ecx, edi
  009a9	41 c1 ec 10	 shr	 r12d, 16
  009ad	41 d3 e5	 shl	 r13d, cl
  009b0	8b cf		 mov	 ecx, edi
  009b2	41 8d 45 ff	 lea	 eax, DWORD PTR [r13-1]
  009b6	41 23 c6	 and	 eax, r14d
  009b9	d3 e8		 shr	 eax, cl
  009bb	41 03 c4	 add	 eax, r12d
  009be	41 8b 04 80	 mov	 eax, DWORD PTR [r8+rax*4]
  009c2	8b c8		 mov	 ecx, eax
  009c4	c1 e9 08	 shr	 ecx, 8

; 504  :                             (BITS(last.bits + last.op) >> last.bits)];
; 505  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  009c7	0f b6 d1	 movzx	 edx, cl
  009ca	03 d7		 add	 edx, edi
  009cc	3b d6		 cmp	 edx, esi
  009ce	76 54		 jbe	 SHORT $LN185@inflateBac
$LL174@inflateBac:

; 506  :                     PULLBYTE();

  009d0	85 db		 test	 ebx, ebx
  009d2	75 15		 jne	 SHORT $LN180@inflateBac
  009d4	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  009d8	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  009dc	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  009df	8b d8		 mov	 ebx, eax
  009e1	85 c0		 test	 eax, eax
  009e3	0f 84 f8 03 00
	00		 je	 $LN369@inflateBac
$LN180@inflateBac:
  009e9	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  009ed	8b ce		 mov	 ecx, esi
  009ef	ff cb		 dec	 ebx
  009f1	83 c6 08	 add	 esi, 8
  009f4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  009f7	48 ff 45 c0	 inc	 QWORD PTR next$[rbp-120]
  009fb	d3 e0		 shl	 eax, cl
  009fd	8b cf		 mov	 ecx, edi
  009ff	44 03 f0	 add	 r14d, eax
  00a02	41 8d 45 ff	 lea	 eax, DWORD PTR [r13-1]
  00a06	41 23 c6	 and	 eax, r14d
  00a09	d3 e8		 shr	 eax, cl
  00a0b	41 8d 0c 04	 lea	 ecx, DWORD PTR [r12+rax]
  00a0f	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  00a13	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00a16	8b c8		 mov	 ecx, eax
  00a18	c1 e9 08	 shr	 ecx, 8
  00a1b	0f b6 d1	 movzx	 edx, cl
  00a1e	03 d7		 add	 edx, edi
  00a20	3b d6		 cmp	 edx, esi
  00a22	77 ac		 ja	 SHORT $LL174@inflateBac
$LN185@inflateBac:
  00a24	4c 8b 6d 38	 mov	 r13, QWORD PTR in_desc$[rbp-120]

; 507  :                 }
; 508  :                 DROPBITS(last.bits);

  00a28	8b cf		 mov	 ecx, edi
  00a2a	41 d3 ee	 shr	 r14d, cl
  00a2d	2b f7		 sub	 esi, edi
  00a2f	bf 01 00 00 00	 mov	 edi, 1
$LN184@inflateBac:

; 509  :             }
; 510  :             DROPBITS(here.bits);

  00a34	8b c8		 mov	 ecx, eax
  00a36	c1 e9 08	 shr	 ecx, 8
  00a39	0f b6 c9	 movzx	 ecx, cl
  00a3c	41 d3 ee	 shr	 r14d, cl
  00a3f	2b f1		 sub	 esi, ecx

; 511  :             state->length = (unsigned)here.val;

  00a41	8b c8		 mov	 ecx, eax
  00a43	c1 e9 10	 shr	 ecx, 16
  00a46	41 89 4f 50	 mov	 DWORD PTR [r15+80], ecx

; 512  : 
; 513  :             /* process literal */
; 514  :             if (here.op == 0) {

  00a4a	84 c0		 test	 al, al
  00a4c	75 5c		 jne	 SHORT $LN312@inflateBac

; 515  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 516  :                         "inflate:         literal '%c'\n" :
; 517  :                         "inflate:         literal 0x%02x\n", here.val));
; 518  :                 ROOM();

  00a4e	44 8b 65 b8	 mov	 r12d, DWORD PTR left$1$[rbp-120]
  00a52	45 85 e4	 test	 r12d, r12d
  00a55	75 2d		 jne	 SHORT $LN495@inflateBac
  00a57	45 8b 67 34	 mov	 r12d, DWORD PTR [r15+52]
  00a5b	45 8b c4	 mov	 r8d, r12d
  00a5e	49 8b 7f 40	 mov	 rdi, QWORD PTR [r15+64]
  00a62	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00a66	48 8b d7	 mov	 rdx, rdi
  00a69	4c 8b 6d 40	 mov	 r13, QWORD PTR out$[rbp-120]
  00a6d	45 89 67 38	 mov	 DWORD PTR [r15+56], r12d
  00a71	41 ff d5	 call	 r13
  00a74	85 c0		 test	 eax, eax
  00a76	74 10		 je	 SHORT $LN189@inflateBac
$LN394@inflateBac:

; 620  :             goto inf_leave;
; 621  :         }
; 622  : 
; 623  :     /* Write leftover output and return unused input */
; 624  :   inf_leave:
; 625  :     if (left < state->wsize) {

  00a78	be fb ff ff ff	 mov	 esi, -5
  00a7d	8b fe		 mov	 edi, esi
  00a7f	e9 8c 03 00 00	 jmp	 $inf_leave$513
$LN495@inflateBac:

; 515  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 516  :                         "inflate:         literal '%c'\n" :
; 517  :                         "inflate:         literal 0x%02x\n", here.val));
; 518  :                 ROOM();

  00a84	48 8b 7d c8	 mov	 rdi, QWORD PTR put$1$[rbp-120]
$LN189@inflateBac:

; 519  :                 *put++ = (unsigned char)(state->length);

  00a88	41 0f b6 47 50	 movzx	 eax, BYTE PTR [r15+80]
  00a8d	88 07		 mov	 BYTE PTR [rdi], al
  00a8f	48 ff c7	 inc	 rdi

; 520  :                 left--;

  00a92	41 ff cc	 dec	 r12d
  00a95	48 89 7d c8	 mov	 QWORD PTR put$1$[rbp-120], rdi
  00a99	44 89 65 b8	 mov	 DWORD PTR left$1$[rbp-120], r12d

; 521  :                 state->mode = LEN;

  00a9d	41 c7 47 08 48
	3f 00 00	 mov	 DWORD PTR [r15+8], 16200 ; 00003f48H

; 522  :                 break;

  00aa5	e9 12 03 00 00	 jmp	 $LN498@inflateBac
$LN312@inflateBac:

; 523  :             }
; 524  : 
; 525  :             /* process end of block */
; 526  :             if (here.op & 32) {

  00aaa	a8 20		 test	 al, 32			; 00000020H
  00aac	74 15		 je	 SHORT $LN315@inflateBac

; 527  :                 Tracevv((stderr, "inflate:         end of block\n"));
; 528  :                 state->mode = TYPE;
; 529  :                 break;

  00aae	48 8b 7d c8	 mov	 rdi, QWORD PTR put$1$[rbp-120]
  00ab2	44 8b 45 b8	 mov	 r8d, DWORD PTR left$1$[rbp-120]
  00ab6	41 c7 47 08 3f
	3f 00 00	 mov	 DWORD PTR [r15+8], 16191 ; 00003f3fH
  00abe	e9 fc 02 00 00	 jmp	 $LN501@inflateBac
$LN315@inflateBac:

; 530  :             }
; 531  : 
; 532  :             /* invalid code */
; 533  :             if (here.op & 64) {

  00ac3	a8 40		 test	 al, 64			; 00000040H
  00ac5	74 10		 je	 SHORT $LN316@inflateBac

; 534  :                 strm->msg = (char *)"invalid literal/length code";

  00ac7	48 8b 7d c8	 mov	 rdi, QWORD PTR put$1$[rbp-120]
  00acb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
  00ad2	e9 bb f9 ff ff	 jmp	 $LN509@inflateBac
$LN316@inflateBac:

; 535  :                 state->mode = BAD;
; 536  :                 break;
; 537  :             }
; 538  : 
; 539  :             /* length code -- get extra bits, if any */
; 540  :             state->extra = (unsigned)(here.op) & 15;

  00ad7	0f b6 c8	 movzx	 ecx, al
  00ada	83 e1 0f	 and	 ecx, 15
  00add	41 89 4f 58	 mov	 DWORD PTR [r15+88], ecx

; 541  :             if (state->extra != 0) {

  00ae1	74 59		 je	 SHORT $LN204@inflateBac

; 542  :                 NEEDBITS(state->extra);

  00ae3	3b f1		 cmp	 esi, ecx
  00ae5	73 43		 jae	 SHORT $LN192@inflateBac
  00ae7	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  00aeb	0f 1f 44 00 00	 npad	 5
$LL195@inflateBac:
  00af0	85 db		 test	 ebx, ebx
  00af2	75 18		 jne	 SHORT $LN200@inflateBac
  00af4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00af8	49 8b cd	 mov	 rcx, r13
  00afb	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00afe	8b d8		 mov	 ebx, eax
  00b00	85 c0		 test	 eax, eax
  00b02	0f 84 d9 02 00
	00		 je	 $LN369@inflateBac
  00b08	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN200@inflateBac:
  00b0c	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00b0f	8b ce		 mov	 ecx, esi
  00b11	d3 e0		 shl	 eax, cl
  00b13	48 ff c2	 inc	 rdx
  00b16	44 03 f0	 add	 r14d, eax
  00b19	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  00b1d	41 8b 4f 58	 mov	 ecx, DWORD PTR [r15+88]
  00b21	ff cb		 dec	 ebx
  00b23	83 c6 08	 add	 esi, 8
  00b26	3b f1		 cmp	 esi, ecx
  00b28	72 c6		 jb	 SHORT $LL195@inflateBac
$LN192@inflateBac:

; 543  :                 state->length += BITS(state->extra);

  00b2a	8b c7		 mov	 eax, edi
  00b2c	d3 e0		 shl	 eax, cl
  00b2e	ff c8		 dec	 eax
  00b30	41 23 c6	 and	 eax, r14d

; 544  :                 DROPBITS(state->extra);

  00b33	41 d3 ee	 shr	 r14d, cl
  00b36	41 01 47 50	 add	 DWORD PTR [r15+80], eax
  00b3a	2b f1		 sub	 esi, ecx
$LN204@inflateBac:

; 545  :             }
; 546  :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 547  : 
; 548  :             /* get distance code */
; 549  :             for (;;) {
; 550  :                 here = state->distcode[BITS(state->distbits)];

  00b3c	41 8b 4f 74	 mov	 ecx, DWORD PTR [r15+116]
  00b40	8b c7		 mov	 eax, edi
  00b42	4d 8b 4f 68	 mov	 r9, QWORD PTR [r15+104]

; 551  :                 if ((unsigned)(here.bits) <= bits) break;

  00b46	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
  00b4a	d3 e0		 shl	 eax, cl
  00b4c	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00b4f	41 8b c6	 mov	 eax, r14d
  00b52	48 23 c8	 and	 rcx, rax
  00b55	41 8b 04 89	 mov	 eax, DWORD PTR [r9+rcx*4]
  00b59	8b c8		 mov	 ecx, eax
  00b5b	c1 e9 08	 shr	 ecx, 8
  00b5e	0f b6 c9	 movzx	 ecx, cl
  00b61	3b ce		 cmp	 ecx, esi
  00b63	76 57		 jbe	 SHORT $LN387@inflateBac
$LL206@inflateBac:

; 552  :                 PULLBYTE();

  00b65	85 db		 test	 ebx, ebx
  00b67	75 18		 jne	 SHORT $LN212@inflateBac
  00b69	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00b6d	49 8b cd	 mov	 rcx, r13
  00b70	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00b73	8b d8		 mov	 ebx, eax
  00b75	85 c0		 test	 eax, eax
  00b77	0f 84 64 02 00
	00		 je	 $LN369@inflateBac
  00b7d	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN212@inflateBac:
  00b81	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00b85	8b ce		 mov	 ecx, esi
  00b87	d3 e0		 shl	 eax, cl
  00b89	49 ff c0	 inc	 r8
  00b8c	44 03 f0	 add	 r14d, eax
  00b8f	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  00b93	41 8b 4f 74	 mov	 ecx, DWORD PTR [r15+116]
  00b97	8b c7		 mov	 eax, edi
  00b99	4d 8b 4f 68	 mov	 r9, QWORD PTR [r15+104]
  00b9d	ff cb		 dec	 ebx
  00b9f	d3 e0		 shl	 eax, cl
  00ba1	83 c6 08	 add	 esi, 8
  00ba4	ff c8		 dec	 eax
  00ba6	41 8b d6	 mov	 edx, r14d
  00ba9	48 23 c2	 and	 rax, rdx
  00bac	41 8b 04 81	 mov	 eax, DWORD PTR [r9+rax*4]
  00bb0	8b c8		 mov	 ecx, eax
  00bb2	c1 e9 08	 shr	 ecx, 8
  00bb5	0f b6 c9	 movzx	 ecx, cl
  00bb8	3b ce		 cmp	 ecx, esi
  00bba	77 a9		 ja	 SHORT $LL206@inflateBac
$LN387@inflateBac:

; 553  :             }
; 554  :             if ((here.op & 0xf0) == 0) {

  00bbc	a8 f0		 test	 al, 240			; 000000f0H
  00bbe	0f 85 a1 00 00
	00		 jne	 $LN225@inflateBac

; 555  :                 last = here;

  00bc4	8b c8		 mov	 ecx, eax

; 556  :                 for (;;) {
; 557  :                     here = state->distcode[last.val +

  00bc6	44 8b e0	 mov	 r12d, eax
  00bc9	c1 e9 08	 shr	 ecx, 8
  00bcc	41 bd 01 00 00
	00		 mov	 r13d, 1
  00bd2	0f b6 f9	 movzx	 edi, cl
  00bd5	0f b6 c8	 movzx	 ecx, al
  00bd8	03 cf		 add	 ecx, edi
  00bda	41 c1 ec 10	 shr	 r12d, 16
  00bde	41 d3 e5	 shl	 r13d, cl
  00be1	8b cf		 mov	 ecx, edi
  00be3	41 8d 45 ff	 lea	 eax, DWORD PTR [r13-1]
  00be7	41 23 c6	 and	 eax, r14d
  00bea	d3 e8		 shr	 eax, cl
  00bec	41 03 c4	 add	 eax, r12d
  00bef	41 8b 04 81	 mov	 eax, DWORD PTR [r9+rax*4]
  00bf3	8b c8		 mov	 ecx, eax
  00bf5	c1 e9 08	 shr	 ecx, 8

; 558  :                             (BITS(last.bits + last.op) >> last.bits)];
; 559  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00bf8	0f b6 d1	 movzx	 edx, cl
  00bfb	03 d7		 add	 edx, edi
  00bfd	3b d6		 cmp	 edx, esi
  00bff	76 58		 jbe	 SHORT $LN226@inflateBac
$LL215@inflateBac:

; 560  :                     PULLBYTE();

  00c01	85 db		 test	 ebx, ebx
  00c03	75 19		 jne	 SHORT $LN221@inflateBac
  00c05	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  00c09	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00c0d	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00c10	8b d8		 mov	 ebx, eax
  00c12	85 c0		 test	 eax, eax
  00c14	0f 84 c7 01 00
	00		 je	 $LN369@inflateBac
  00c1a	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN221@inflateBac:
  00c1e	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00c22	8b ce		 mov	 ecx, esi
  00c24	d3 e0		 shl	 eax, cl
  00c26	49 ff c0	 inc	 r8
  00c29	44 03 f0	 add	 r14d, eax
  00c2c	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  00c30	41 8d 45 ff	 lea	 eax, DWORD PTR [r13-1]
  00c34	8b cf		 mov	 ecx, edi
  00c36	41 23 c6	 and	 eax, r14d
  00c39	ff cb		 dec	 ebx
  00c3b	d3 e8		 shr	 eax, cl
  00c3d	83 c6 08	 add	 esi, 8
  00c40	41 8d 0c 04	 lea	 ecx, DWORD PTR [r12+rax]
  00c44	49 8b 47 68	 mov	 rax, QWORD PTR [r15+104]
  00c48	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00c4b	8b c8		 mov	 ecx, eax
  00c4d	c1 e9 08	 shr	 ecx, 8
  00c50	0f b6 d1	 movzx	 edx, cl
  00c53	03 d7		 add	 edx, edi
  00c55	3b d6		 cmp	 edx, esi
  00c57	77 a8		 ja	 SHORT $LL215@inflateBac
$LN226@inflateBac:

; 561  :                 }
; 562  :                 DROPBITS(last.bits);

  00c59	8b cf		 mov	 ecx, edi
  00c5b	41 d3 ee	 shr	 r14d, cl
  00c5e	2b f7		 sub	 esi, edi
  00c60	bf 01 00 00 00	 mov	 edi, 1
$LN225@inflateBac:

; 563  :             }
; 564  :             DROPBITS(here.bits);

  00c65	8b c8		 mov	 ecx, eax
  00c67	c1 e9 08	 shr	 ecx, 8
  00c6a	0f b6 c9	 movzx	 ecx, cl
  00c6d	41 d3 ee	 shr	 r14d, cl
  00c70	2b f1		 sub	 esi, ecx

; 565  :             if (here.op & 64) {

  00c72	a8 40		 test	 al, 64			; 00000040H
  00c74	74 10		 je	 SHORT $LN327@inflateBac

; 566  :                 strm->msg = (char *)"invalid distance code";

  00c76	48 8b 7d c8	 mov	 rdi, QWORD PTR put$1$[rbp-120]
  00c7a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code@
  00c81	e9 0c f8 ff ff	 jmp	 $LN509@inflateBac
$LN327@inflateBac:

; 567  :                 state->mode = BAD;
; 568  :                 break;
; 569  :             }
; 570  :             state->offset = (unsigned)here.val;

  00c86	8b d0		 mov	 edx, eax

; 571  : 
; 572  :             /* get distance extra bits, if any */
; 573  :             state->extra = (unsigned)(here.op) & 15;

  00c88	0f b6 c8	 movzx	 ecx, al
  00c8b	c1 ea 10	 shr	 edx, 16
  00c8e	83 e1 0f	 and	 ecx, 15
  00c91	41 89 57 54	 mov	 DWORD PTR [r15+84], edx
  00c95	41 89 4f 58	 mov	 DWORD PTR [r15+88], ecx

; 574  :             if (state->extra != 0) {

  00c99	74 59		 je	 SHORT $LN242@inflateBac

; 575  :                 NEEDBITS(state->extra);

  00c9b	3b f1		 cmp	 esi, ecx
  00c9d	73 3f		 jae	 SHORT $LN230@inflateBac
  00c9f	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LL233@inflateBac:
  00ca3	85 db		 test	 ebx, ebx
  00ca5	75 19		 jne	 SHORT $LN238@inflateBac
  00ca7	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  00cab	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00caf	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00cb2	8b d8		 mov	 ebx, eax
  00cb4	85 c0		 test	 eax, eax
  00cb6	0f 84 25 01 00
	00		 je	 $LN369@inflateBac
  00cbc	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN238@inflateBac:
  00cc0	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00cc3	8b ce		 mov	 ecx, esi
  00cc5	d3 e0		 shl	 eax, cl
  00cc7	48 ff c2	 inc	 rdx
  00cca	44 03 f0	 add	 r14d, eax
  00ccd	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  00cd1	41 8b 4f 58	 mov	 ecx, DWORD PTR [r15+88]
  00cd5	ff cb		 dec	 ebx
  00cd7	83 c6 08	 add	 esi, 8
  00cda	3b f1		 cmp	 esi, ecx
  00cdc	72 c5		 jb	 SHORT $LL233@inflateBac
$LN230@inflateBac:

; 576  :                 state->offset += BITS(state->extra);

  00cde	8b c7		 mov	 eax, edi
  00ce0	d3 e0		 shl	 eax, cl
  00ce2	ff c8		 dec	 eax
  00ce4	41 23 c6	 and	 eax, r14d

; 577  :                 DROPBITS(state->extra);

  00ce7	41 d3 ee	 shr	 r14d, cl
  00cea	41 01 47 54	 add	 DWORD PTR [r15+84], eax
  00cee	41 8b 57 54	 mov	 edx, DWORD PTR [r15+84]
  00cf2	2b f1		 sub	 esi, ecx
$LN242@inflateBac:

; 578  :             }
; 579  :             if (state->offset > state->wsize - (state->whave < state->wsize ?

  00cf4	41 8b 4f 34	 mov	 ecx, DWORD PTR [r15+52]
  00cf8	45 33 d2	 xor	 r10d, r10d
  00cfb	41 39 4f 38	 cmp	 DWORD PTR [r15+56], ecx
  00cff	41 8b c2	 mov	 eax, r10d
  00d02	44 8b 65 b8	 mov	 r12d, DWORD PTR left$1$[rbp-120]
  00d06	48 8b 7d c8	 mov	 rdi, QWORD PTR put$1$[rbp-120]
  00d0a	41 0f 42 c4	 cmovb	 eax, r12d
  00d0e	2b c8		 sub	 ecx, eax
  00d10	3b d1		 cmp	 edx, ecx
  00d12	76 1f		 jbe	 SHORT $LL246@inflateBac

; 580  :                                                 left : 0)) {
; 581  :                 strm->msg = (char *)"invalid distance too far back";

  00d14	4c 8b 4d 28	 mov	 r9, QWORD PTR strm$[rbp-120]
  00d18	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@

; 582  :                 state->mode = BAD;
; 583  :                 break;

  00d1f	45 8b c4	 mov	 r8d, r12d
  00d22	49 89 41 20	 mov	 QWORD PTR [r9+32], rax
  00d26	41 c7 47 08 51
	3f 00 00	 mov	 DWORD PTR [r15+8], 16209 ; 00003f51H
  00d2e	e9 93 00 00 00	 jmp	 $LN489@inflateBac
$LL246@inflateBac:

; 584  :             }
; 585  :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 586  : 
; 587  :             /* copy match from window to output */
; 588  :             do {
; 589  :                 ROOM();

  00d33	45 85 e4	 test	 r12d, r12d
  00d36	75 25		 jne	 SHORT $LN247@inflateBac
  00d38	45 8b 67 34	 mov	 r12d, DWORD PTR [r15+52]
  00d3c	45 8b c4	 mov	 r8d, r12d
  00d3f	49 8b 7f 40	 mov	 rdi, QWORD PTR [r15+64]
  00d43	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00d47	48 8b d7	 mov	 rdx, rdi
  00d4a	4c 8b 6d 40	 mov	 r13, QWORD PTR out$[rbp-120]
  00d4e	45 89 67 38	 mov	 DWORD PTR [r15+56], r12d
  00d52	41 ff d5	 call	 r13
  00d55	85 c0		 test	 eax, eax
  00d57	0f 85 1b fd ff
	ff		 jne	 $LN394@inflateBac
$LN247@inflateBac:

; 590  :                 copy = state->wsize - state->offset;

  00d5d	41 8b 4f 54	 mov	 ecx, DWORD PTR [r15+84]

; 591  :                 if (copy < left) {

  00d61	45 8b c4	 mov	 r8d, r12d
  00d64	41 8b 47 34	 mov	 eax, DWORD PTR [r15+52]
  00d68	2b c1		 sub	 eax, ecx
  00d6a	41 3b c4	 cmp	 eax, r12d
  00d6d	73 0a		 jae	 SHORT $LN334@inflateBac

; 592  :                     from = put + copy;

  00d6f	8b d0		 mov	 edx, eax
  00d71	48 03 d7	 add	 rdx, rdi

; 593  :                     copy = left - copy;

  00d74	44 2b c0	 sub	 r8d, eax

; 594  :                 }

  00d77	eb 06		 jmp	 SHORT $LN335@inflateBac
$LN334@inflateBac:

; 595  :                 else {
; 596  :                     from = put - state->offset;

  00d79	48 8b d7	 mov	 rdx, rdi
  00d7c	48 2b d1	 sub	 rdx, rcx
$LN335@inflateBac:

; 597  :                     copy = left;
; 598  :                 }
; 599  :                 if (copy > state->length) copy = state->length;

  00d7f	41 8b 47 50	 mov	 eax, DWORD PTR [r15+80]

; 600  :                 state->length -= copy;

  00d83	44 3b c0	 cmp	 r8d, eax
  00d86	8b c8		 mov	 ecx, eax
  00d88	41 0f 46 c8	 cmovbe	 ecx, r8d
  00d8c	2b c1		 sub	 eax, ecx

; 601  :                 left -= copy;

  00d8e	44 2b e1	 sub	 r12d, ecx
  00d91	41 89 47 50	 mov	 DWORD PTR [r15+80], eax
  00d95	48 2b d7	 sub	 rdx, rdi
  00d98	44 89 65 b8	 mov	 DWORD PTR left$1$[rbp-120], r12d
  00d9c	0f 1f 40 00	 npad	 4
$LL252@inflateBac:

; 602  :                 do {
; 603  :                     *put++ = *from++;

  00da0	0f b6 04 3a	 movzx	 eax, BYTE PTR [rdx+rdi]
  00da4	88 07		 mov	 BYTE PTR [rdi], al
  00da6	48 ff c7	 inc	 rdi

; 604  :                 } while (--copy);

  00da9	83 c1 ff	 add	 ecx, -1			; ffffffffH
  00dac	75 f2		 jne	 SHORT $LL252@inflateBac

; 605  :             } while (state->length != 0);

  00dae	48 89 7d c8	 mov	 QWORD PTR put$1$[rbp-120], rdi
  00db2	41 39 4f 50	 cmp	 DWORD PTR [r15+80], ecx
  00db6	0f 85 77 ff ff
	ff		 jne	 $LL246@inflateBac
$LN498@inflateBac:

; 285  :     hold = 0;
; 286  :     bits = 0;
; 287  :     put = state->window;
; 288  :     left = state->wsize;
; 289  : 
; 290  :     /* Inflate until end of block marked as last */
; 291  :     for (;;)
; 292  :         switch (state->mode) {

  00dbc	45 8b c4	 mov	 r8d, r12d
$LN501@inflateBac:
  00dbf	45 33 d2	 xor	 r10d, r10d
$LN500@inflateBac:
  00dc2	4c 8b 4d 28	 mov	 r9, QWORD PTR strm$[rbp-120]
$LN489@inflateBac:
  00dc6	41 8b 47 08	 mov	 eax, DWORD PTR [r15+8]
  00dca	2d 3f 3f 00 00	 sub	 eax, 16191		; 00003f3fH
  00dcf	83 f8 12	 cmp	 eax, 18
  00dd2	77 2a		 ja	 SHORT $LN339@inflateBac
  00dd4	4c 8b 6d 38	 mov	 r13, QWORD PTR in_desc$[rbp-120]
  00dd8	4c 8b 65 30	 mov	 r12, QWORD PTR in$[rbp-120]
  00ddc	e9 be f2 ff ff	 jmp	 $LN505@inflateBac
$LN369@inflateBac:

; 620  :             goto inf_leave;
; 621  :         }
; 622  : 
; 623  :     /* Write leftover output and return unused input */
; 624  :   inf_leave:
; 625  :     if (left < state->wsize) {

  00de1	33 c0		 xor	 eax, eax
  00de3	48 89 45 c0	 mov	 QWORD PTR next$[rbp-120], rax
$LN372@inflateBac:
  00de7	be fb ff ff ff	 mov	 esi, -5
  00dec	8b fe		 mov	 edi, esi
  00dee	eb 18		 jmp	 SHORT $LN506@inflateBac
$LN337@inflateBac:

; 606  :             break;
; 607  : 
; 608  :         case DONE:
; 609  :             /* inflate stream terminated properly */
; 610  :             ret = Z_STREAM_END;
; 611  :             goto inf_leave;

  00df0	bf 01 00 00 00	 mov	 edi, 1
  00df5	eb 0c		 jmp	 SHORT $LN507@inflateBac
$LN338@inflateBac:

; 612  : 
; 613  :         case BAD:
; 614  :             ret = Z_DATA_ERROR;

  00df7	bf fd ff ff ff	 mov	 edi, -3

; 615  :             goto inf_leave;

  00dfc	eb 05		 jmp	 SHORT $LN507@inflateBac
$LN339@inflateBac:

; 616  : 
; 617  :         default:
; 618  :             /* can't happen, but makes compilers happy */
; 619  :             ret = Z_STREAM_ERROR;

  00dfe	bf fe ff ff ff	 mov	 edi, -2
$LN507@inflateBac:

; 620  :             goto inf_leave;
; 621  :         }
; 622  : 
; 623  :     /* Write leftover output and return unused input */
; 624  :   inf_leave:
; 625  :     if (left < state->wsize) {

  00e03	be fb ff ff ff	 mov	 esi, -5
$LN506@inflateBac:
  00e08	44 8b 65 b8	 mov	 r12d, DWORD PTR left$1$[rbp-120]
  00e0c	4c 8b 6d 40	 mov	 r13, QWORD PTR out$[rbp-120]
$inf_leave$513:
  00e10	45 8b 47 34	 mov	 r8d, DWORD PTR [r15+52]
  00e14	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]
  00e19	45 3b e0	 cmp	 r12d, r8d
  00e1c	73 18		 jae	 SHORT $LN490@inflateBac

; 626  :         if (out(out_desc, state->window, state->wsize - left) &&

  00e1e	49 8b 57 40	 mov	 rdx, QWORD PTR [r15+64]
  00e22	45 2b c4	 sub	 r8d, r12d
  00e25	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00e29	41 ff d5	 call	 r13
  00e2c	85 c0		 test	 eax, eax
  00e2e	74 06		 je	 SHORT $LN490@inflateBac
  00e30	83 ff 01	 cmp	 edi, 1
  00e33	0f 44 fe	 cmove	 edi, esi
$LN490@inflateBac:

; 627  :             ret == Z_STREAM_END)
; 628  :             ret = Z_BUF_ERROR;
; 629  :     }
; 630  :     strm->next_in = next;

  00e36	48 8b 45 28	 mov	 rax, QWORD PTR strm$[rbp-120]
  00e3a	48 8b 4d c0	 mov	 rcx, QWORD PTR next$[rbp-120]

; 631  :     strm->avail_in = have;
; 632  :     return ret;

  00e3e	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00e43	89 58 08	 mov	 DWORD PTR [rax+8], ebx
  00e46	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00e4b	48 89 08	 mov	 QWORD PTR [rax], rcx
  00e4e	8b c7		 mov	 eax, edi
  00e50	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]

; 633  : }

  00e55	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00e59	41 5f		 pop	 r15
  00e5b	41 5d		 pop	 r13
  00e5d	41 5c		 pop	 r12
  00e5f	5d		 pop	 rbp
  00e60	c3		 ret	 0
$LN254@inflateBac:

; 275  :         return Z_STREAM_ERROR;

  00e61	b8 fe ff ff ff	 mov	 eax, -2

; 633  : }

  00e66	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00e6a	41 5f		 pop	 r15
  00e6c	41 5d		 pop	 r13
  00e6e	41 5c		 pop	 r12
  00e70	5d		 pop	 rbp
  00e71	c3		 ret	 0
  00e72	66 90		 npad	 2
$LN481@inflateBac:
  00e74	00 00 00 00	 DD	 $LN255@inflateBac
  00e78	00 00 00 00	 DD	 $LN339@inflateBac
  00e7c	00 00 00 00	 DD	 $LN31@inflateBac
  00e80	00 00 00 00	 DD	 $LN339@inflateBac
  00e84	00 00 00 00	 DD	 $LN339@inflateBac
  00e88	00 00 00 00	 DD	 $LN56@inflateBac
  00e8c	00 00 00 00	 DD	 $LN339@inflateBac
  00e90	00 00 00 00	 DD	 $LN339@inflateBac
  00e94	00 00 00 00	 DD	 $LN339@inflateBac
  00e98	00 00 00 00	 DD	 $LN302@inflateBac
  00e9c	00 00 00 00	 DD	 $LN339@inflateBac
  00ea0	00 00 00 00	 DD	 $LN339@inflateBac
  00ea4	00 00 00 00	 DD	 $LN339@inflateBac
  00ea8	00 00 00 00	 DD	 $LN339@inflateBac
  00eac	00 00 00 00	 DD	 $LN339@inflateBac
  00eb0	00 00 00 00	 DD	 $LN339@inflateBac
  00eb4	00 00 00 00	 DD	 $LN339@inflateBac
  00eb8	00 00 00 00	 DD	 $LN337@inflateBac
  00ebc	00 00 00 00	 DD	 $LN338@inflateBac
inflateBack ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\infback.c
;	COMDAT inflateBackEnd
_TEXT	SEGMENT
strm$ = 48
inflateBackEnd PROC					; COMDAT

; 637  : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 638  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 28		 je	 SHORT $LN3@inflateBac
  0000e	48 8b 51 28	 mov	 rdx, QWORD PTR [rcx+40]
  00012	48 85 d2	 test	 rdx, rdx
  00015	74 1f		 je	 SHORT $LN3@inflateBac
  00017	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  0001b	48 85 c0	 test	 rax, rax
  0001e	74 16		 je	 SHORT $LN3@inflateBac

; 640  :     ZFREE(strm, strm->state);

  00020	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00024	ff d0		 call	 rax

; 641  :     strm->state = Z_NULL;
; 642  :     Tracev((stderr, "inflate: end\n"));
; 643  :     return Z_OK;

  00026	33 c0		 xor	 eax, eax
  00028	48 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [rbx+40], 0

; 644  : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
  00035	c3		 ret	 0
$LN3@inflateBac:

; 639  :         return Z_STREAM_ERROR;

  00036	b8 fe ff ff ff	 mov	 eax, -2

; 644  : }

  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5b		 pop	 rbx
  00040	c3		 ret	 0
inflateBackEnd ENDP
_TEXT	ENDS
END
