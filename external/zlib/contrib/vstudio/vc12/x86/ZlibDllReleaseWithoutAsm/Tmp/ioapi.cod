; Listing generated by Microsoft (R) Optimizing Compiler Version 19.36.32537.0 

	TITLE	c:\users\chris\documents\github\fastcopy-m\external\zlib\contrib\vstudio\vc12\x86\zlibdllreleasewithoutasm\tmp\ioapi.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_03HMFOOINA@r?$CLb@			; `string'
PUBLIC	??_C@_02GMLFBBN@wb@				; `string'
EXTRN	__imp___fseeki64:PROC
EXTRN	__imp__fread:PROC
EXTRN	__imp___ftelli64:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp__fseek:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__ferror:PROC
EXTRN	__imp__ftell:PROC
;	COMDAT ??_C@_02GMLFBBN@wb@
CONST	SEGMENT
??_C@_02GMLFBBN@wb@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HMFOOINA@r?$CLb@
CONST	SEGMENT
??_C@_03HMFOOINA@r?$CLb@ DB 'r+b', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
PUBLIC	_fill_fopen64_filefunc
PUBLIC	_fill_zlib_filefunc64_32_def_from_filefunc32
PUBLIC	_call_ztell64
PUBLIC	_call_zseek64
PUBLIC	_call_zopen64
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\ioapi.c
;	COMDAT _call_zopen64
_TEXT	SEGMENT
_mode$ = 8						; size = 4
_call_zopen64 PROC					; COMDAT
; _pfilefunc$ = ecx
; _filename$ = edx

; 31   : voidpf call_zopen64 (const zlib_filefunc64_32_def* pfilefunc, const void*filename, int mode) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 32   :     if (pfilefunc->zfile_func64.zopen64_file != NULL)

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 71 1c	 mov	 esi, DWORD PTR [ecx+28]
  00009	ff 75 08	 push	 DWORD PTR _mode$[ebp]
  0000c	52		 push	 edx
  0000d	56		 push	 esi
  0000e	85 c0		 test	 eax, eax
  00010	75 03		 jne	 SHORT $LN6@call_zopen

; 33   :         return (*(pfilefunc->zfile_func64.zopen64_file)) (pfilefunc->zfile_func64.opaque,filename,mode);
; 34   :     else
; 35   :     {
; 36   :         return (*(pfilefunc->zopen32_file))(pfilefunc->zfile_func64.opaque,(const char*)filename,mode);

  00012	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
$LN6@call_zopen:

; 37   :     }
; 38   : }

  00015	ff d0		 call	 eax
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001a	5e		 pop	 esi
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_call_zopen64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\ioapi.c
;	COMDAT _call_zseek64
_TEXT	SEGMENT
_offset$ = 8						; size = 8
_origin$ = 16						; size = 4
_call_zseek64 PROC					; COMDAT
; _pfilefunc$ = ecx
; _filestream$ = edx

; 40   : long call_zseek64 (const zlib_filefunc64_32_def* pfilefunc,voidpf filestream, ZPOS64_T offset, int origin) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	51		 push	 ecx

; 41   :     if (pfilefunc->zfile_func64.zseek64_file != NULL)

  00007	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0000a	56		 push	 esi
  0000b	85 c0		 test	 eax, eax
  0000d	74 17		 je	 SHORT $LN2@call_zseek

; 42   :         return (*(pfilefunc->zfile_func64.zseek64_file)) (pfilefunc->zfile_func64.opaque,filestream,offset,origin);

  0000f	ff 75 10	 push	 DWORD PTR _origin$[ebp]
  00012	ff 75 0c	 push	 DWORD PTR _offset$[ebp+4]
  00015	ff 75 08	 push	 DWORD PTR _offset$[ebp]
  00018	52		 push	 edx
  00019	ff 71 1c	 push	 DWORD PTR [ecx+28]
  0001c	ff d0		 call	 eax
  0001e	83 c4 14	 add	 esp, 20			; 00000014H

; 50   :     }
; 51   : }

  00021	5e		 pop	 esi
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
$LN2@call_zseek:

; 43   :     else
; 44   :     {
; 45   :         uLong offsetTruncated = (uLong)offset;

  00026	8b 45 08	 mov	 eax, DWORD PTR _offset$[ebp]

; 46   :         if (offsetTruncated != offset)

  00029	33 f6		 xor	 esi, esi
  0002b	3b 75 0c	 cmp	 esi, DWORD PTR _offset$[ebp+4]
  0002e	75 15		 jne	 SHORT $LN7@call_zseek

; 48   :         else
; 49   :             return (*(pfilefunc->zseek32_file))(pfilefunc->zfile_func64.opaque,filestream,offsetTruncated,origin);

  00030	ff 75 10	 push	 DWORD PTR _origin$[ebp]
  00033	50		 push	 eax
  00034	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00037	52		 push	 edx
  00038	ff 71 1c	 push	 DWORD PTR [ecx+28]
  0003b	ff d0		 call	 eax
  0003d	83 c4 10	 add	 esp, 16			; 00000010H

; 50   :     }
; 51   : }

  00040	5e		 pop	 esi
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
$LN7@call_zseek:

; 47   :             return -1;

  00045	83 c8 ff	 or	 eax, -1

; 50   :     }
; 51   : }

  00048	5e		 pop	 esi
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
_call_zseek64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\ioapi.c
;	COMDAT _call_ztell64
_TEXT	SEGMENT
_call_ztell64 PROC					; COMDAT
; _pfilefunc$ = ecx
; _filestream$ = edx

; 54   :     if (pfilefunc->zfile_func64.zseek64_file != NULL)

  00000	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00004	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00007	52		 push	 edx
  00008	50		 push	 eax
  00009	74 09		 je	 SHORT $LN2@call_ztell

; 55   :         return (*(pfilefunc->zfile_func64.ztell64_file)) (pfilefunc->zfile_func64.opaque,filestream);

  0000b	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0000e	ff d0		 call	 eax
  00010	83 c4 08	 add	 esp, 8

; 63   :     }
; 64   : }

  00013	c3		 ret	 0
$LN2@call_ztell:

; 56   :     else
; 57   :     {
; 58   :         uLong tell_uLong = (uLong)(*(pfilefunc->ztell32_file))(pfilefunc->zfile_func64.opaque,filestream);

  00014	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00017	ff d0		 call	 eax
  00019	83 c4 08	 add	 esp, 8

; 59   :         if ((tell_uLong) == MAXU32)

  0001c	83 f8 ff	 cmp	 eax, -1
  0001f	75 06		 jne	 SHORT $LN4@call_ztell

; 60   :             return (ZPOS64_T)-1;

  00021	0b c0		 or	 eax, eax
  00023	83 ca ff	 or	 edx, -1

; 63   :     }
; 64   : }

  00026	c3		 ret	 0
$LN4@call_ztell:

; 61   :         else
; 62   :             return tell_uLong;

  00027	33 d2		 xor	 edx, edx

; 63   :     }
; 64   : }

  00029	c3		 ret	 0
_call_ztell64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\ioapi.c
;	COMDAT _fill_zlib_filefunc64_32_def_from_filefunc32
_TEXT	SEGMENT
_fill_zlib_filefunc64_32_def_from_filefunc32 PROC	; COMDAT
; _p_filefunc64_32$ = ecx
; _p_filefunc32$ = edx

; 67   :     p_filefunc64_32->zfile_func64.zopen64_file = NULL;
; 68   :     p_filefunc64_32->zopen32_file = p_filefunc32->zopen_file;

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 69   :     p_filefunc64_32->zfile_func64.zread_file = p_filefunc32->zread_file;

  00005	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00008	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 70   :     p_filefunc64_32->zfile_func64.zwrite_file = p_filefunc32->zwrite_file;

  0000b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0000e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 71   :     p_filefunc64_32->zfile_func64.ztell64_file = NULL;
; 72   :     p_filefunc64_32->zfile_func64.zseek64_file = NULL;
; 73   :     p_filefunc64_32->zfile_func64.zclose_file = p_filefunc32->zclose_file;

  00011	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00014	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 74   :     p_filefunc64_32->zfile_func64.zerror_file = p_filefunc32->zerror_file;

  00017	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001a	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 75   :     p_filefunc64_32->zfile_func64.opaque = p_filefunc32->opaque;

  0001d	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00020	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 76   :     p_filefunc64_32->zseek32_file = p_filefunc32->zseek_file;

  00023	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00026	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 77   :     p_filefunc64_32->ztell32_file = p_filefunc32->ztell_file;

  00029	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0002c	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00032	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  00039	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00040	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 78   : }

  00043	c3		 ret	 0
_fill_zlib_filefunc64_32_def_from_filefunc32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\ioapi.c
;	COMDAT _fopen_file_func
_TEXT	SEGMENT
_opaque$ = 8						; size = 4
_filename$ = 12						; size = 4
_mode$ = 16						; size = 4
_fopen_file_func PROC					; COMDAT

; 82   : static voidpf ZCALLBACK fopen_file_func(voidpf opaque, const char* filename, int mode) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 83   :     FILE* file = NULL;
; 84   :     const char* mode_fopen = NULL;
; 85   :     (void)opaque;
; 86   :     if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)

  00003	8b 4d 10	 mov	 ecx, DWORD PTR _mode$[ebp]
  00006	33 d2		 xor	 edx, edx
  00008	8b c1		 mov	 eax, ecx
  0000a	24 03		 and	 al, 3
  0000c	3c 01		 cmp	 al, 1
  0000e	75 07		 jne	 SHORT $LN2@fopen_file

; 87   :         mode_fopen = "rb";

  00010	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_02JDPG@rb@
  00015	eb 17		 jmp	 SHORT $LN6@fopen_file
$LN2@fopen_file:

; 88   :     else
; 89   :     if (mode & ZLIB_FILEFUNC_MODE_EXISTING)

  00017	f6 c1 04	 test	 cl, 4
  0001a	74 07		 je	 SHORT $LN4@fopen_file

; 90   :         mode_fopen = "r+b";

  0001c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03HMFOOINA@r?$CLb@
  00021	eb 0b		 jmp	 SHORT $LN6@fopen_file
$LN4@fopen_file:

; 91   :     else
; 92   :     if (mode & ZLIB_FILEFUNC_MODE_CREATE)

  00023	f6 c1 08	 test	 cl, 8
  00026	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_02GMLFBBN@wb@
  0002b	0f 44 c2	 cmove	 eax, edx
$LN6@fopen_file:

; 93   :         mode_fopen = "wb";
; 94   : 
; 95   :     if ((filename!=NULL) && (mode_fopen != NULL))

  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _filename$[ebp]
  00031	85 c9		 test	 ecx, ecx
  00033	74 11		 je	 SHORT $LN9@fopen_file
  00035	85 c0		 test	 eax, eax
  00037	74 0d		 je	 SHORT $LN9@fopen_file

; 96   :         file = fopen(filename, mode_fopen);

  00039	50		 push	 eax
  0003a	51		 push	 ecx
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00041	83 c4 08	 add	 esp, 8

; 97   :     return file;
; 98   : }

  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
$LN9@fopen_file:
  00046	33 c0		 xor	 eax, eax
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
_fopen_file_func ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\ioapi.c
;	COMDAT _fopen64_file_func
_TEXT	SEGMENT
_opaque$ = 8						; size = 4
_filename$ = 12						; size = 4
_mode$ = 16						; size = 4
_fopen64_file_func PROC					; COMDAT

; 100  : static voidpf ZCALLBACK fopen64_file_func(voidpf opaque, const void* filename, int mode) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 101  :     FILE* file = NULL;
; 102  :     const char* mode_fopen = NULL;
; 103  :     (void)opaque;
; 104  :     if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)

  00003	8b 4d 10	 mov	 ecx, DWORD PTR _mode$[ebp]
  00006	33 d2		 xor	 edx, edx
  00008	8b c1		 mov	 eax, ecx
  0000a	24 03		 and	 al, 3
  0000c	3c 01		 cmp	 al, 1
  0000e	75 07		 jne	 SHORT $LN2@fopen64_fi

; 105  :         mode_fopen = "rb";

  00010	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_02JDPG@rb@
  00015	eb 17		 jmp	 SHORT $LN6@fopen64_fi
$LN2@fopen64_fi:

; 106  :     else
; 107  :     if (mode & ZLIB_FILEFUNC_MODE_EXISTING)

  00017	f6 c1 04	 test	 cl, 4
  0001a	74 07		 je	 SHORT $LN4@fopen64_fi

; 108  :         mode_fopen = "r+b";

  0001c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03HMFOOINA@r?$CLb@
  00021	eb 0b		 jmp	 SHORT $LN6@fopen64_fi
$LN4@fopen64_fi:

; 109  :     else
; 110  :     if (mode & ZLIB_FILEFUNC_MODE_CREATE)

  00023	f6 c1 08	 test	 cl, 8
  00026	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_02GMLFBBN@wb@
  0002b	0f 44 c2	 cmove	 eax, edx
$LN6@fopen64_fi:

; 111  :         mode_fopen = "wb";
; 112  : 
; 113  :     if ((filename!=NULL) && (mode_fopen != NULL))

  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _filename$[ebp]
  00031	85 c9		 test	 ecx, ecx
  00033	74 11		 je	 SHORT $LN9@fopen64_fi
  00035	85 c0		 test	 eax, eax
  00037	74 0d		 je	 SHORT $LN9@fopen64_fi

; 114  :         file = FOPEN_FUNC((const char*)filename, mode_fopen);

  00039	50		 push	 eax
  0003a	51		 push	 ecx
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00041	83 c4 08	 add	 esp, 8

; 115  :     return file;
; 116  : }

  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
$LN9@fopen64_fi:
  00046	33 c0		 xor	 eax, eax
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
_fopen64_file_func ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\ioapi.c
;	COMDAT _fread_file_func
_TEXT	SEGMENT
_opaque$ = 8						; size = 4
_stream$ = 12						; size = 4
_buf$ = 16						; size = 4
_size$ = 20						; size = 4
_fread_file_func PROC					; COMDAT

; 119  : static uLong ZCALLBACK fread_file_func(voidpf opaque, voidpf stream, void* buf, uLong size) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 120  :     uLong ret;
; 121  :     (void)opaque;
; 122  :     ret = (uLong)fread(buf, 1, (size_t)size, (FILE *)stream);

  00003	ff 75 0c	 push	 DWORD PTR _stream$[ebp]
  00006	ff 75 14	 push	 DWORD PTR _size$[ebp]
  00009	6a 01		 push	 1
  0000b	ff 75 10	 push	 DWORD PTR _buf$[ebp]
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00014	83 c4 10	 add	 esp, 16			; 00000010H

; 123  :     return ret;
; 124  : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
_fread_file_func ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\ioapi.c
;	COMDAT _fwrite_file_func
_TEXT	SEGMENT
_opaque$ = 8						; size = 4
_stream$ = 12						; size = 4
_buf$ = 16						; size = 4
_size$ = 20						; size = 4
_fwrite_file_func PROC					; COMDAT

; 126  : static uLong ZCALLBACK fwrite_file_func(voidpf opaque, voidpf stream, const void* buf, uLong size) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 127  :     uLong ret;
; 128  :     (void)opaque;
; 129  :     ret = (uLong)fwrite(buf, 1, (size_t)size, (FILE *)stream);

  00003	ff 75 0c	 push	 DWORD PTR _stream$[ebp]
  00006	ff 75 14	 push	 DWORD PTR _size$[ebp]
  00009	6a 01		 push	 1
  0000b	ff 75 10	 push	 DWORD PTR _buf$[ebp]
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  00014	83 c4 10	 add	 esp, 16			; 00000010H

; 130  :     return ret;
; 131  : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
_fwrite_file_func ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\ioapi.c
;	COMDAT _ftell_file_func
_TEXT	SEGMENT
_opaque$ = 8						; size = 4
_stream$ = 12						; size = 4
_ftell_file_func PROC					; COMDAT

; 133  : static long ZCALLBACK ftell_file_func(voidpf opaque, voidpf stream) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 134  :     long ret;
; 135  :     (void)opaque;
; 136  :     ret = ftell((FILE *)stream);

  00003	ff 75 0c	 push	 DWORD PTR _stream$[ebp]
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell
  0000c	83 c4 04	 add	 esp, 4

; 137  :     return ret;
; 138  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
_ftell_file_func ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\ioapi.c
;	COMDAT _ftell64_file_func
_TEXT	SEGMENT
_opaque$ = 8						; size = 4
_stream$ = 12						; size = 4
_ftell64_file_func PROC					; COMDAT

; 141  : static ZPOS64_T ZCALLBACK ftell64_file_func(voidpf opaque, voidpf stream) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 142  :     ZPOS64_T ret;
; 143  :     (void)opaque;
; 144  :     ret = (ZPOS64_T)FTELLO_FUNC((FILE *)stream);

  00003	ff 75 0c	 push	 DWORD PTR _stream$[ebp]
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___ftelli64
  0000c	83 c4 04	 add	 esp, 4

; 145  :     return ret;
; 146  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
_ftell64_file_func ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\ioapi.c
;	COMDAT _fseek_file_func
_TEXT	SEGMENT
_opaque$ = 8						; size = 4
_stream$ = 12						; size = 4
_offset$ = 16						; size = 4
_origin$ = 20						; size = 4
_fseek_file_func PROC					; COMDAT

; 148  : static long ZCALLBACK fseek_file_func(voidpf opaque, voidpf stream, uLong offset, int origin) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 149  :     int fseek_origin=0;
; 150  :     long ret;
; 151  :     (void)opaque;
; 152  :     switch (origin)

  00003	8b 45 14	 mov	 eax, DWORD PTR _origin$[ebp]
  00006	83 e8 00	 sub	 eax, 0
  00009	74 1d		 je	 SHORT $LN6@fseek_file
  0000b	83 e8 01	 sub	 eax, 1
  0000e	74 11		 je	 SHORT $LN4@fseek_file
  00010	83 e8 01	 sub	 eax, 1
  00013	74 05		 je	 SHORT $LN5@fseek_file

; 162  :         break;
; 163  :     default: return -1;

  00015	83 c8 ff	 or	 eax, -1

; 169  : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
$LN5@fseek_file:

; 157  :     case ZLIB_FILEFUNC_SEEK_END :
; 158  :         fseek_origin = SEEK_END;

  0001a	b8 02 00 00 00	 mov	 eax, 2

; 159  :         break;

  0001f	eb 09		 jmp	 SHORT $LN2@fseek_file
$LN4@fseek_file:

; 153  :     {
; 154  :     case ZLIB_FILEFUNC_SEEK_CUR :
; 155  :         fseek_origin = SEEK_CUR;

  00021	b8 01 00 00 00	 mov	 eax, 1

; 156  :         break;

  00026	eb 02		 jmp	 SHORT $LN2@fseek_file
$LN6@fseek_file:

; 160  :     case ZLIB_FILEFUNC_SEEK_SET :
; 161  :         fseek_origin = SEEK_SET;

  00028	33 c0		 xor	 eax, eax
$LN2@fseek_file:
  0002a	56		 push	 esi

; 164  :     }
; 165  :     ret = 0;
; 166  :     if (fseek((FILE *)stream, (long)offset, fseek_origin) != 0)

  0002b	50		 push	 eax
  0002c	ff 75 10	 push	 DWORD PTR _offset$[ebp]
  0002f	33 f6		 xor	 esi, esi
  00031	ff 75 0c	 push	 DWORD PTR _stream$[ebp]
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003d	83 c9 ff	 or	 ecx, -1
  00040	85 c0		 test	 eax, eax
  00042	0f 45 f1	 cmovne	 esi, ecx

; 167  :         ret = -1;
; 168  :     return ret;

  00045	8b c6		 mov	 eax, esi
  00047	5e		 pop	 esi

; 169  : }

  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
_fseek_file_func ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\ioapi.c
;	COMDAT _fseek64_file_func
_TEXT	SEGMENT
_opaque$ = 8						; size = 4
_stream$ = 12						; size = 4
_offset$ = 16						; size = 8
_origin$ = 24						; size = 4
_fseek64_file_func PROC					; COMDAT

; 171  : static long ZCALLBACK fseek64_file_func(voidpf opaque, voidpf stream, ZPOS64_T offset, int origin) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 172  :     int fseek_origin=0;
; 173  :     long ret;
; 174  :     (void)opaque;
; 175  :     switch (origin)

  00003	8b 45 18	 mov	 eax, DWORD PTR _origin$[ebp]
  00006	83 e8 00	 sub	 eax, 0
  00009	74 1d		 je	 SHORT $LN6@fseek64_fi
  0000b	83 e8 01	 sub	 eax, 1
  0000e	74 11		 je	 SHORT $LN4@fseek64_fi
  00010	83 e8 01	 sub	 eax, 1
  00013	74 05		 je	 SHORT $LN5@fseek64_fi

; 185  :         break;
; 186  :     default: return -1;

  00015	83 c8 ff	 or	 eax, -1

; 194  : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
$LN5@fseek64_fi:

; 180  :     case ZLIB_FILEFUNC_SEEK_END :
; 181  :         fseek_origin = SEEK_END;

  0001a	b8 02 00 00 00	 mov	 eax, 2

; 182  :         break;

  0001f	eb 09		 jmp	 SHORT $LN2@fseek64_fi
$LN4@fseek64_fi:

; 176  :     {
; 177  :     case ZLIB_FILEFUNC_SEEK_CUR :
; 178  :         fseek_origin = SEEK_CUR;

  00021	b8 01 00 00 00	 mov	 eax, 1

; 179  :         break;

  00026	eb 02		 jmp	 SHORT $LN2@fseek64_fi
$LN6@fseek64_fi:

; 183  :     case ZLIB_FILEFUNC_SEEK_SET :
; 184  :         fseek_origin = SEEK_SET;

  00028	33 c0		 xor	 eax, eax
$LN2@fseek64_fi:
  0002a	56		 push	 esi

; 187  :     }
; 188  :     ret = 0;
; 189  : 
; 190  :     if(FSEEKO_FUNC((FILE *)stream, (z_off64_t)offset, fseek_origin) != 0)

  0002b	50		 push	 eax
  0002c	ff 75 14	 push	 DWORD PTR _offset$[ebp+4]
  0002f	33 f6		 xor	 esi, esi
  00031	ff 75 10	 push	 DWORD PTR _offset$[ebp]
  00034	ff 75 0c	 push	 DWORD PTR _stream$[ebp]
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___fseeki64
  0003d	83 c4 10	 add	 esp, 16			; 00000010H
  00040	83 c9 ff	 or	 ecx, -1
  00043	85 c0		 test	 eax, eax
  00045	0f 45 f1	 cmovne	 esi, ecx

; 191  :                         ret = -1;
; 192  : 
; 193  :     return ret;

  00048	8b c6		 mov	 eax, esi
  0004a	5e		 pop	 esi

; 194  : }

  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
_fseek64_file_func ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\ioapi.c
;	COMDAT _fclose_file_func
_TEXT	SEGMENT
_opaque$ = 8						; size = 4
_stream$ = 12						; size = 4
_fclose_file_func PROC					; COMDAT

; 197  : static int ZCALLBACK fclose_file_func(voidpf opaque, voidpf stream) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     int ret;
; 199  :     (void)opaque;
; 200  :     ret = fclose((FILE *)stream);

  00003	ff 75 0c	 push	 DWORD PTR _stream$[ebp]
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0000c	83 c4 04	 add	 esp, 4

; 201  :     return ret;
; 202  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
_fclose_file_func ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\ioapi.c
;	COMDAT _ferror_file_func
_TEXT	SEGMENT
_opaque$ = 8						; size = 4
_stream$ = 12						; size = 4
_ferror_file_func PROC					; COMDAT

; 204  : static int ZCALLBACK ferror_file_func(voidpf opaque, voidpf stream) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 205  :     int ret;
; 206  :     (void)opaque;
; 207  :     ret = ferror((FILE *)stream);

  00003	ff 75 0c	 push	 DWORD PTR _stream$[ebp]
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ferror
  0000c	83 c4 04	 add	 esp, 4

; 208  :     return ret;
; 209  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
_ferror_file_func ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\chris\Documents\GitHub\FastCopy-M\external\zlib\contrib\minizip\ioapi.c
;	COMDAT _fill_fopen64_filefunc
_TEXT	SEGMENT
_fill_fopen64_filefunc PROC				; COMDAT
; _pzlib_filefunc_def$ = ecx

; 223  :     pzlib_filefunc_def->zopen64_file = fopen64_file_func;

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET _fopen64_file_func

; 224  :     pzlib_filefunc_def->zread_file = fread_file_func;

  00006	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET _fread_file_func

; 225  :     pzlib_filefunc_def->zwrite_file = fwrite_file_func;

  0000d	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], OFFSET _fwrite_file_func

; 226  :     pzlib_filefunc_def->ztell64_file = ftell64_file_func;

  00014	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], OFFSET _ftell64_file_func

; 227  :     pzlib_filefunc_def->zseek64_file = fseek64_file_func;

  0001b	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], OFFSET _fseek64_file_func

; 228  :     pzlib_filefunc_def->zclose_file = fclose_file_func;

  00022	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], OFFSET _fclose_file_func

; 229  :     pzlib_filefunc_def->zerror_file = ferror_file_func;

  00029	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET _ferror_file_func

; 230  :     pzlib_filefunc_def->opaque = NULL;

  00030	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 231  : }

  00037	c3		 ret	 0
_fill_fopen64_filefunc ENDP
_TEXT	ENDS
END
